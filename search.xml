<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[零基础超简单的入门级烘焙食谱 - 菠萝酥]]></title>
    <url>%2F2019%2F03%2F22%2F%E8%8F%A0%E8%90%9D%E9%85%A5%2F</url>
    <content type="text"><![CDATA[你以为这是徐福记凤梨酥那个“酥”吗？ NO！ 这是鲍师傅榴莲酥那个“酥”哈哈哈哈~ 这个点心是小胡入了烤箱后第一次尝试的烘焙食物，不过当时做的是香蕉酥，果然是入门级零基础的烘焙食物，烘焙处女作成品就好看又好吃，这也奠基了小胡对烘焙的信心哈哈哈哈。 工具烤箱、烤盘、锡纸（油纸）、刷子、分蛋器 食材蛋挞皮（6个）、菠萝（半个）、白糖（50g）、蛋黄（1个）、黑芝麻（少许） 步骤ღ 蛋挞皮室温解冻，去掉外面的锡纸，用分蛋器分出一个蛋黄打碎备用（蛋清在这个食谱中木有啥用，我用来腌肉了哈哈哈） ღ 菠萝切成小小丁，稍微碎一点，但是不要碎成渣啦，和白糖一起倒入锅内翻炒，炒到粘稠呈透明状就差不多了，盛出备用 ღ 烤盘上铺锡纸，薄薄地刷一层油，将菠萝馅放入蛋挞皮中，像捏饺子一样捏紧收口，然后放置于烤盘上 ღ 菠萝酥上刷一层蛋黄液，撒上少许黑芝麻 ღ 烤箱预热上下火190℃5分钟，然后烤盘放入中层烤制15分钟，出炉后放凉就OK啦 P.S. 每个烤箱的脾性不一样，所以温度和烤制时间可能会有偏差，不了解自己烤箱脾性的童鞋在烤制过程中要多关注下烤制程度，随时调整~ 夹心可以换成你想爱吃的呀，紫薯、芒果、香蕉、红豆、榴莲都阔以（若是做香蕉酥就直接把香蕉捣碎放进蛋挞皮中就妥啦） 嘻嘻嘻，刚出炉的菠萝酥真的是非常香了~这么简单又好吃的东西快试试吧~ 本食谱同步于公众号小胡不说八道（eateateat33）上，欢迎关注~]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>食谱</tag>
        <tag>烘焙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清新爽口的五彩菠萝炒饭--食谱]]></title>
    <url>%2F2019%2F03%2F21%2F%E8%8F%A0%E8%90%9D%E7%82%92%E9%A5%AD%2F</url>
    <content type="text"><![CDATA[昨日小胡出门溜达，一下子就被附近菜场10元5个菠萝的叫卖声吸引住了，一冲动就提了俩菠萝回家~(✿◡‿◡) 正好最近天热了，小胡的胃渴望一顿口味清新色彩丰富的午餐，于是就有了这份菠萝炒饭啦~♪(^∇^*) 食材米饭（1小碗）、鸡蛋（1个）、胡萝卜（半根）、火腿（半根）、豌豆（70g）、菠萝（半个）、小葱（少许）、食用油（少量）、盐（少许） 步骤☛ 胡萝卜洗净切丁，火腿切丁，菠萝切丁，豌豆洗净，鸡蛋打散，小葱切小段备用 ☛ 胡萝卜丁和豌豆先开水煮至七分熟，捞出沥水 ☛ 锅内倒少许油，中火将鸡蛋炒散，盛出备用 ☛ 锅内再倒少许油，煎炒火腿丁至表面微焦 ☛ 倒入沥干水的胡萝卜丁和豌豆一块儿翻炒 ☛ 倒入炒好的鸡蛋碎继续翻炒 ☛ 倒入米饭小火翻炒，炒至米饭分散后加入少许盐，倒入菠萝丁翻炒2分钟即可出锅 ☛ 出锅的炒饭上撒上香葱就可以开吃啦~~~ 再配上一碗甜甜的鸡汤，生活简直不要太美好哈哈哈哈~~ P.S. 鸡蛋其实一个就可以了，我那个刚好是双黄蛋哈哈哈 胡萝卜丁和豌豆比较难熟，最好开水烫几分钟，嫌麻烦也可以后面多放点油炒熟，我不喜油，所以选择烫熟啦 炒米饭的时候小火慢慢打散，火太大容易炒过头，毕竟想吃完美点的午餐也要多点耐心不是~~ 一定要注意火候，炒这个饭可不能急，大火很容易一不小心就糊了hhh，毕竟也不是重油爆炒的食物呀~~ 本食谱同步于公众号小胡不说八道（eateateat33）上，欢迎关注~]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>食谱</tag>
        <tag>一人食</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原味酥皮泡芙--食谱]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%8E%9F%E5%91%B3%E9%85%A5%E7%9A%AE%E6%B3%A1%E8%8A%99%2F</url>
    <content type="text"><![CDATA[泡芙是小胡的最爱，但是外面的泡芙要么太甜太腻，要么不酥不脆，所以自己动手，丰衣足食~(#^.^#) 虽然我也是参照别人的教程做的，但是稍微有做调整，下面为大家献上排过雷填过坑后我最满意的配方~(╹▽╹) 食材酥皮泡芙的材料需要分成三个部分制作，分别为酥皮、泡芙皮、夹心。以下原料为20个小泡芙的用量。 酥皮：黄油（40g）、糖粉（20g）、低筋面粉（50g） 泡芙皮：黄油（40g）、牛奶（80g）、白砂糖（3g）、低筋面粉（50g）、鸡蛋（2个） 夹心：淡奶油（150g）、白砂糖（15g） 制作步骤制作步骤同样分为三个部分，首先准备好酥皮，然后制作泡芙皮，烤泡芙的时候准备奶油夹心。 酥皮制作： 黄油室温软化，软化到用手指一压就能压下去的程度就好 加入糖粉和过筛的低粉，开始揉揉揉，揉成圆柱形，直径差不多跟挤在烤盘上的泡芙皮一样大就行 将揉好的圆柱柱仍冰箱里冷藏一下，为的是让其硬化，到时候好切成片，也不用太久了，不然到时候就切不动啦 泡芙皮制作： 将黄油、牛奶和白砂糖倒入奶锅加热，边加热边搅拌到沸腾 沸腾一分钟后开小火，倒入过筛的低粉并不停搅拌，这样可以让面粉充分吸收水分，然后就熟了哈哈哈，等充分搅拌到没有面粉粉了就关火，关火后再搅一搅，放凉 鸡蛋打成蛋液，等凉到不烫手时少量多次加入鸡蛋液，蛋液一定要慢慢加，加一点后充分混匀了再加 当搅到筷子提起来成倒三角就差不多了，就是提起来不会掉落，如果蛋液没用完也不要加了 将泡芙皮装入裱花袋 烤制过程： 烤箱200℃预热5分钟 装了泡芙皮的裱花袋剪一个小口子，然后将泡芙皮挤在铺了油纸的烤盘上，油纸上最好刷一层薄薄的油，到时候好脱模~挤的时候要垂直挤，下面要饱满点，烤的过程泡芙会变大，所以中间要留点空隙~（我挤着挤着就偏了，只能见缝插针地挤了哈哈哈） 取出酥皮，根据挤出来的泡芙个数决定切片厚度，我挤了20个泡芙，最后切了21片哈哈哈，将酥皮铺到泡芙上，放入烤箱 烤箱上下火180℃10分钟，这时候泡芙膨胀得差不多了，改为150℃25分钟，最后改成100℃10分钟，整个过程最好多看看烤制程度，好随时调整温度和时间 夹心制作： 我做的是纯奶油的，就将淡奶油和白砂糖倒入容器中用打蛋器打发，打到奶油硬挺就好了~ 将打发好的奶油装入裱花袋 成品制作： 烤好的泡芙冷却，底部戳个小洞洞，将奶油挤进去就好啦~~ P.S. 泡芙大小可以根据自己的口味调整，喜欢多奶油的就大一点，喜欢少奶油就小一点 白砂糖的量也可以自己稍微调整一下，我不喜欢太甜的，所以糖的用量不是很多 烤制过程中不要打开烤箱，不然容易导致泡芙坍塌 嘻嘻，没事儿的话就试试吧~~ 本食谱同步于公众号小胡不说八道（eateateat33）上，欢迎关注~]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>食谱</tag>
        <tag>烘焙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[挺好的]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%8C%BA%E5%A5%BD%E7%9A%84%2F</url>
    <content type="text"><![CDATA[记于2019/3/19 昨天跟一个不太熟的朋友吃饭，整个过程我话很少，基本上处于一问一答且回答非常简短的状态。 吃到一半时，他问我，你现在是不是语言表达能力下降了？ 我的语言表达能力下降了吗？好像是的，太久没有正常的社交，太久没有跟别人有正常的交流，独自生活了这么久，我好像不太会说话了，又好像是懒得说那么多话了。 我回他了一句：“嗯。” 之后觉得这种氛围好像有点尴尬，还是应该跟人家互动一下，只有内心OS却不跟别人交流这样不会形成恶性循环吗？然后我跟他讲了个冷笑话。 朋友们问我现在情况的时候，我通常只回答一句“挺好的”。但是这又显得太过敷衍，所以我后面会加一句“谢谢”，这样会显得比较真诚，然后对方还能回一句“不客气”，但是没有人回复过我“不客气”，好气哦。 这个笑话是真的冷，我都觉得自己被冷到了，他竟然笑了，他觉得很搞笑。 突然觉得内心有点小波澜，竟然有人能get到我这么冷的笑话。 ​ 下午有体育课，像初中上体育课一样，自由活动前要集体跑800米。 我很有信心，因为初中每次跑800米我都是第一个，大学体测800米都是满分，又到了我展示自己的时候了。 田径场对面有个同学在召唤我，我小跑过去，却发现脚步沉重，50米的距离跑得我气喘吁吁。 我在想这是怎么回事？我的身体怎么突然变得这么弱了？我的运动技能怎么消失了？以前那个操场上英姿飒爽的女子哪儿去了？现在连50米都跑不了了，那接下来的800米我要怎么完成？ 我顺手摸了摸自己的小短发，突然想起来，原来我生病了啊。 我算了算，从接受治疗到现在将近十个月了，十个月都没有运动，体力跟不上了啊，那还是得慢慢来，不着急。 然后我甩甩手，去跳起了广场舞。 ​ 隔壁传来一阵阵尖锐的电钻声，没拉紧的窗帘透进刺眼的阳光，我翻了个身，艰难地睁开了眼。 原来是梦啊，原来是梦哦，我嘴角上扬了一下，挺好的。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[div元素监听键盘事件]]></title>
    <url>%2F2019%2F02%2F09%2Fdiv%E5%85%83%E7%B4%A0%E7%9B%91%E5%90%AC%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近做表情联想时，踩了几个键盘监听事件的坑，总结一下~ 坑一：如何让div元素监听键盘不知道你们试没试过，直接给div绑定如keypress、keyup、keydown这种键盘事件是不管用的， 要想让某个div元素监听键盘事件，首先得让它获得焦点吧？不然人家都没有玉玺，哪来的皇权？ 1div.focus(); //div指的是那个想监听键盘事件的div~ 巴特，你以为div元素像input元素一样直接focus就能聚焦了？too young too naive~~像form中input、button、textarea这种可输入的元素和a这种链接元素是默认可获得焦点的，但是span、div这种元素可不行哇。因为他们缺少一个重要的属性：tabindex，给他们添加了tabindex属性后，就能指定他们可触焦了。 所以要想让div监听键盘事件，应该酱紫写： 123//需要给这个元素添加tabindex属性div.setAttribute('tabindex', '0');div.focus(); 给它绑定键盘事件，在合适的时候让它获得焦点，然后就能监听到键盘事件啦~~ 关于tabindextabindex属性用于管理键盘焦点，决定元素能否被选中，且指定了按下tab键时元素被选中的顺序。 像form表单元素及链接元素是默认可获得焦点的，所以即使不显式地设置其tabindex，按下tab键时，也能获得焦点，直接触发onfocus事件，而span这种元素就不行了，哪怕你点击这个span也木有用。试一试~ 如果想让span也能获取焦点，可以为这个span设置个tabindex，这样它也具有自动聚焦的能力啦~试一试~ tabindex可以设置为0、负值、正值： tabindex=0：表示在自然tab键顺序中插入一个元素，可以通过调用其focus方法聚焦该元素，也能通过tab键聚焦该元素。BTW，tab顺序就是你按tab键时元素获得焦点的顺序，默认就是在DOM中的位置顺序。 tabindex=负值：表示在自然tab键顺序中移除该元素，哟呵，移除了就不能通过tab键使其聚焦啦，不过还是可以调用focus方法聚焦的啦。这里的负值基本上就是-1啦，虽然你想设-5，-6，-7也没问题，但是没意义哇，就好像数组的indexof，若无匹配就返回-1，也不返回-2对吧？试一试~ tabindex=正值：显式地指定该元素在tab键顺序中的位置。其实tabindex就是tab+index嘛，index不就表示索引咯，咱对index的理解不就是越小越靠前嘛，tabindex也是哇(不包括0)。试一试~ 关于tabindex更多使用场景，请移步这里~ 坑二：Mac和win的快捷键不一致在Mac中，cmd+a默认是全选的快捷键，在Windows中，全选的快捷键是ctrl+a。我想做的交互是，表情联想面板出现时，不管焦点是否在表情联想面板上，全选的时候都选中输入框中的内容，如下图所示： 但是实际上，当div获取焦点后，cmd+a时是酱紫的： 诶？这不是我想要的效果哇，我应该要监听一下cmd+a的键盘事件，然后实现我想要的效果~但是cmd+a是Mac的全选快捷键，而在Windows上，对应的快捷键是ctrl+a，所以需要先判断一下操作系统，再重写对应的全选键盘事件。 window的navigator对象中，有个platform字段，声明了运行浏览器的操作系统和（或）硬件平台，咱可以用它来判断当前浏览器运行在哪个操作系统中： 12var isWin = (navigator.platform == "Win32") || (navigator.platform == "Windows");var isMac = (navigator.platform == "Mac68K") || (navigator.platform == "MacPPC") || (navigator.platform == "Macintosh") || (navigator.platform == "MacIntel"); 所以核心代码可以这样写： 1234567switch (true) &#123; case e.keyCode === KEY_A: //KEY_A = 65 if ((isMac &amp;&amp; e.metaKey) || (isWin &amp;&amp; e.ctrlKey)) &#123; //your code &#125; break;&#125; 完整的keycode在此~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>问题记录</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS制作半像素边框]]></title>
    <url>%2F2019%2F02%2F09%2FCSS%E5%88%B6%E4%BD%9C%E5%8D%8A%E5%83%8F%E7%B4%A0%E8%BE%B9%E6%A1%86%2F</url>
    <content type="text"><![CDATA[问题描述如果想给某个元素设置个0.5px的边框，你会怎么做？是直接设置border-width为0.5？ 1border-width: 0.5px; 可是这样浏览器真的能给你显示成0.5px的边框吗？哈哈哒，想多啦~ border-width只能为自然数，其他类似的属性也是一样样的，小于1px的线浏览器都直接显示成1px（当然，0px就没有了哈）。效果 所以，常规方式是不行哒，但是咱可以用伪元素+缩放来巧妙地实现~~ 实现方式大概思路就是用伪元素给该元素做个1px的框，这个框的大小是该元素的两倍，然后再缩小0.5倍，这样0.5px像素的框就出来啦~~具体步骤如下： 给目标元素设个定位参考，然后伪元素才能根据这个定位进行绝对定位 123span &#123; position: relative; /* 只要不是默认值static就好了，原因我想你们应该知道 */&#125; 给目标加个伪元素，并设置绝对定位 12345span:after &#123; position: absolute; top: 0; left: 0;&#125; 给伪元素加个1px的边框，并把高宽设为目标元素的两倍 123border: 1px solid #000;width: 200%;height: 200%; 然后缩小0.5倍，缩到目标元素的大小 12transform-origin: 0 0;transform: scale(0.5); 然后就差不多啦~~ 完整代码如下： 1234567891011121314span &#123; position: relative;&#125;span:after &#123; content: ''; position: absolute; top: 0; left: 0; border: 1px solid #000; width: 200%; height: 200%; transform-origin: 0 0; transform: scale(0.5);&#125; 具体效果看这里~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>问题记录</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的组长在中科院]]></title>
    <url>%2F2019%2F01%2F31%2F%E6%88%91%E7%9A%84%E7%BB%84%E9%95%BF%E5%9C%A8%E4%B8%AD%E7%A7%91%E9%99%A2%2F</url>
    <content type="text"><![CDATA[我经常跟别人说，我组长在中科院，带着骄傲的口吻。 不愉快的初识第一次跟这人打交道时，我真是打心底里觉得他讨厌。 大二上学期，一博拉了几个人组了个小团队参加第三届“数字中南”软创比赛。第一次开会地点定在创南二楼，那个灯光昏黄沙发老旧而且还是在走廊上的临时会议室，但那时候的我们热情洋溢啊，激情无限啊。就是在那个地方，我们第一次相识。 一博大概介绍了一下我们几个，几班的叫什么名字。他问我会PS吗，我说不太会。“那你得找个会PS的呀，找个什么都不会的来干嘛”，他冲一博说道。 我靠，这人怎么这么讨厌啊，不会可以学呀，我又不是不愿意学，说得好像你就什么都会了？当然这只是心理活动，没敢说出口。 “哎呀，不会很正常啊，现在边学边做还来得及，大家不都一开始啥都不会吗？”还是一博帮我圆的场。 就这样，我们这个参赛小组算成立了，之后就是各种开会讨论各种熬夜赶文档各种修修改改，将近一个月后的比赛上，算是取得了还可以的成绩，二等奖。但是跟组长并没有熟络起来，只是相互认识了。 小片段1：你怎么都不理我我走路容易发呆，然后会不自觉地低着头，所以经常看不到别人给我打招呼。 有次快期末，我去世纪楼复习。在教学楼走廊上，他迎面朝我走来，向我招手问好，但是我并没有看到。走近之后，他又朝我挥了挥手，我还是没有看到。当他从我身边走过，我隐约觉得刚刚旁边过了个人，但是也没有往后看。然后突然我的书包被人拍了一下，我往后一看，他站在我身后，问我怎么都不理他。 …….其实我真的只是没看到。 互损的相识跟组长真正熟起来还是因为软创。 我们院有个传统，大二下学期参加软创大赛，大三下学期参加服务外包大赛。而那一届的软创大赛正好由中南大学主办，由于有本场优势，大家组队报名格外积极。他们也是，大二上学期末，组长、一博、小易就已经商量好要一起组队，但是还缺一个做UI和前端的。他们仨一直在讨论找谁比较好，毕竟这个比赛对大家都很重要，都不愿意马虎随便。当时小易推荐了一个女生，组长推荐了我。 寒假在家时，组长来问我要不要一起参加软创比赛。我当然想都没想就同意加入啦。然后我们芒果团队就这样横空出世啦。后来听小易说，由于我们俩之前没有合作过，他还是比较倾向于他推荐的那个女生，但是组长动之以理劝服了他。这个理当然是上次合作比赛时我体现出的努力认真负责严谨啦，哈哈哈哈哈哈哈~ 这个比赛战线拉得很长，从4月份的初赛到11月份的决赛，要历经大半年。也就是在半年内，我跟组长一下子熟络起来。 以前的我，在生人面前讲话跟蚊子一样，长得也算秀气，总给人一种很文静的感觉。但是熟起来之后，我就会比较放得开了，大声说话大声笑，表情丰富动作搞笑。但是如论如何，我都说不出脏话。尽管大一时，我整个寝室的妹子们都是三句话离不开脏字，我被熏陶了整整一年也没能说出“我去”这类的词。很神奇，我跟他们混了才两个月，就彻底爆发了，从此淑女文静这类的词就跟我不沾边了。 有次赶文档，我们四个人找了个有Wi-Fi的饭店，吃完饭后就开始分工工作。我当时的任务是负责P图，整个UI的设计图要做出来，放到文档中。小易在做PPT，时不时也需要我P几个图标。图片做到一半时大家又随时提修改意见，搞得我很混乱。突然，我一放鼠标，说了句妈蛋！说完后我看向他们，发现他们都以一种不可思议的眼神盯着我，可能是在想，刚刚那句“妈蛋”是从你嘴里出来的吗？从这以后，我就对脏话再也不忌口了，尤其是面对他们的时候。 虽然创意有受到来自于部分同学和老师的质疑，但是我们听取多方意见后还是决定坚持自己的想法。幸运的是，我们的选择没有错，一路上我们破关斩将，先后以优异成绩通过了院里选拔，校内选拔，进入国家级复赛。进入了复赛也就意味着我们的创意被认同了，接下来就是将创意实现的问题了。其实我们几个人，除了一博，其他三个对安卓都是一窍不通，只能硬着头皮边学边做了。由于时间紧迫，暑假我们只能回家休息一个星期，其余时间都必须呆在学校里做这个项目。 一般一博和小易在寝室学习，我和组长就呆在实验室。每隔几天开一次会，验收上次布置的开发任务，讨论过程中遇到的困难及解决方案。一开始我的任务是美工，主要是负责界面设计实现。尽管我到处上网搜别人的UI，参考那些美观好看的界面，自己做出来的总是那么入不了眼。尴尬的是，自己看久了，并不觉得丑，可能是看习惯了。但是拿给他们看的时候，从他们的表情中就能看出我设计的界面有多难看。一博和小易只是面露难色，组长就会直接骂人。 组长说话很直接，从来不拐弯抹角拖泥带水。很多东西，好就是好，不好就是不好，他不会碍于跟你是同学或者是朋友就不好意思说。因为界面的事，我都被他骂哭过两次。一次是在寝室没日没夜做了三天，把最后成果发给他看的时候，他回了我几句话，“怎么这么难看啊，让你做个界面都做不出来，你活着还有什么意义？”比起愤怒，我更多的是委屈难过。不是因为他说的话，而是我认认真真做的东西，别人不认可，自己也不认可。那种不认可，才让我从心底里觉得自己无能没用。还有一次，是我们几个开会的时候。那次其实大家心情都挺压抑的，因为为这个比赛这个项目投入了这么多，准备了这么久，却不知道到底能不能完成。具体就不说了，反正是我被组长讲哭了。之后他们经常拿这个事儿来调侃组长，说他把我骂哭，哈哈哈哈。 但是这个事情也并没有影响到大家的感情，反而是彼此之间更加近了。毕竟是希望你变得更好，才会对你提要求提意见啊。严格点要求高点反而才能让自己发现可以做得更好~所以之后在其它的界面设计与实现的过程中，很明显就得心应手多了。 因为我和组长平常都在实验室，所以吃饭之类的也都是一块儿。我逮着机会就黑他气他，为了报两次眼泪之仇。那时候是夏天，长沙特别热，太阳特别毒，只是中午出去吃个饭也能晒成煤球。组长那时候有点胖，他说他要瘦成一道闪电，我说可是你已黑成一片乌云。 到决赛的时候，大家都卯足了劲儿，力求各个细节都做到完美，连答辩结束的鞠躬我们都排练了好多次。决赛分两天，第一天是现场体验，各个院长们（评审专家）会到每个小组的展台体验项目成果。我们在空闲时间还到别的参赛小组的展台看了他们的成果，有让我们觉得很惊艳的，当然也有我们觉得比较low的，其实是说不出的感觉。但是好在我们几个都非常自信我们的东西是最棒的，至少心理上气势上不能输人，哈哈哈哈。第二天是正式答辩，封闭式的，在小易条理清楚激情澎湃的演讲和我们仨个人默契的演示后，我们看到了各位老师眼中透漏出的满意。一出了答辩室，我们就非常激动地跳了起来，不是因为我们觉得我们要得第一了，而是因为整个过程我们都没有出错，至少没有遗憾，这就够了。 下午公布结果的时候，我们四个和导师坐在大展厅的第二排，我们看到大屏幕上我们的分数遥遥领先与第二名时，看到评审老师们将大多数的票投给了“手绘心语”时，每个人都哭了，眼泪夺眶而出，彼此之间没有一句话也没有一个眼神，那半分钟内，大家只是盯着屏幕流眼泪。这是我们最骄傲的一刻，大半年来的努力得到了最好的回报。 那半年，是我最认真最专注地去做一件事的一段日子，可能对组长对一博对小易也都是这样。遇到困难时，我们一起想办法解决；受到质疑时，我们一同坚定选择；不管谁有了进步，大家都很开心地鼓励；时间空闲时，我们也会约好出去浪。我们的合作有过争吵，但是我们从来对事不对人，上一秒吵完，下一秒就能给对方抛一句，”走，吃饭去！”正是这个比赛，让原本不太熟悉的几个人，变得像亲人一样亲近。 小片段2：R和L不分组长是河北人，他R和L不分。 我们确定了比赛创意后决定去长沙特殊教育学校调研，当时是4月的春天，穿的还不少。我们几个坐公交辗转到了学校附近的时候已是下午2点，那天特别热，温度高太阳毒，每个人都热得脸红扑扑的。 过了个地下通道后，我听到组长说了句，“好乐好乐。” 我一脸无语，“这有什么乐的，热都热死了。“ “对啊，我就是说好乐啊。” ”对啊，我就说有什么乐的呀。“ “难道你不觉得乐吗？” “我就觉得热呀，虽然是挺激动，但是也不至于乐呀。” 他急了，说他R和L不分，他就是说的热！ 哈哈哈哈哈，简直要把我们几个笑死了，只知道湖南人N和L不分，还不知道有R和L不分的。 就因为R和L不分，他被我们嘲笑过无数次，尤其是在说“肉”的时候，总是会说成“漏”。 他会说，我不吃猪“漏”。有次我教他，“r-ou-肉”。他学，“r-ou-漏”。哈哈哈，饭都差点喷出来了。 我问他，你能发出rose的音吗？奇怪的是，他rose这个单词说得还蛮好的。 “那肉就跟rose前面那个ro发音差不多，你试试。” “ro—-se，r—-lou”，我勒个去。简直被气死，rose明明发的好好的，一意识到要说“肉”了就变成“漏”了。 我说他比较适合去学日语韩语，毕竟他们也是发不出r的音，哈哈哈。 小片段3：我不吃猪肉组长很奇怪的，他不吃猪肉。 我问他，你为什么不吃猪肉啊？你是回族人吗？还是有什么信仰？ “不是啊，我只是单纯地不吃猪肉，如果我知道这是猪肉的话就不想吃了。” “那你要是不知道这是猪肉，你就会吃咯？” “对啊，所以有时候家里做猪肉都不会告诉我这是猪肉，会说这是牛肉。” “那你这就奇怪了，你又吃不出猪肉还嫌弃猪肉。” 但是这有一个好处，我可以欺负他，让他自愿把肉让给我吃，哈哈哈。 我们去吃米粉，他喜欢点排骨面，我喜欢点肉丝粉。等到他的餐上来了，我会告诉他，其实这个排骨上的肉是猪肉，名副其实的猪肉。一开始他会抗拒听我说，但是吃了一块之后就下不去口了，就只好排骨入我碗了，哈哈哈。藜爷经常说，这绝对是亲组员，这么坑组长的。 小片段4：生日快乐暑假有一周的假期，刚好可以陪我们过个生日，而组长生日在我妈前一天。 “要不你去我家过生日吧，跟我妈一块儿过，可以尝尝我爸的厨艺。” 回家后听我妈说我爸去市里陪外公做手术了，这两天还回不来，我就没喊组长来我家玩了，可怕的是，在家太悠闲忘了他的生日。 那天下午他给我发了微信，说今天是他生日。我突然想起来，但是不好意思再说生日快乐，就回了句，我知道呀。 过了很久，他又给我发了消息。你们竟然都忘了我的生日，我等你们给我说生日快乐都等了一天了，你们是我最重要的朋友，但是竟然连我生日都忘了，知道还不给我说生日快乐。他的话语中带着气愤，带着责备，而更多的是失望。那一刻，我突然意识到，原来我们是特别好的朋友。 以前的我是个很慢热的人，也特别不愿意主动，很有自己的小世界，我的朋友们一般是比较有主动性的，因为如果她们不主动我可能就不会跟她们成好朋友了。那天我突然意识到，其实我们几个对彼此而言都是很重要的，彼此都在对方心里占据着不一般的地位，那种并肩作战的战友情，是一般同学比不上的。 我很羞愧，给组长发了个红包，并附上了迟到的“生日快乐”。但是过了一会儿，他把红包退了回来。他不是来讨红包讨礼物的，他只是希望能得到我们平等的重视。可是这个道理我后来才明白。 知根知底的熟识如果说软创那段时光让我们成为了好朋友，那在英特尔实习那节经历则让我们成为了亲人。 软创拿了特等奖，我们几个都有去英特尔实习的机会。虽说是可以直接去实习，其实就相当于有个内推，进不进还是得像招实习生一样面试。一博大概3月份就过去了，他想早早去接触底层的内容。我跟组长是7月底到的上海，其实还没有确定能进英特尔，但是我俩就是这么义无反顾地各自从家里拖着行李箱踏上了去上海的火车。 到了上海的前几天，因为还没确定工作，不敢租房子，所以组长住一博那儿，我住酒店里。但是第一天，我们仨在一个特别不正宗的桑拿麻将房里睡了一夜，那绝对是我这辈子睡得最不安心的一觉。具体情况就不说了，但是那次之后我就发誓再也不睡这种地方了，整晚提心吊胆，简直没法睡觉。感动的是，他俩陪着我在那个破地方睡了一夜，这是唯一让我觉得安心的部分了。 在外面住了几天后，我们的工作确定下来了，可以开始租房子了。那几天，我们白天就在公司餐厅坐着，没那么炎热的时候就出去看房子，基本上都是组长在网上找房源并联系，我也就是跟着他去看看房子。最后很快就定下来住塘泾南苑了，他住9楼，我住6楼。事后闺蜜们说我真有勇气，一切都未知的情况下拖着箱子就走了。说实话，活那么大我都没有出过远门，虽然从小自立自强，但是多年来不是在家就是在学校，并没有独自在陌生城市生活的经历。更别说在毫无准备的情况下就只身跑上海租房实习。但是很幸运，有这几个小伙伴在身边，尤其是我那超级靠谱的组长，带领我找到工作确定住所过上了钱不多但滋润的小日子~ 实习期间，我俩每天中午一块儿吃饭，下班一块儿回家，每天谈天说地，连对方七大姑八大姨家里的情况都了如指掌。 小片段5：杭州游9月初组里两个墨西哥同事过来出差，想去杭州游玩，组里同事周六都忙，所以带他们逛杭州的任务就光荣地交到我们身上了。 周六我们四点半就起床，收拾收拾就搭上去酒店的公交。我们要去酒店接那两位国际友人一块儿去高铁站，但是我们又没钱打车，只能赶早坐一个半小时的公交过去。 那是我们第一次进五星级酒店，服务员都非常礼貌，且都会说英语，我们心里暗暗想，连服务员英语都比我们好啊。 到了杭州后林璞学长担任了我们的导游。我们口语都不怎么样，我可能稍微好点，但是不太敢说，而林学长虽然英语口语不怎样，胆子却是很大，一路上跟两位国际友人聊得甚欢。只是讲的非常Chiglish，很多我都听不下去那两位友人竟然一直点头表示听懂了，我也是笑了一路啊~ 在参观雷锋塔时，我用蹩脚的英语给他们大致讲了白蛇传的传说，第二天他们跟经理吃饭时说到法海，经理他们表示很惊讶，我们连法海都给他们讲了哈哈哈哈哈。 小片段6：你怎么这么瘦成这个样子了组长到了上海后就开始减肥，每天跟着斗鱼健身直播做1小时的健身运动，每天的吃食也是减肥餐，在公司食堂吃饭时，吃的比我还少！ 3个月后，我换了个手机，午后散步时，我拿着新手机到处拍，无意间将他拍进了画面。看到照片中的他，我突然发现，他怎么偷偷地瘦了这么多！由于我们每天都呆一块，他一点点掉肉我也没发现，待我发现时他已经减掉30斤肉肉了！ 然后我跟了上去，惊叹一句：“你怎么瘦成这个样子了！” 8月刚到上海时还是个有小肚子的小胖子，突然就成了个有腹肌的小瘦子，3个月减30斤，也难怪那个健身主播邀请他去北京参加年会！ 小片段7：我都等了你一辈子了下午吃午饭前，我们都会去上个厕所。 女生嘛，上厕所总会比男生慢很多，刚好那天人又挺多，让他等了好久。 我一出来，他就冲我说了句：“你怎么这么慢啊，我都等了你一辈子了！” 简直要笑死我了，不知道的还以为这是在求婚呢！ 小片段8：我要晕了某天上班时肚子不舒服，疼痛难忍。待舒服一些后，我拿上水杯去外面走廊接水。 刚接了水，就感觉视线模糊，耳鸣，浑身无力，我意识到自己可能是犯低血糖要晕了。然后我赶紧将水杯放在饮水机旁边的垃圾桶上，摇摇晃晃地进了实验室。 进了实验室后，我拍了他一下，说了句“等会儿我晕了你帮我下去拿点糖”，然后就躺尸在椅子上了。 他还以为我在开玩笑，还问我是不是傻！ 但是我后面真的晕了，醒来后组长给我拿来了水杯和糖，还表示你刚刚真的晕了啊，太可怕了！ 哈哈哈哈哈，笑死我了，感觉把组长吓得不轻啊。 各奔东西大学毕业后，我去了浙大，组长去了中科院，我们各奔东西。 我们联系的不多，本身我就是不太爱与人联系的性格。偶尔联系也不会装模作样地嘘寒问暖而是直接切入正题，很久不联系也不会觉得生疏，依旧能扯天扯地。 研究生期间偶尔通个电话聊聊最近的生活和学习，组长会跟我聊最近正在追求的女孩，聊室友的奇葩女友，我会跟组长说追我的男孩，实验室的趣事。 刚实习时由于租完房子资金紧缺，二话不说就转账过来，还让我不急着还，生活还是要过好。由于刚到上海时我和组长都是租了房子就穷成狗，又倔强地不向家里求助，过了一个月苦日子。可能是怕我在杭州也像初到上海时那么两两算计着，所以会时不时在网上给我订零食，新鲜水果啥的，所以当时小日子还是挺富余的哈哈哈哈哈。 有天晚上组长给我打了个电话，那时我们已经很久很久没有通过电话了，只是偶尔微信联系。接到电话后就只听到听筒里传来的啜泣声，慢慢变成了嚎啕大哭，又渐渐平息。整个过程持续了好几分钟，我们一句话都没说，我不知道发生了什么，所以不敢乱说话。那几分钟内我想了好多种可能，能让一个男生哭得这么伤心怕不是家里出事了吧，我还在想如果真是这样我又要怎么安慰呢，毕竟我可能也帮不到什么。然后组长开始说话了，虽然吐字模糊且语无伦次，但我大概听出来并不是出了什么事。而是同学聚餐，组长喝了点酒，加上那段时间压力比较大，觉得周围的同学都那么牛逼，自己学起来有点吃力，又有点迷茫看不到未来的样子，所以很难受。可是组长啊，那可是中科院啊，能跟那些大牛们做同学本身就很牛逼了啊！ 那一次我意识到，组长是真的很信任我吧，像亲人那样信任。 小片段9：你就没有她聪明英特尔的小宝哥知道组长打算去中科院，我打算去浙大的时候，就说了句：“*你真是没有33聪明啊！” 我们俩都一脸懵逼，没听懂啥意思。 小宝哥接着说：“浙江多么好的地方，好山好水又养人，人家去浙江待一年长寿两年，你去北京待一年折寿两年，划不来啊！” 哈哈哈哈哈哈哈，简直要笑死我了。 讲不清的亲人关系在我心里，我组长就是我的亲人，但是既不像哥哥更不像弟弟，而是一种讲不清的亲人关系。 在杭州实习了半年后我就去了北京，开启了另一段实习生活。虽然我跟组长同在北京，但是基本上没见过几次面，一开始是因为我刚入职想尽管进入状态所以比较忙，组长约了我好几次我不是在加班就是有团建活动。而后生日时跟闺蜜去近郊玩去了，又放了组长一次鸽子。估计组长肯定很生气吧哈哈哈哈哈。 年前终于约成功了，吃完饭后我又扔下组长去找我室友浪去了。就是这一次之后，估计组长对我失望到不行了，然后咱俩就不怎么联系了。 再一次联系是差不多半年后，我生了重病住院治疗，组长看到了我在知乎上的回答，然后约上了一博和小易一起来探望我。刚好藜爷也说要回来看我，然后他们就天南地北地从各地赶回来在我狭小的病房里挤着，对了，还有蠢蠢的潇潇。组长从北京来，一博从上海来，潇潇从杭州来，小易和藜爷从深圳来，而我在长沙。 其实大家都很忙，找实习的，准备论文的，工作的，但是都抽出了宝贵的时间来探病，甚至还想瞒着我给我惊喜，小易还因为没赶上高铁挥泪买了张商务座，票价比回程的机票都贵，我听着都心疼钞票啊~ 那天是我治疗期间最开心的一天之一，虽然我说不了话，但是听着他们侃天侃地相爱相杀也是很幸福的哈哈哈哈。 虽然我们几个日常联系不多，但是一定是关键时候会挺身而出两肋插刀的那种交情！ 小片段10：靶神探病那天，组长就是我们名副其实的靶神，谈到什么都能向他开一枪。 小易和一博一来，我就发现他俩胖了，一博甚至都有小肚子了，但是组长可是苗条的很，曾经三个人中最胖的他如今成了最瘦的。然后我们说，毕竟是没有女朋友的人，这么瘦有女朋友是撑不住的，哈哈哈哈哈开了一波车。 以前的组长不说白白净净，至少也不是黑煤炭，可是他跟一博小易站在一块儿真的是乌漆嘛黑的，小易就说这或许就说他单身的原因了哈哈哈哈又黑了一波。 我们聊到一个产品使用问题时，组长对一个特别弱智的问题表示不解，我说他果然是搞算法的，对产品一无所知哈哈哈哈哈。 小片段11：组长脱单了那一次的探病，倒是成就了一段姻缘。我家藜爷跟组长谈恋爱啦！ 听到消息的我下巴都要惊掉了，怎么都没想到他俩成了，两个都是我很熟悉的人，毕竟大学期间，白天在实验室跟组长呆一块儿，晚上回寝室跟藜爷呆一块儿，他俩在一起这件事让我激动了好久大晚上还精神抖擞到不行呢！ 知道消息的当天晚上，藜爷和组长就轮流来跟我语音，两个人都是略微羞涩又急于知道对方的一切。我很开心藜爷能找到自己喜欢的人，也很开心组长能拥有藜爷这么体贴懂事的女朋友。 只是，组长和藜爷的恋情没有维持太久，原因是不合适。 分手后他俩也是跟我说了大致情况，作为一个旁观者，我确实觉得这段感情两人都没错，不过合不合适确实是要相处过后才能知道。 我问过藜爷喜欢组长什么，藜爷说觉得他很厉害，这点我也承认，而且藜爷比较容易对厉害的男生有好感这我也是知道的。 之后组长跟我说，他不是藜爷喜欢的类型，藜爷喜欢成熟温柔厉害的，他只占了最后一条。 我当时就懵逼了，在我看来，组长确实不够成熟，更加不是温柔的类型，还凶哭过我呢，但是这两点藜爷未曾跟我谈起。只是一开始藜爷觉得组长是成熟温柔的，因为他们来探望我前，组长特意抽时间去了趟商场，直播逛街，给我买想要的小礼物，这让藜爷觉得组长是非常靠谱值得托付的。只是相处后，两个人都觉得对方不够懂自己，对对方的认知也有一定的偏差，这才彼此放开。 我最亲近的两位朋友，希望你们都能找到真正属于自己的幸福。 结语其实这篇文章在两年前就开始写了，当时刚搭好博客，我承诺组长要写一篇关于他的文章。后面却因为各种事情（其实可能就是懒）中途搁置了，最近将博客重新修整起来，看到了这篇文章，决定要立马将它完成。毕竟我的组长就快要从中科院毕业了，至少要对得起文章的标题吧！ 以后要是跟别人谈到我的组长，就不能骄傲地说我的组长在中科院了，而是要自豪地说，我的组长在微软！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>人物</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[年少的模样]]></title>
    <url>%2F2019%2F01%2F27%2F%E5%B9%B4%E5%B0%91%E7%9A%84%E6%A8%A1%E6%A0%B7%2F</url>
    <content type="text"><![CDATA[某个寻常的周五，我照例乘4路公车去人民医院检查。公交路过一所中学，上来了一男一女两个学生，看相貌应该是这所中学的学生。 男生高高瘦瘦的，穿着休闲的运动装，一身少年气。 女生白白净净的，扎着活泼的马尾辫，充满灵气。 两人应该不认识，一前一后上了车。但是车上人稍微有点多，将两人挤到了一块，两人对视了一下后迅速地转移目光。随后女生在我身后找了个座位坐了下来，男生则站在下车门附近。 我不知道女生的状态，但我发现男生一直在东张西望不时地往我身后瞄一眼，瞄完后又匆忙地转换视角。过了几站后，车上大半的老人和小孩下了车，男生坐上了车中央的老弱病残孕专座。但他并没有乖乖地面向前坐着，而是面向下车门方向，状态和站着时差不多，只是感觉有点坐立不安，可能是想要引起女生的注意，又怕太过引人注目。 到了某站时，男生站了起来，应该是要下车了。车门打开的瞬间，他光明正大地望向了我身后的位置，有点期待有点羞涩，这一次他的目光没有闪躲。只是一秒后，他便迈开步子下了车。 我从窗户往外看，他正向车尾走去。我也不知道他脸上表现出来的是失落还是开心，但他扬着头，我仿佛看到了一丝骄傲。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[飞羽作品集（下）]]></title>
    <url>%2F2019%2F01%2F19%2F%E9%A3%9E%E7%BE%BD%E4%BD%9C%E5%93%81%E9%9B%86%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本作品集为飞羽原创，18岁生日时飞羽将其作为礼物赠与本人，现将该作品摘抄并记录在该博客中。 （四十）《卖火柴的小女孩》 1从前有个可怜的小女孩，父母很早就去世了，只留下她与年迈的奶奶相依为命，她每天只能靠卖火柴来维持生计。 2日子一天天过去，有一天，出现了一个小男孩，手里拿着很多烟火，他是来放烟花的，恰巧，他没有火柴。 小男孩在小女孩附近绕了很久，小女孩似乎看出了小男孩的心思，就问他：“你是要买火柴吗？”小男孩不好意思地说：“嗯，不过我没带钱。”小女孩大方地说：“我送你一根火柴吧，但是要让看看你放的烟花。”小男孩的脸上绽放着笑容：“当然，你喜欢什么颜色的？”“彩色的。”小女孩毫不犹豫地回答，在她的家里似乎只要黑与白两种颜色，所以她特别渴望彩色。 3小男孩拿了一根火柴跑到一块离小女孩不远的空旷地方，向小女孩挥了挥手示意要放烟花了，小女孩睁着大眼睛屏住呼吸等待着。 火柴点亮了，天空绽放出一朵彩色的云，“真是漂亮的烟花”，小女孩说着。她完全沉醉进去了–她感觉自己的手能触摸到那一片彩色的云了，好柔软，好温暖，还有一种轻飘飘的感觉。她甚至觉得自己都要跟云一起飘起来了，飘到天堂去跟她的爸爸妈妈打个招呼…… 当小女孩睁开眼睛时，烟花早就消失了，她的嘴角还挂着一抹甜甜的微笑。 小男孩跑过来问她：“漂亮吗？我刚刚怎么见你闭上眼睛没看啊？” 小女孩笑着说：“我看到了啦，用心看到了，非常漂亮。” 顿了顿又说：“你明天还会来吗？” 小男孩想了想：“嗯，只要你想要我来我就来，不过是免费的火柴哦！” “那当然。” “那就一言为定了。” 约定明天再见面后，小男孩蹦蹦跳跳地回家了，小女孩目送着他离开，然后继续卖她的火柴…… 4冬天的序幕在不知不觉中揭开了，小女孩依旧穿着她那单薄的外套，打着赤脚，蜷成一团叫卖着火柴。每天最快乐的时光，便是等小男孩来了，看他放那灿烂的烟花。所以，即使生意再好，小女孩也总会留下一根火柴，这是只属于小男孩的非卖品。 小男孩今天来得很早，她怕女孩在雪里等得太久冻着了，他很同情小女孩的生活境遇，想着，等有一天自己赚钱了，一定要让这个女孩过上和自己一样好的日子。 5小女孩的奶奶病了，这让小女孩面对更大的困境。她几乎已经没有办法支撑起这个家了，她也想过向小男孩家里求助，后来想了想，还是放弃了。 小男孩从小女孩的眼里看到了哀伤，哪怕她表面装得再快乐，也掩饰不了绚丽的烟花印在她眼中的黯淡。小男孩想每天陪她一起卖火柴，可是连跟她一起放烟花都是好不容易才求得父母的同意，一起卖火柴怎么可能让父母批准呢？ 6小男孩想出了另外一个办法，把他每天带出来要放的烟花全都卖掉，把卖了的钱给小女孩。 小女孩的经济压力得到了减轻，可是，要想治好奶奶的病，这些钱是远远不够的。而且，她开始怀念从前看的烟花了，她的世界，仿佛回到了黑与白。此时的小男孩，也是一筹莫展。 7奶奶还是在一个风雪交加的夜晚去世了，小女孩趴在床边孤零零地哭着，没有小男孩的陪伴。 又过了一段更加艰难的日子，有一天，小女孩要小男孩别卖烟花了，她说她想看一次。 这一次，小女孩的眼里又重新出现了彩色。她努力不让自己去想自己还能看几次这样的烟花，小男孩也努力不让自己去想还能给小女孩几次这样的快乐。因为，现在的她实在太虚弱了。 现实的残酷让他们无法反抗。 8终于有一天，小男孩跑去小女孩卖火柴的地方，发现小女孩不在了。他等了很久，等到的只是父母把他带回家去吃饭。 一连几天，小男孩去的时候都没有看到小女孩。他开始用寻找代替等待，他总想着，她只是换地方了，也许马上就能找得到呢！ 日子一天天过去，小男孩从来没有放弃过寻找，生活给他的结果是–蓦然回首，灯火阑珊处，空无一人。 …… 9象征着冬天的雪消融了，小男孩像往常一样走到小女孩卖火柴的地方。 结局一： 小男孩惊讶地发现地上有很多已经烧过了的火柴，仔细数了数，发现正好是和小女孩看过烟花的次数。原来，每次看完烟花后，小女孩都没扔掉点燃过的火柴，而是把它们埋在这雪里。 小男孩把这些燃过的火柴紧紧地攥在手里：“这是我们永不逝去的友情，不管你在哪儿，我都会想着你的。” 烟火绽放在夜幕之中，小男孩仿佛在天上看到了小女孩无暇的笑脸。 结局二： 一辆马车缓缓地停在小男孩的旁边，卖火柴的小女孩从上面走了下来。原来，是小女孩的一个亲戚找到了小女孩，把她带去养病了，小女孩那时还没来得及跟小男孩道别。 夜幕下，小男孩和小女孩微笑地坐在一起，看那永不逝去的烟花。 ----------本篇完---------- （四十一）《荼蘼》 第一声蝉鸣揭开了夏天的序幕，夏雨依旧毫不吝啬地浇灌着每一株在春天盛开的花，在一个不起眼的角落里，一株荼蘼依旧紧闭着，完全不像要开花的样子。 它问地上的小草：“小草小草，你说我怎么还不开花呢？”小草说：“快了吧，你别急，这不是还有一些花没开吗？”“也是”，荼蘼安慰着自己。 不知不觉夏天已经过去一半了，好多开过的花都已经谢了，荼蘼更加着急了，问不远处的昙花：“昙花姐姐，为什么我还不开花呢？”昙花想了想说：“也许你已经开了但是你不知道呢？像我就是在夜晚开花，你今晚别睡觉了，看看自己是不是在夜晚开的花。”垂头丧气的荼蘼一下子振奋起来了，盼望着夜幕的降临，心想着：“没错，我一定是在夜晚开花的，咯咯咯咯~~” 漫漫长夜随着天际的破晓而宣布离去，荼蘼熬了一夜，硬是没有看到自己开花。此时的荼蘼已经心灰意冷了，旁边的梅花树安慰她：“没事啦，荼蘼啊，你看我这梅花都要冬天才开呢！现在还是夏天，早得很哪，开花这事儿，急不得的。” 荼蘼想了想：“也是，我就不去想这事儿了，能开花就行。”不过其实它也很在意，它想要的是在这热情奔放的夏天盛开，而不是寒冷刺骨的冬天。 夏天马上就要过去了，荼蘼在夏天盛开的可能性也越来越小，它努力让自己不再去想这件事了…… 夏的最后一天，荼蘼惊艳地绽放了。 ----------本篇完---------- （四十二）《白云和风》 湛蓝的天空下有一对很好的朋友，一个是白云，一个是风。除了白云，谁也不知道风在哪里。 可是有一天，白云变成了乌云，这下子风可不认识它了，到处找啊找啊，就是不见白云的踪影。 乌云只有靠风才能动，没有风，它就只能干巴巴地浮在空中等着。好不容易风飘到了它的面前，它大声喊着自己就是白云可是风完全不相信。风不屑地说：“我的朋友白云全身都是雪白的，看你这脏的样子，怎么可能是它呢？” 乌云发现自己的身体正在一点点地变湿润，它知道自己马上就要死了，要化成透明的雨到地上去了。一想到连道别都不能跟风说，它伤心地哭了起来。 风见乌云哭得那么伤心，觉得是有些不对劲，就去确认了一下乌云到底是不是就是白云。乌云边哭边诉说着它们过去一件件开心的事情，这会儿风真的相信乌云就是白云了。可还没来得及多说一句话，乌云已经全部化成了雨落了下去。 风后悔死了，心想怎么没早点问清楚，不然也不会出现这种状况了。 没有了云的风，带着颓废的心情以及看不见的躯体，像幽灵般漂浮在天上，想着：“白云以前在这里待过……” 又是一阵子过去了，突然有一天，天边出现了一朵白云…… ----------本篇完---------- （四十三）《心房》 我希望有这么一座房 透明的窗 享受阳光 我希望有这么一座房 充满想象 朝着梦想的方向 我希望有这么一座房 纯澈明亮 周围散发着花香 我希望有这么一座房 爬山虎在上面缠绕 与铁轨遥遥相望 我希望 某人有这样的心房 ----------本篇完---------- （四十四）《如果可以》 如果可以 我想做一阵风 自由地无形 直到遇见 让我有形的你 如果可以 我想做一片云 把所有的累都含在心里 等某一刻 肆意地洒落 如果可以 我想做一只蜗牛 与生活的节奏背道而驰 漫观世界的永无休止 如果可以 我想做一片树叶 在生命的最后一刻 舞动隐藏的翅膀 如蝶般纷飞而落 如果可以 我想做一株小草 违抗被践踏的命运 在坚硬的大地之上 生息不断 如果 我不是我 你亦菲你 命运 又会开一个 什么样的玩笑 让彼此聚散无常？ ----------本篇完---------- （四十五）《小老鼠吱吱》 在所有与老鼠有关的童话里，都有一只叫吱吱的老鼠，这只也不例外。 小老鼠吱吱天生就是大家讨厌的对象，可不是因为它有多讨厌，而是大家形成了一种固定思维–老鼠都是坏的。 可是小老鼠吱吱并不在意被大家讨厌，还是会在人家需要帮助的时候帮别人一把。 这一天，兔子家门口的锁坏了，怎么打也打不开。小老鼠吱吱就马上跑过去，用牙齿不停地磨门上的锁，把口里都磨出血了终于才磨开了锁。本以为兔子再也不会讨厌他了，结果兔子说的第一句话竟然是：“哎呀，这锁还不够结实，看样子得换把好一点的锁来防着点。” 又有一天，小狗在玩一个跳跳球，一不小心把球给掉到蛇洞里去了。在谁都没辙的时候，吱吱冒着生命危险去蛇洞里面把球推了出来，小狗没说一句谢谢，还怪球被弄脏了，又自个儿玩去了。 不久后，小鸡妈妈发现窝里的蛋少了一个，便在吱吱门前大吵大嚷地喊着：“偷蛋贼！”吱吱在家里那叫一个委屈啊：“虽说老鼠爱偷鸡蛋，可我从来没有做过这样的事啊。”为了澄清自己，吱吱整日整夜地去找那只丢了的蛋，终于在一个草丛里发现了它。于是吱吱高兴地把鸡蛋带回去给鸡妈妈。鸡妈妈捧着宝贝蛋说：“乖乖，还好你没事，不然妈妈可怎么活啊。”顿了顿又瞟了一眼吱吱：“算你还有良心，把蛋还回来了。”此时吱吱已经累得不行了，也不想再解释什么，拖着疲惫的身子回洞里去了。 …… 就这样，在大伙的偏见与误解中，吱吱实在受不了了。开始和自己的同类一起做坏事，学会去偷别人的吃的，咬坏别人家的东西…… 又过了一段时间，一次吱吱和几个同伴聚会，喝酒喝多了便开始抱怨起来：“那些个动物算什么，我原本对它们那么好，它们凭什么那样对我，哼，现在算是把仇都报了。” 另外一只老鼠笑嘻嘻地说：“当初要不是我们暗中使坏把你拉到我们这边来，你的日子也不会像现在这么潇洒啊。” “暗中使坏？”吱吱好气地问了句。 “对啊，锁是我们弄坏的，洞是我们挖的，蛋也是我们偷的……我们可都是为了你好，不然你怎么会到我们这边来呢？” 吱吱一下子清醒了，酒也没喝，走了。 第二天清早，吱吱就收拾好行李，独自离开了。他要去找一个地方，没有偏见，也没有陷害，只有纯澈的真诚。 ----------本篇完---------- （四十六）《飞蛾与螳螂》 ###1 在一个不起眼的角落里，一只飞蛾刚刚睡醒，不过还没来得及清醒它就被吓呆了，因为就在前面不远处一只螳螂正盯着它看。正巧的是，螳螂正一步一步向它走来飞蛾的恐惧已经完全占据了它的理智，它知道自己马上就要死于螳螂的刀下了。 “唰！”一眨眼的工夫，刀起刀落，地上多了一具黄蜂的尸体，原来刚才黄蜂正在飞蛾后面，这才是螳螂想要捕食的对象。 2飞蛾悬着的心还没来得及放下来，看螳螂吃黄蜂的样子又害怕得一动也不敢动了。 螳螂吃饱后瞟了它一眼：“放心，我现在对你还没兴趣。” 飞蛾刚叹了口气，螳螂又说：“等你长大一点再吃也不迟。” 飞蛾真的几乎崩溃了，不过又马上镇定了下来：“等我长大了我就去扑火，到时候你就吃不到我了。”飞蛾这话的时候连自己都觉得奇怪，这不是摆明让螳螂吃掉自己吗？ 可这时螳螂突然来了兴趣：“对了，你们为什么要去扑火啊？那不是自取灭亡吗？” 飞蛾清了清嗓子，摆出一副教授的样子说道：“这你们就不懂了，其实除了凤凰可以涅槃，我们飞蛾也可以，但这个概率很小，只有九万九千九百九十九分之一，所以一般的飞蛾都死了，不过如果涅槃成功了的，我就会变成一种比蝴蝶还漂亮的动物，而且还会使法术。” 螳螂瞪大了眼睛，这种事还是头一回听说，真想见识见识。 3为了能见识飞蛾的涅槃，螳螂开始和飞蛾在一起了，不过这可不是飞蛾想要的，有个杀手在身边可是一件很毛骨悚然的事。飞蛾也想过逃跑，不过一旦被发现的话，它也会像最开始那只黄蜂那样被整个吃掉的。于是，它不再想逃跑的事了。 “小羽，我出去觅食了，你就呆在这好好练习一下你的翅膀吧。”螳螂开始称呼飞蛾的名字了，因为至少它现在没把这只飞蛾当猎物看待。 “好的，刀刀。”小羽也直呼螳螂的名字，连它自己也觉得很不可思议，它居然会跟一只螳螂混在一起。 4日子一天天过去了，小羽也慢慢长大了，这天螳螂刀刀又开始问：“小羽，还要多久你才能涅槃啊？”小羽一时不知怎么回答了，因为和它差不多大的飞蛾都已经去尝试这项伟大的事业了，当然，结果只是死亡。 小羽知道，现在它只有两个选择，要么扑火，要么被刀刀吃掉。终于，它下定决心了：“就今晚吧！” 刀刀一脸的喜悦，虽然不一定能看到小羽涅槃成功，但一想到那个情景就觉得异常兴奋。 5夜无声地降临了，在一盏油灯面前，小羽和刀刀正呆呆地站着，火苗不停地窜动，两个生命在它的面前显得太渺小了。 “开始吧。”刀刀的声音打破了夜的寂静。 小羽擦了擦汗，鼓起勇气向火苗扑去，头用力地往下低着，紧闭着眼睛，凭感觉去不断撞击火焰。一下，两下，三下……连一旁的刀刀都看得非常紧张。 火苗还在窜动着，小羽不知疲惫地不停扑着火，它知道哪怕有一秒钟的停顿，它的身体就会被无情的火焰吞食，它只有用完最后一丝体力，才有希望得意涅槃。 6小羽马上就要支撑不住了，它使出了最后力气扑向火焰，希望能在碰到火焰的那一瞬间能有奇迹发生。可以，在它身体穿过火焰的那一瞬，它知道奇迹没有发生，它再也没有力气去扑火了，倒在了地上，等待着死亡的降临。 当然，刀刀并没有杀它，其实刀刀早就把小羽当成了朋友，它是真的希望小羽能够涅槃成功，尽管现在失败了，它也要带着小羽回去。 正当刀刀走近小羽时，奇迹发生了，刚刚被小羽不断扑打的火焰熄灭了，小羽的背上长出了一双蓝色的翅膀，此时的刀刀兴奋极了，大声喊着：”小羽，你成功了，你成功了，快醒醒啊！“ 小羽用力睁开了眼睛，看了看自己，满足地笑了，又睡了过去。 7第二天一大早，小羽就醒来了，它躺在原来和刀刀一起居住的房子里，不过它还不知道怎么使用法术呢，只是呆呆地看着自己那一对美丽的翅膀。 它隐隐约约听到一个声音对自己说：“来吧，飞越过高山，又飞羽过海洋，来到我们这个梦的世界吧！你的翅膀会带你飞到这里来的。” 小羽兴奋地跟刀刀说听见声音呼唤它到梦的世界去了，刀刀听了也替它高兴，不过一想到还没见到小羽使的法术就要离开了又觉得很不舍。 小羽看出了刀刀的心思，对它说：“我们一起去吧，反正你也会飞。” 刀刀灿烂的笑了。 8小羽和刀刀就这样出发了，在那双奇妙的翅膀的带领下，不久，它们就飞越过了高山，可是在飞越海洋的途中，刀刀显得体力不支了，而小羽，因为那双翅膀的作用还毫无感觉。 刀刀对小羽说：“小羽，我好像不行了，不能陪你到海洋那边梦的世界去了，你去了之后多学点法术，还有，别忘了有我这么一个朋友哦。” 小羽说：“这怎么行呢，你到我背上来，我背你一起去。”话刚说完，小羽就背起了刀刀继续向前飞去。 9翅膀的力量只足够让小羽一个人飞到梦的世界去，背上刀刀后，小羽很快也没力气了，眼看着它们都要掉到海面上去了，刀刀从小羽背上一跃，掉了下去，只留给小羽一个微笑。 小羽愣了一下，飞快地朝刀刀掉落的地方冲去，用比当初扑火时更大的力气，冲进了海里，它压根就没想过结果会是怎样，它只要找到刀刀。 被小羽冲起浪花的那一层海面，很快就平静了下来，刀刀和小羽都失去了知觉，沉到了海底。 10当小羽醒来时，它已经到梦的世界了，此时刀刀正在它的旁边，还熟睡着呢。这是又出现当初呼唤小羽来的那个声音，告诉它现在它真的涅槃了。 原来，飞蛾的涅槃不仅需要火的炼造，还需要水的洗礼，而现在，小羽成了真正意义上一只涅槃过的飞蛾了。 从此，小羽和刀刀就生活在了这个梦的世界，开始学习法术的生活。也许不久之后，它们就会通过法术回到原来的世界，做出一些奇妙的事情呢。 ----------本篇完---------- （四十七）《卖梦的商店》 “天使”经营了一家商店，专门卖梦给需要的顾客。 第一个来买梦的是小狗，它要的梦很简单，只是能在梦里有骨头吃。因为是刚开张，所以“天使”免费送给它一个梦，其实也就是一颗丸子，夜晚睡前吃掉就可以做许下愿望的梦了。 第二个来的顾客是一只蝴蝶，它的梦也很简单，只想梦里能有一片无尽的花丛任它飞舞，自然，它也拿到了一颗丸子。 第三个顾客是一只乌鸦，它想要在梦里拥有一身洁白的羽毛，在付了钱之后，它也得到了一颗丸子，高高兴兴地走了。 夕阳散尽了最后一丝余晖，夜与梦同时降临。 在小狗的梦里，它的前脚只剩下白色的骨头，惨不忍睹，小狗看着自己的骨头，吓了醒来。 蝴蝶在梦里看到了一片无穷无尽的花，准确地说，是食人花，蝴蝶只能用力地挥着翅膀在花的上方挣扎，无穷无尽，永远飞不出去。 乌鸦更惨，本以为洁白的羽毛会令同类羡慕不已，结果同伴都视其为异类，飞到哪儿都遭受驱赶…… 第二天一大早，买了梦的动物们纷纷到卖梦天使店找“天使”理论，结果昨天那个天使模样的店主已经不见了，取而代之的是面目狰狞的魔鬼。动物们这才恍然大悟，原来买的是魔鬼的梦，只能愤然离去。 其实动物们不知道，天使与魔鬼经营着同一家店，你若内心澄澈，不带一丝贪恋，梦自然是美好的。否则，噩梦则永远不会消失。 ----------本篇完----------]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>作品集</tag>
        <tag>礼物</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[飞羽作品集（中）]]></title>
    <url>%2F2019%2F01%2F18%2F%E9%A3%9E%E7%BE%BD%E4%BD%9C%E5%93%81%E9%9B%86%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本作品集为飞羽原创，18岁生日时飞羽将其作为礼物赠与本人，现将该作品摘抄并记录在该博客中。 （二十一）《世界末日》 世界末日真的到来了，幸运的是，仁慈的上帝派了诺亚方舟拯救世界上所有的生灵。 诺亚方舟一到，大家就争相往上面挤。人类就开始维持秩序，分配大家上去的顺序。当然，人类理所当然是最先上去的，凭其所谓的智商，然后人类开始控制入口，觉得可以上的，就放行。 狮子马上挤上前：“我是万兽之王，必须得带我走吧！”人类想想，确实啊，狮子是代表性的动物，不带上不行。于是，狮子顺利进入了诺亚方舟。既然万兽之王能上诺亚方舟，那森林之王–老虎也没有不上诺亚方舟的理由吧！因此老虎也紧跟着上去了。 再然后，聪明的猴子，狡猾的狐狸等动物也一一上了诺亚方舟，等人类的朋友海豚挤上诺亚方舟时已经再也挤不上了，和平鸽一声下令：“出发！”诺亚方舟便开始向前方驶去，这次的目的地是月球，必须等地球平静后才能开回来。 开着开着，动物们开始望着这颗还湛蓝的地球，带着一丝的不舍。不过想到过一阵子又能回来，他们便也舒缓了。然而，接下来发生的事大家都始料未及的。由于离开了大气层，空气越发地稀薄，氧气已经很少了，大家都有点喘不过气来，这时有动物才意识到忘记带一样最重要的东西了–植物。其他什么动物都可以不带，唯独不能不带植物。 大家都争相往诺亚方舟挤，说着自己的重要性，而真正最重要的植物却一言不发。这下大家才真正清醒–看似最渺小的才是最伟大的。这下子，该是真正的世界末日了。 （能意识到所失去事物的重要性，这是种万幸，也是种不幸。） ----------本篇完---------- ##（二十二）《秋》 残叶卷风起 飞花飘雨零 古月依然照 今人难想惜 ----------本篇完---------- （二十三）《沙漠里的树》 干涸的沙漠中心突然出现了一棵巨大的树，这件事可不寻常啊，要知道沙漠中心极热无比，寸草不生呢！ 这棵大树吸引了许多沙漠动物的围观，大树被围得里三层外三层，什么稀奇古怪的动物，只要能来就都来了。然后大家开始研究为什么这棵大树会突然出现在沙漠中心，动物们用尽了所有它们会的语言来问大树，可大树总是沉默着，一言不发。动物们也束手无策，尽管无法获知大树到来的原因，但大家依旧对这棵大树有着很浓厚的兴趣，把它视作神物供奉。 又是很突然的一刻，大树消失得无影无踪，沙漠里的动物再次被惊动–一棵如此巨大的树怎么说消失就消失了呢，没有哪个动物知道这是海市蜃楼…… ----------本篇完---------- （二十四）《梦的枕头》 上帝的枕头一不小心遗落到了人间，被一个不知该说是幸运还是不幸的人捡到了。 枕头想：“既然他捡到了我，那也算是一种缘分吧！我就让他在梦里过得舒服点吧！” 太阳被约了赶下了山，捡到枕头的人也开始进入梦乡。枕头对他的大脑施了魔法，让他的愿望显示出来然后让他在梦里实现这个愿望。不过，枕头没想到这个人的愿望居然如此简单–有很多的糖可以吃。枕头当然欣然去梦里让他好好享受吃糖的快乐。一晚下来，捡到枕头的人做的梦里是五颜六色的糖，他吃得可开心了，一辈子都没吃过这么多的好吃的糖呢！ 不过，他的口水全流在枕头身上，这可让枕头很不乐意–作为上帝的枕头，怎么能让人类的口水都流在自己身上呢？尽管很不乐意，但看到这个人做梦时笑得那么甜，它还是决定忍了。然而，接连很多天这个人都流口水，而且一次比一次多，枕头终于忍无可忍了，决定让他在梦里失去幸福，体会一下不幸的哀愁。 果然，这一天梦里，他的生活变得非常不幸，生活没有一件如意的事，他哭得很凄惨，半夜就哭醒来了，依然湿了枕头。这下枕头更纳闷了，这幸福不幸，不幸更不行呀！口水好歹是甜的，这眼泪也太咸了。如此过了几夜，梦枕更受不了了，它决定再想想别的办法。 上帝的枕头不愧是上帝的，一下子又想到了，它决定让他既不做幸福的梦也不做不幸的梦，而是做噩梦。然而，枕头还是失算了，捡枕头的人是个十足的胆小鬼，在梦里被吓个半死，额头上全都是汗了，枕头被他的汗浸湿了。这回枕头可是苦不堪言了，口水是甜的还不算惨，泪水是闲的也罢了，这汗水可是苦的呀，这苦枕头可怎么受得了…… 纠结了几天，枕头喝了几天苦汗水后实在没办法了，决定什么梦也不能让他做了，干脆让他失眠算了。这下子枕头不苦了，可苦了这个捡枕头的人了，连续的失眠怎么受得了呢？他似乎觉察到枕头的不对劲了，最终决定扔掉这个奇怪的枕头。 于是，枕头在第二天躺在了垃圾堆里。当然，它没躺多久，上帝就找到它了，把它弄干净带了回去。回去之后上帝问枕头感觉怎么样，枕头满口怨言呀！这人间还真不适合枕头这样的神物待着。 没办法，一般人都会有喜怒哀乐，不像上帝可以安心地枕着它入睡。不过这样也好，这就是天堂和人间的区别，有喜有怒有哀有乐，这才是人间的魅力所在。 ----------本篇完---------- （二十五）《飞羽》 飞羽飞， 霏雨雨， 飞雨雨飞羽。 蜚语飞， 语飞羽， 予非飞羽。 ----------本篇完---------- （二十六）《单翅天使》 天使做了一个梦，梦见自己只有一只翅膀，于是感到很好奇，就去问上帝：“上帝啊，我昨晚做梦梦见自己只剩一只翅膀了，这是为什么呀？” 上帝说：“如果你知道了为什么，你就可能真的只剩一只翅膀了，你还想知道吗？” 天使想了想，实在想知道为什么，就坚决问上帝为什么。上帝告诉他：“所有的天使原本都只有一只翅膀，为了好看，许多天使偷偷地偷了人家的翅膀，偷到翅膀的天使便用一双翅膀飞到了天堂，那些翅膀被偷了的天使就变成了人类，生活中天空下那一片土地上。” 天使一下子惊住了：“那我的翅膀岂不是偷来的？可是我没有去偷过啊！” 上帝无奈一笑：“在你出生时，你的父母就偷了一只翅膀，所以你现在就有了一双翅膀。那个和你同时出声的被偷了翅膀的小孩就生活在你脚底下那片土地。” 天使一下子惊呆了，他没想到自己是这样变成天使的，嚷嚷着要上帝取了他的那只偷来的翅膀。上帝平静地问天使：“翅膀取了你就不能飞翔了，你还愿意取吗？” 天使没有丝毫的迟疑，坚决要取下那只翅膀。于是，上帝取下了那只被偷来的翅膀，天使以为自己马上会因不能飞翔而坠落下去，离开这上帝居住的天堂。可没想到自己反而在往上升，那一只原本属于他的翅膀在带着他飞翔，他好奇地大声呼喊：“上帝，我这是要去哪啊？” 上帝笑了，乐呵呵地说：“去天堂啊，顺便告诉你，其实我不是上帝，只是看管这片区域的守卫罢了。”这下天使大彻大悟了，原来自己一直不在天堂啊，因为一只翅膀要带他去天堂，可另一只偷来的翅膀要去人间寻找它的助人而阻碍了他去天堂，取下那只翅膀之后，原来属于他的翅膀便带他去到了真正的天堂。 话说另一只被守卫取下的翅膀，自然是去人间寻找他的主人呗。历经千辛万苦之后，翅膀终于找到它那个从小就与它分离的主人，兴奋地对主人说：“主人啊，我是你的翅膀，带你去天堂的，你快戴上我吧，等你死后我们就可以去往天堂了。” 那主人大笑：“一只翅膀吗？没有一双翅膀可怎么带我去天堂呢？”翅膀就跟你他解释原因，可这主人就是不听，心想有一双翅膀的才是天使，才能居住在天堂，只有一只翅膀的岂不是怪物？便对翅膀摆了摆手，说还是等到有一双翅膀了再来接他去天堂吧。 这下翅膀也没有办法了，只能游走人间，寻找一个愿意戴着它去天堂的人，可是遗憾的是世人都认为天使有一双翅膀，没人愿意让这一只翅膀带着去天堂，因此这只翅膀就流量至今，仍在人间寻寻觅觅…… 你梦到过一只带你去天堂的翅膀吗？如果还没梦到，请不要错过了，那些长着一双翅膀的可不是天使呢，别被骗了哦！ ----------本篇完---------- （二十七）《小傻》 我做了一个很美， 很美的梦。 你从土里发了芽， 一点一点地长大。 直到， 花繁叶茂， 像这幅图一样。 我的小傻， 快点长高吧。 ----------本篇完---------- （二十八）《虫与鸟》 从小鸟妈妈就教育小鸟：“小乖乖，要记住一个生存的道理–早起的鸟儿有虫吃，起晚了就会挨饿的。” 同样，从小毛毛虫妈妈就教育毛毛虫：“小乖乖，要记住一个生存的道理–早起的虫虫被鸟吃，起早了就会被吃掉的，所以我们要学会做懒虫哦。” 可是，事与愿违，乖乖鸟和毛毛虫偏偏就没听自己妈妈的话，乖乖鸟每天太阳晒屁股了才起来（按照这鸟巢的设计，晒屁股应该已经是中午了）。而毛毛虫每天还没亮就起来了，在草丛里玩耍，顺便吃点东西。 然而有一天，毛毛虫生病了，躺在床上没有起来，而乖乖鸟呢，因为每天起得晚没吃到虫虫，便决定早起一回，结果很遗憾，乖乖鸟还是没有遇到毛毛虫。从此它下定决心：“早起晚起都没虫，不如睡个好觉。” 而毛毛虫这边呢，因为每天早起都没被鸟儿吃，所以决定不当懒虫，每天起来看日出。 日复一日，年复一年。乖乖鸟和毛毛虫都长大了，它们同样有了自己的后代，乖乖鸟对小乖乖说：“早起的鸟儿没虫吃，起晚点儿没事。”毛毛虫也对小毛毛虫说：“早起的虫虫没被鸟吃，别当懒虫。” 可是，经验告诉我们小乖乖鸟和小毛毛虫可不会这么听话，它们自然也都是反其道而行之，同样永不见面。 还是可是，这么多中，总有些听话的乖宝宝听了话，如果是鸟宝宝听话的话，自然能吃到虫宝宝，如果是虫宝宝听话的话，那结果可就惨了。 所以，听话之前，先判断一下你是什么~ ----------本篇完---------- ##（二十九）《花·叶》 瓜瓜在花盆里种下了一颗种子，正好是早春，瓜瓜一心一意地照顾这颗种子，每天幻想着不久后这颗种子会开出什么样的花朵。 过了好久好久，种子才刚刚发芽出来，一点点的嫩绿，却也让瓜瓜兴奋了好一阵子。不过秋天都到了，花盆里的植物也才长高了一点点，瓜瓜心想：“今年是看不到花了，看样子只有等明年才知道花会是什么样的，不过这样也好，能多点期待，多点想象。” 一眨眼又是一年了，原本种在花盆里的种子已经枝繁叶茂了，可偏偏就是不开花。瓜瓜有点失望了，可仍然很耐心地照顾着花盆里的植物，心里总是想着它会开出什么样的花，会是什么颜色的，什么形状的…… 日复一日，年复一年，当年的小瓜瓜都已经长大了，可植物仍然没有开花。此时的花花已经成为了画家，专门画花的，他笔下的花各式各样，争奇斗艳，而原型都是这棵不开花的植物。 后来的后来，瓜瓜知道了原来他当年种下的种子是不会开花的，不过开不开花对他来说已经不重要了，因为种子早已在他的心中开了花，无数无数朵，都是那么美丽。瓜瓜庆幸当年没有刻意去查一下种子为什么不开花，不然怎么会在他心里开出这么多的花呢。 很多事情，都像这种子一样，也许本来就只有叶却没有花，我们不必刻意去找寻那朵花，只需静下心来想象，心里开出的花永远是最美、最灿烂的，即使现实的花已经不在了，心中的花却依旧盛开着，陪伴着我们，永远，永远…… ----------本篇完---------- (三十)《井底之蛙》（一） 当年的井底之蛙，在听从建议后跳到井外，欣赏到了大自然辽阔的美。 若干年后，它的后代又回到了当年的那个井底，一只野鹿经过这口井，看到了呆在井底的青蛙，不禁嘲笑起来–哈哈，又是一只井底之蛙，难道你的祖先没告诉过你外面世界的辽阔与美丽吗？大自然是如此的美好，你怎么能只呆在那口枯燥乏味的井里呢？ 小青蛙无奈地笑了笑，叹了口气：“大自然确认是美丽的，不过那是当年我祖先所在的那个时代，现在还能是如此吗？外面到处都是危险，那么多的农药，还有那么的捕蛙人，我还敢在外面吗？现在啊，只有这枯燥的井底才是我的栖身之地了。” 野鹿嘲笑青蛙胆小，不屑地说：“不就是一点小危险吗？比起大自然的美算什么，只要稍微注意一点就不会有事了嘛。” 话还没说完，只听见一声枪响，野鹿倒在猎人的子弹下，小青蛙坚信住在井底的信念了…… ----------本篇完---------- （三十一）《井底之蛙》（二） 躲在井底的青蛙也一天一天长大了，有了自己的后代。两只小青蛙从小就被教育外面很危险，这个井底才是最安全的。 青蛙姐姐听了妈妈的话，乖乖地呆在井底，把井底当成她的整个世界，生活得倒也挺自在的。青蛙弟弟可就不听话了，一心想着去外面闯荡一回。 一天晚上，青蛙弟弟看着皎洁的月光，越发想到外面去玩了，正好青蛙妈妈已经睡熟了。弟弟就轻轻摇醒姐姐：“姐姐，姐姐，快起来啦，我们偷偷去外面玩几天好不好啊？”青蛙姐姐马上拒绝：“不行，不行，妈妈都说了不准了，外面很危险的，你出去会死的。” 青蛙弟弟苦苦央求，缠着青蛙姐姐陪他出去玩，可青蛙姐姐就是不愿意。青蛙弟弟没办法了：“你不去就算了，我一个人去了，哼！”说完，青蛙弟弟就朝井外跳去，姐姐喊了两声，弟弟理也不理。这时青蛙妈妈也醒了，看着调皮的儿子离开了井底，伤心地喊了两声，也实在不敢追去，小青蛙的背景渐渐远去…… ----------本篇完---------- （三十二）《井底之蛙》（三） 小青蛙一出来，就感觉到了世界的辽阔，兴奋地叫了一阵。感觉到有点饿了，便跳进一片鸣叫声不断的田里，开始寻找自己的猎物。 田里的食物比井里的就是多些，小青蛙只一小阵子就吃饱了，躺在一片草地上悠闲地睡觉了。 一觉醒来，小青蛙感觉肚子疼痛，知道吃的东西不干净了，正想着该怎么办，已经被一双手抓住扔到一片漆黑的袋子里去了，还传来一句笑声：“今天收获不错诶，捡了这么多只被毒到的青蛙。”这下子小青蛙后悔死了，还怀念着看过的风景，遗憾地叹了口气。 小青蛙和其它的青蛙被拿出去准备卖了，小青蛙和其它青蛙都在谈论自己的经历，小青蛙听得入迷了，好像自己就经历了那些事，尽管被抓了，可经历的那些事确实都很精彩，尽管被抓了倒也值得了。 不久之后，小青蛙和另外一些青蛙都被卖了出去，因为小青蛙太小了，主人把它给自己的儿子拿去玩了…… ----------本篇完---------- （三十三）《井底之蛙》（四） 小孩拿到小青蛙后对它可好了，带它去草地上玩，跟着它一起蹦蹦跳跳，还给它好多零食。小青蛙感觉小孩真好，自己真是太幸运了，便也和小孩玩得很好。 不过没多久，小青蛙还是想念自己的妈妈和姐姐了。小孩似乎懂得了小青蛙的想法，几天之后，他就把小青蛙放了，要它去寻找自己的家。 小青蛙对小孩感激涕零，一蹦一跳地走了，路上，小青蛙又遇到了很多危险，不过小青蛙最终还是回到了井边。小青蛙看了一眼外面的世界，闭上眼睛美美地回忆了一番，跳回井里了。 看着儿子回来了，青蛙妈妈兴奋地哭了，抱着小青蛙就不放，青蛙姐姐看着回来的弟弟说：“外面是很危险吧，不过回来了就好。”小青蛙笑了笑：“危险是危险，不过更精彩啊！为了这些精彩，出去还是值得的。” 青蛙姐姐看了看外面的天空，若有所思，她似乎也在等待某一个夜晚了…… ----------本篇完---------- （三十四）《铅笔和橡皮》 瘦铅笔和胖橡皮从小就是敌人，不爱在一起玩，可偏偏主人把他们放在了一起。 铅笔盒橡皮整天都会在文具盒里吵架，有得争的，没得争的他们都能争得天翻地覆。终于有一天，他们彻底爆发了，铅笔不停地画，橡皮使劲地擦，不知不觉铅笔已经短到快没了，橡皮也用得差不多了。 就在他们的生命要因为这场战争而消失的时候，他们似乎醒悟过来了。铅笔先开的口：“诶，橡皮，我不想画了，你也别擦了。”橡皮想了想：“现在的我们已经没什么用了，不如快点离开吧，主人不会要我们的了。” 片刻的沉默，铅笔用最后的生命写下了大大的三个字–对不起。橡皮看了看，微微笑了一下，这次是他第一次没有擦去铅笔写的字，然后默默地把这三个字的周围擦得干干净净的。 白纸上，除了这三个字，什么也没留下…… ----------本篇完---------- （三十五） 我寻找着光明 在无尽的黑夜 繁星闪烁 留下一夜的梦 纵使爬上 那高百尺的危楼 也摘不到 最近的那颗星 我迷茫地望着 等一颗流星划过 就一刻 便已足够 也许 你只是夜空的流萤 却成了 我梦里的流星 带着我的愿望划过 留给了我满眼的闪烁 那是一片 满是萤火虫飞舞的夜空 闪着 闪着 。。。。。。 ----------本篇完---------- （三十六）《月亮》 1地球人都以为月亮从古代一直存在，陪伴大家至今。其实才不是呢，大家都被骗了。 月亮的生命很短暂，一般都只有一个月左右，月亮在死去的那天夜里会生出一个月亮来，新的月亮会代替她妈妈的工作，慢慢长大、长大，然后再老去，又生出一个月亮。 其实月亮长大是很明显的事嘛，最开始那么小，然后慢慢变圆。可人类就是傻，偏偏以为月亮会魔术，自己变大又变小。 可是，意外总是在不经意间就发生了。三十日晚，月亮妈妈生出的不是女儿，而是一对双胞胎，准确的说法应该是龙凤胎。这下可麻烦了，一个天空可容不得两个月亮啊，不然肯定会打架的，即将死去的月亮妈妈灵机一动，要他们俩一人在天空呆几个小时，没有出现的那个就躲进云里。 2不过这当弟弟的可没这么听话（刚刚忘说了，他们是姐弟俩），这天夜晚本该姐姐值班的，可弟弟偏偏要出来玩，这姐姐就不高兴了，值班是我的事，你来瞎搅和干啥呀，就要弟弟躲到云里去。 弟弟可没那么听话，你越说他越不听，在天空到处转悠，划出了好多漂亮的尾巴。这一划不要紧，可是让地上的人看见了，你想啊，这么美的东西谁不想要啊，于是各自想办法来套住这个调皮的月亮。 3人的智商往往是偏低的，这话一点不假。最主要的是，这月亮出来的时代正是草原智商第一高天才狼灰太狼的时代。灰太狼倒不要紧，他只对羊感兴趣。遗憾的是，他有一个爱美的红太狼老婆。 红太狼第一次看到这月亮的时候就深深地被迷住了，马上用平底锅对着灰太狼：“灰太狼你给我听着，要是你不能帮我把那个带尾巴的月亮弄给我，你就永远别回来了！” 于是，灰太狼踏上了收月之旅。 4作为草原物理竞赛、化学竞赛及数学竞赛的冠军，灰太狼在半小时内就发明出了七七四十九项抓月亮的东西。 实践证明，灰太狼的发明是多余的，有尾巴的月亮因为飞得太快一不小心就撞在狼堡上，晕了。 红太狼见月亮来了，一个劲地兴奋。可才高兴了一下就犯难了：“这么大一个月亮，怎么才能做自己的装饰品呢？” 不一会儿灰太狼也回来了，正想说有尾巴的月亮不见了就发现月亮到自己家了，于是钻进实验室开始分析解剖此月亮的方法。 5红太狼和灰太狼还在想着办法，小灰灰就凑到了月亮旁边，轻轻闻了一下：“哇！好香啊！”于是忍不住一口咬下去，结果越吃越有味，月亮被咬出了很多的缺口，终于给疼醒来了。月亮见自己一身残缺的模样，哭着飞走了。 但是因为被咬的缺口实在太多了，又飞得太快，尾巴月亮就这样解体了。很多碎片就变成了星星，剩下的成了流星，散布在了夜空。 6从此，天上又只有了一个月亮，继续以月为周期繁衍下去。 ----------本篇完---------- （三十七）《青蛙王子和青蛙公主》 很久很久以前，小月从田里捉到了两只蝌蚪，因为她听外婆说过，蝌蚪长大了可以变成青蛙王子，那样她就可以和王子生活在一起了。 日子一天天地过去，小月心里想着，王子会是什么样呢，一定很帅气吧。不过，她可没想过这两只蝌蚪是公是母，还想着有两个王子让她选呢。 蝌蚪不知不觉地长成了青蛙，这会儿小月只需等待某个早晨醒来会看到她的王子。 那一天果然来了，清晨，小月睁开眼睛便看到了变成王子的青蛙，可是王子旁边还有一个公主。这下小月不知该怎么办了，她可没想过会出现一个王子和一个公主啊。 这时王子说话了：“主人你好，感谢你对我们的照顾，不过这会儿我们该离开了。再见。” 小月正想说着什么，可这会儿她觉得王子和公主才是一对的，自己怎么好意思留下王子呢，下次一定只能抓一只青蛙作王子了。 又过了不久，小月已经从失去王子的悲伤中恢复过来了，毅然决然地再去田里捉蝌蚪。这次正好看见一只蝌蚪，小月兴奋地把它抓回了家里，等待着它长成王子，这一次，她依然以为肯定是王子而没考虑过公主。 不过小月还没来得及高兴，以前的青蛙王子和青蛙公主就来了，很不好意思地说：“不好意思，主人，这是我们的儿子，他已经在出生时就和另一只青蛙订婚了，所以……”小月没办法啊，只有把养成王子的青蛙还给青蛙夫妇。 这之后，小月再也没有去捉蝌蚪当王子，因为她知道，那是一个不属于自己的世界，她要找的是人类世界的王子。 又是很久很久之后，青蛙王子一家搬到小月家来住了，因为外面太危险了，这儿更适合他们。 ----------本篇完---------- （三十八）《蜡烛和灯》 从前的从前，这个世界上还没有灯，蜡烛是全世界所有人最崇敬的东西，因为它能在黑夜带来光明。不管是诗人学者还是商人，都说蜡烛是样不可多得的好东西。 从前的后来，有个让所有蜡烛都讨厌的人出现了，叫爱迪生。因为他发明的灯让蜡烛失去了对光的主宰地位。 可是蜡烛并不服输，坚持认为自己比灯伟大，于是蜡烛王国就派人和灯王国谈判，输的一方将永远退出光的世界。 蜡烛方说得头头是道，紧紧围绕它们牺牲自我的伟大奉献精神谈论，希望以自己的精神来打败灯。而灯则围绕自己的光有多亮，又不会像蜡烛一样燃一会儿就没了…… 最终，电灯王国辩论得更有说服力，蜡烛王国决定从这个世界上消失。就在此时世界忽然停电了，正当电灯们没辙时，蜡烛们燃烧发出了光，一切又是那么的安详了。 蜡烛和电灯终于懂了，这个世界上，它们都是不可或缺的。其实他们都是发光为了照亮世界，只是生命长短不一罢了，又何苦非要比较出一个胜负来呢？ ----------本篇完---------- （三十九）《萤火虫的灯》 黑夜降临了，森林的草丛里，飞舞着几只萤火虫，他们拥有上天赐予的礼物–灯，但他们并不知道。 一只蚂蚁此时还没有回家，很遗憾，他确信自己迷路了，萤火虫火火正好从蚂蚁上方飞过。虽然只是微弱的光，但蚂蚁就是凭借那一丁点儿光认出了回家的路，蚂蚁朝火火大喊了一声：“谢谢你了萤火虫。” 火火像丈二的和尚摸不着头脑–刚才那只蚂蚁谢我干什么啊，我没做什么事。 不一会儿，萤火虫飞到了田边，青蛙妈妈正借着月色给小蝌蚪织衣服，等衣服织好让小蝌蚪穿上，它们就会变成青蛙了。可是月色太微弱，青蛙妈妈一不小心织错了，也不知从何改起，无奈地叹了口气：“唉，小蝌蚪们又得晚几天变青蛙了。” 萤火虫火火正飞累了，停在了青蛙妈妈的旁边，这不，青蛙妈妈不一会儿就改过来织错的衣服了，想着小蝌蚪马上就能变成青蛙，别提多高兴了，“呱呱”地向萤火虫道了谢。萤火虫又奇怪了，我刚刚是没做什么事啊，为什么青蛙妈妈要向我道谢呢？ …… 萤火虫这一晚飞过了很多地方，无论他飞到哪儿，总会听到道谢的声音。火火不知道大家为什么向他道谢，不过想到反正自己能帮助大家，那飞再久也无所谓了。 从此以后，每天夜晚萤火虫都会不停地在夜空下飞舞，知道日出才闭上眼休息。他们不知道，自己的身上有种叫“灯”的东西。 我想，我们每个人都是一只萤火虫，有着一盏只属于自己的独特的灯，那么，我们把这盏灯发出的萤火，分享给别人了吗？ ----------本篇完----------]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>作品集</tag>
        <tag>礼物</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[飞羽作品集（上）]]></title>
    <url>%2F2019%2F01%2F13%2F%E9%A3%9E%E7%BE%BD%E4%BD%9C%E5%93%81%E9%9B%86%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本作品集为飞羽原创，18岁生日时飞羽将其作为礼物赠与本人，现将该作品摘抄并记录在该博客中。 （一）《淡淡》 人生是一本最短也最长的书， 真实中夹杂着虚幻与飘无。 我们不停地写着，头脑麻木， 突然发现， 无数的喜悦与哀愁，都在不停地重复。 也许我们早该醒悟， 去寻找人生真正的归宿。 你的欢笑是我的翅膀， 带我飞离书中的荒芜。 ----------本篇完---------- （二） 两滴雨住在云里，整日悠闲，四处闲逛。 一天，一滴雨被吹过的风带走了，还没来得及和自己的朋友道别就落到了一片池塘里。原本它以为云中的生活才是最舒适安逸，没想到这池塘是如此迷人–鱼儿们自由嬉戏，一两只蜻蜓在池面飞过，……雨滴喜欢上了这里的生活。 然而，池塘中的雨滴还想着云中的雨滴，它不能让它的朋友孤单地生活在云里，不过一旦回去，就不知道什么时候才能再落到这片池塘。纠结了一番后，池塘的雨滴还是觉得朋友更重要，便努力地吸收阳光，希望将自己蒸发回云里。 云中的雨滴同样在想着它的朋友，它在担心朋友落下后生活会不会很困苦，它不能独自在云中过着安逸的生活，让自己的朋友受苦。于是，它努力地挣扎着，一心想落下去寻找自己的朋友，毕竟，两个一起受苦比一个单独受苦要好过些。 终于有一天，池塘中的雨滴吸收了足够多的阳光，兴奋地飞上天去寻找自己的朋友，也就在那一刻，云中的雨滴挣脱了束缚向下落去。他们相遇在半空，它笑了，它也笑了，因为尽管彼此依旧分离，但心中那一份友谊已在半空相遇的那一瞬定格。 （这是童话，亦菲童话） ----------本篇完---------- （三）《风筝与风》 角落里有一只风筝，身上布满了灰尘。 一天，风筝实在受不了这无聊的生活，偷偷跑出去寻找能带给风筝天堂般快乐的风。 风筝先飞到大树的枝头，期盼地问大树：“大树爷爷，您知道风在哪儿吗？”大树看了看摇曳着的树叶：“看，这不就是吗？”风筝挠了挠头：“哪有啊？除了树叶什么都没有嘛，大树爷爷肯定是看我太小，在逗我玩呢，我还是去别处寻找吧！” 风筝飞啊，飞啊，飞到了云朵旁边，风筝急切地问云朵：“云朵姐姐，你知道风在哪儿吗？”云朵惊讶地看着风筝：“哈哈，你傻呀，风不就在这儿吗？”风筝又纳闷了：“明明就没有嘛，你们怎么都逗我玩呢！”风筝想找云朵问清楚，可云朵已经捂着嘴偷笑着飘走了。 不知不觉，风筝已经飘到了天堂，这儿一片欢声笑语，只有风筝闷闷不乐，因为它还是没有看到风，它在想风不是能带给他天堂般的快乐吗？可是自己已经到天堂了，怎么还是一点都不快乐啊！风筝受不了了，大喊了一声：“风啊，你到底在哪啊！”只听四周传来声音：“呵呵，傻孩子，你以为是谁带你到这天堂上来的啊？” 风筝突然明白了，原来风一直就在它身边，只是自己看不到罢了。 我们每个人都是风筝，总有那么一些人是我们的风，我们只顾着寻找他们，却不知道其实他们一直在我们身边，默默地帮助着我们，不离，不弃…… ----------本篇完---------- （四）《逆流的溪水》 一条小溪哗啦啦地流着，带着欢声与笑语。 突然有一天，溪水在想自己会去哪，便问周围的大树自己会去哪儿。 大树说：“流到河里啊！” 溪水又问：“然后呢？” “流去江里。” “再然后呢？” “流到大海里。” “再然后呢？” “到大海里就是你们最终的归宿，你们可以尽情地咆哮，也可以平静地生活。总之，你们是最伟大的。” 溪水有些兴奋：“最伟大的？那我们该做些什么事呢？” 大树笑呵呵的，“你们流入大海后就什么都不用做了，没有什么能再阻拦你们，连太阳也蒸发不了你们。” 溪水倒是有点失落了，它就是想着能多做些什么才不断前行，如果前方是没有意义的伟大，它又何苦盲目前行呢？于是，溪水毅然决然往回流，不顾一切阻挠。 溪水艰苦地逆流着，前方的路越来越窄了，溪水看到前方的路快到尽头了，源头的后方是一片荒凉。溪水勇敢地冲了过去，冲破了源头，冲向它不曾见过的一片荒凉–它以前只看到溪水流过的地方有花有草，从未知道源头后面是日此干涸。 终于，溪水放弃了大海的伟大，成就了源头背后的绿意盎然。 ----------本篇完---------- （五）《遥夜》 漫步于无边的原野， 望见天空繁星点点。 我擦亮憧憬的双眼， 等待着流星的出现。 抬头那一瞬间， 浮现的是你微笑的脸。 ----------本篇完---------- （六）《猫·狗·鼠》 很久很久以前，猫和鼠是朋友，漂泊在外，狗则住在安逸的屋子里。 寒冬到了，猫和鼠觉得在外面过不下去了，边去投靠住在温暖屋子里的狗。狗见它们可怜，便瞒着助人偷偷把猫和老鼠带回家里。 猫和鼠在狗的家里住下后生活非常闲适，因为屋里暖暖的，而且狗每次都会分一些吃的给它们，有时狗甚至只吃骨头，把肉都给猫和鼠吃。然而，猫和鼠越发地贪心了，猫有时就趁狗不在时偷吃助人家的鱼，老鼠更过分，不仅偷吃，还打了很多个洞，把自己吃不下的都藏了起来。忠诚的狗怎么会想到自己如此真心对待的两个朋友会这样对待它的主人呢，所以依然对猫和狗很好，还教他们很多本领，希望它们以后可以像它一样看家。 终于有一天，鼠将“魔爪”伸向了鱼，这让猫有些生气了，便对鼠说：“你有那么多吃的了，为什么还要把我的鱼也搬到你洞里去？”老鼠十分不屑：“鱼又不是你一个人的，凭什么我不能吃！”这下猫火了，干脆一拍两散，向狗告发了老鼠的恶行，并说证据都在洞里面。这下老鼠自知没办法了，躲进洞里去不敢出来。从此以后狗一见老鼠就非常仇恨地扑过去抓它，当然，几乎没抓到过，所以才说狗拿耗子–多管闲事。其实这不是闲事，是狗要报仇哩。 鼠躲进洞之后，一心想着要报猫的告发之仇。可它又打不过猫，便在猫偷吃鱼的时候钻出洞出现在狗的面前，待狗追它时把狗带到猫吃鱼的地方再钻进洞里。狗见猫在偷吃鱼，气不打一处来–我对你不薄啊，你却这样对我。便猛地扑上去要咬猫，猫幸好有爬树这一招才侥幸逃脱。它知道是鼠害它被狗发现偷吃鱼的，所以，整日想着要吃掉老鼠报仇。 从此以后，狗一见猫就疯狂地扑上去捉，猫一见老鼠就疯狂地扑上去捉。猫一见狗就马上爬上树，鼠一见狗和猫就钻到洞里去。 ----------本篇完---------- （七）《蝶与蚕》 在众多的故事里，都是碟笑蚕丑陋，而结果是蝶由蚕破茧而来。很可惜，在这个故事里，角色转换了一下，由蚕来笑蝶了。this is why？因为这是个现实的童话，于人类而言，能吐丝的蚕才是有用的，整日在花丛中打转的蝴蝶简直一文不值。 蚕便笑话蝶：“你看你有什么用，整日虚度光阴，在那些花丛中飞舞着有什么用呢？最后不得落地为土，还得落花怨蝶？”蝶一想，蚕说得确实有道理，自己的人生似乎就在花丛飞舞中虚度了，蝴蝶越想越惭愧，便飞进了一棵树洞，整日练着吐丝，然而终未吐出一根丝来。 终于有一天，蝴蝶受不了吐不出丝的生活，飞去问蚕如何吐丝，此时的蚕已吐出丝变茧，裹住了自己。蝴蝶就一直在外面等着蚕出来好问它要怎么吐丝，结果自然是–蝴蝶看见另一只蝴蝶破茧而出，它这才明白了，自己就由蚕变来的。 既然丝已吐尽，何苦再为难自己呢？吐丝的意义只在于对人类有用， 做蚕做蝴蝶，于自己本身有何区别？于是蝴蝶选择做回自己本身，不再想吐丝的事，尽情飞舞在花丛中。 其实，于蚕于蝶，它们的生活都是有意义的，其区别只在于对人是否有益。活出自己，便已足矣。呆在家中看书是一种美，旅游在外也是一种美。无数种美的交织，成就了认识的幸福。 ----------本篇完---------- （八）《幻·非幻》 晴天下雨， 雨天天晴。 这不是天气， 而是–心情。 白天天黑， 黑夜天亮。 这不是时间， 而是–生活。 ----------本篇完---------- （九） 迷路， 有时也是一种艺术， 可惜， 一般人永远无法理解， 幸运的是， 我邂逅了这种艺术， 日复一日年复一年。 ----------本篇完---------- （十） 我梦见自己在做梦…… 梦中的梦中的我在梦游。 如鬼如魂，无人理会。 当我醒时，我亦梦游。 当我梦游，我仍醒着。 （梦中的我于梦游中写下之，不知应从左往右念，还是从右往左念） ----------本篇完---------- （十一） 我是一个球，很复杂的球。 从我出生的那一刻起，我就会跑了，我看着前方是一片光明，便不停向前追逐着，然而有时前方会闪过一个影子拦住我的视线，在我靠近它的时候它又消失了。 我跑着跑着就累了，在路上挥洒汗水，无论我如何跑，都只能看到那片光明，始终无法抵达。 终于，我不再刻意去追寻那片光明，静静地享受生活，享受同时存在的白天与黑夜。 我是地球，轨迹是圆…… ----------本篇完---------- (十二)《不要和陌生人说话》 小猪要去上学了，小猪妈妈提醒它：“猪儿，千万别和陌生人说话，免得被骗走卖了。” 小猪听从了猪妈的叮嘱，在路上，它遇到了同是去上学的刺猬，刺猬主动上前去打招呼：“嘿，小猪，去上学吗？咱一起去吧！”小猪吓得躲到一边：“不行不行，我妈妈说了不能和陌生人说话，更别说一起去上学了。”说完匆匆走了。 跑着跑着，兔子从草丛跳了出来：“小猪小猪，上个学干嘛这么急匆匆的，又不会迟到。”小猪丢下一句：“不能和陌生人说话。”又向前跑去。 小猪就这样一直跑到了学校， 教室里面它一言不发，心里就是猪妈说的那句“不要和陌生人说话。” 渐渐地，教室里的同学们都反感起来了，班长小猴就对班主任山羊大伯说小猪不和它们说话。山羊大伯去问小猪：“你怎么都不和新同学们说话呢？才开学第一天你们不会就闹矛盾了吧？” 小猪很委屈：“我没和它们闹矛盾，但是我妈说了不要和陌生人说话呢！” 山羊大伯哈哈大笑：“你出生的那时候你认识你妈妈吗？” 小猪想了想，摇摇头说：“不认识。” “那不就是了，你出生时所有的人都是陌生人，但你还是慢慢熟悉了它们，你的亲人们渐渐不再是陌生人了，不是吗？” 小猪点了点头：“嗯。” “所以嘛，你要和同学们多讲话，所有熟悉的人都是从陌生人开始的。”小猪若有所思，在接下来的时间里慢慢和所有的同学都成了朋友。 （若干年前，我们彼此都是陌生人。幸运的是，我们勇敢地敞开了心扉。从此，希望我们能是一辈子的朋友。因为能从陌生人变成朋友，是一种缘分。） ----------本篇完---------- （十三） 我看过这么一个故事，一头老牛正在吃草，背上的一个蚊子对它说：“老牛啊，我要走了了。”老牛看都没看，继续吃草。蚊子又耐着性子说：“老牛啊，我要走了啊！”老牛依然不理会蚊子。蚊子有点生气：“喂，老牛，我要飞走了！”老牛终于发话了：“你要走就走吧！你来时我没注意到，你走了我又何须理会。” 也许我们在许多人心中只是无足轻重的过客，既然要走，何须让每个人都知道呢。然而，有时不经意间就会有对我们很重要的人出现在我们身旁，仅因为我们没注意到他们的到来而任由他们离开，不予理会吗？生命中总有那么多重要的人来到又离去，要想不后悔失去，现在赶紧珍惜吧！可怕的不是没注意到他们的到来，而是在他们离开之后仍无动于衷或茫然未醒。 ----------本篇完---------- （十四）《爱轨》 两根永世不相亲近的铁轨 让人们一直误以为 它们彼此充满仇恨 一样的冰冷 一样的固执 一样的从不理会 其实 火车驶过之时 它们都借着枕木 感受彼此咣咣铛铛的 心跳的速度 即使延伸至千里 也从未停止 而且 两根铁轨都不偷懒 谁也不肯 偷偷缩回自己的肩头 不让对方 承受多一丝的沉重 （许多人总奇怪我为何爱看铁轨，我只是为它们的从未交汇却不离不弃而沉醉。人们总为它们可望而不可及心碎，却不知它们心灵早已依偎。） ----------本篇完---------- （十五）《阳光照不到的角落》 在一处偏僻又荒凉的地方，有一个阴暗的角落，太阳每天东升西落，却总是照不到这个角落。 这个角落就很伤心，因为它对温暖的阳光总是可望而不可及。它就对蚂蚁感叹它的伤心，蚂蚁听了对角落很是同情，便喊了一大群同伴去搬阳光，可阳光一搬到靠近角落的地方就消失了。 蚂蚁又去找老鼠帮忙，老鼠就说：“我在墙上开个洞，阳光就能从后方射进角落了。”角落忙说不可：“这不是要凿穿我的身体吗？怎么能行呢？” 老鼠又去找聪明的小猴帮忙，小猴就说要风帮忙把阳光吹进来吧！大家一听立马去找风，可是无论风用多大的劲，阳光还是吹不进角落，风说别急，它去求太阳照一下角落。 大家怀着期待等着风去说服太阳，可是尽管太阳很为大家的友情感动，但却不能改变运行的轨迹，不然地球很多地方都会遭殃的。动物们有些失望，但角落安慰它们：“没事的，你们已经尽力了，也许我和阳光这辈子没缘吧！” 第二天一早醒来，角落就感觉阳光暖暖地照在身上，这可不是太阳变轨哩，而是动物们用反光镜把阳光照过来的，友谊的力量总是那么伟大，总是不能改变太阳的轨迹，也能改变阳光的方向。 角落开心地笑了，不仅因为身上暖暖的，更因为心里暖暖的，能有这样一群好朋友，即使身体感觉不到阳光也绝不会寒冷的，因为心里依旧洒满了阳光。 ----------本篇完---------- （十六） “是时光 将我凝固； 还是我 将时间停住。“ 当树的年轮不再重复 我惟愿漫步 于记忆中那片 若影若现的荒芜 ----------本篇完---------- （十七） 我们都是人生路上的过客， 路经彼此生命中的沼泽。 有些沼泽我们轻轻踏过， 有些沼泽我们越陷越深。 我陷在谁的沼泽里， 谁又为我的沼泽所困。 如梦若然， 待醒已晚。 ----------本篇完---------- （十八）《蜗牛》 有些动物天生就是官二代，像老虎；有些动物天生就是富二代，像蜗牛–一出生就有房子。 蜗牛的房子以前是很大的，不像现在只可以住它自己一个。这责任要归咎于蜗牛的祖先。 那是很久很久以前，所有的动物都住在原始森林里，动物里有四大天王，它们分别是狮子、老虎、大象和蜗牛（别惊讶，那时的蜗牛真的很大）。狮子和老虎爱欺负甚至杀死其他的动物，而大象和蜗牛则选择吃素不爱杀生。 这一天，狮子和老虎心血来潮，决定来一次大杀戮，吃一顿好的。小动物们可着急了，四处逃窜，但很难摆脱强大的狮子和老虎，便纷纷向蜗牛求救，钻进蜗牛巨大的房子里。虽说蜗牛不杀生，可是它很讨厌有其他的动物到它的房子里，便要赶它们出去。动物们可怎么敢出去啊，外面便是狮子和老虎，出去不等于送死吗？可是蜗牛可管不了这么多，态度非常强硬地赶动物们出去。 小兔子第一个妥协了，委屈地走了出去，刚出去一下就被吃掉了，随着小兔从拥挤的房里走出去，房子变小了一点。动物们见小兔的悲惨遭遇更加不敢出去了，可蜗牛态度非常蛮横，说再不出去就让老虎狮子进来了。动物们失望了，一个一个走出蜗牛的房子，随着它们的走出，蜗牛的房子越变越小，最后只能容纳它自己了。 走出去的动物中属老鼠最聪明，马上去求救大象，钻进了大象的长鼻子里，没想到大象却因此死了，这也让大家发现了大象的弱点。 从此，四大天王就只有狮子和老虎可以称王了，一个森林之王，一个万兽之王。大象看到老鼠就非常惊恐，至于蜗牛，失去了大大的房子，开始受其他动物的欺凌，只能经常把头缩进壳里。也许这就是报应吧，谁让它不救那些小动物呢。 就这么一次杀戮，让四大天王只剩两个。也许若干年之后，狮子和老虎也会变得弱小或暴露出自己的弱点。到时候森林就会是一片和平了，也许蚂蚁还能坐在狮子头上玩哩！ ----------本篇完---------- （十九）《渴望飞翔的企鹅》 企鹅群里出现了一直不寻常的企鹅，当然，从外表肯定看不出来，但它又一颗渴望飞翔的心。其实这个想打来得很巧合，是在它出生的那个夜晚，它做了一个美梦，梦见自己飞翔在天空，那个梦醒来后，它就开始寻找飞翔。 当它向同伴说出这个想法时，所有的同伴都嘲笑着它，它只能孤独地面对现实，默默地坐着飞翔的梦。 于是，它开始付诸实践。首先就是强化已经退化了的翅膀，加强对翅膀的训练，让翅膀有足够的力量维持它飞翔的身体。然后它又开始减肥，它很清楚目前肥胖的身体很难飞起来，尽管很可爱。再接下来，它开始爬到一处不高的冰山上往下跳，感受短暂的飞翔的感觉。尽管它已经很用力地扑腾翅膀，但每次还是很沉重地摔在了冰上。冰很冷，但它的心依然滚烫着。 终于，那一天到来了。它再次从冰山跃下，它–依旧没有飞起来，而是摔在冰上并滑进水里。在滑进水里的那一刻，它突然醒悟了，奋力向前游着，留下一串欢快的笑声在游动的轨迹后面。 其实我们从天上往下看那片企鹅游过的海洋，不也是反射的蓝天吗？远远看去，它就是飞翔在自己渴望的那片蓝天，丝毫没有改变，也许更加轻快呢！我们每个人都有自己的一片蓝天，任我们飞翔，可是我们找到了自己的那片蓝天了吗？ ----------本篇完---------- （二十）《灯》 电线两端连着两盏灯 一盏灯亮着 另一盏，也亮着 夜正不紧不慢地前行 不知不觉 它们都已累了 一盏灯说：“晚安。” 另一盏也通过电线 回应“晚安。“ 夜仍不紧不慢地前行 一盏灯亮着 另一盏，依旧亮着 只是 为了 照亮彼此 夜–已亮 ----------本篇完----------]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>作品集</tag>
        <tag>礼物</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《你的名字》影评]]></title>
    <url>%2F2019%2F01%2F11%2F%E3%80%8A%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E3%80%8B%E5%BD%B1%E8%AF%84%2F</url>
    <content type="text"><![CDATA[导演：新海诚 编剧：新海诚、Waris Dirie、Sherry Hormann 演员：神木隆之介、上白石萌音 一句话评价：超好看超好看超好看！ 这是唯一一部电脑上看过后还想去电影院看的电影，没有失望，满满的满足感，从整体的剧情到唯美的画面再到人物塑造我都特别喜欢。 其实看电影这种事，除了电影本身的质量外，自己的状态也特别能影响整个观影心情。最近因为一些事情导致心里老是空落落又七上八下的，就是那种惦记着某个东西却得不到的感觉。这不正与电影中他俩一直在寻找着神秘却找不到（准确说是并不知道在找什么）一样嘛。 还好，还好最后他俩相遇了，还好泷鼓足了勇气叫住了三叶，还好在那之前他俩都还单着，还好还好。 如果一辈子都想不起来心里那个东西是什么该如何生活？因为想不起，所以何来忘记。 回到电影中来，其实整个电影中伏笔都设置非常好，包括后面勅使炸发电站，泷喝口嚼酒来产生联系。电影中每一幕都是有意图的，都是能在后面找到对应的情节的，每一个画面，每一句台词都是有意义的。这就是我特别喜欢这部电影的原因，饱满而不做作，多看几遍也还是能看出新东西来。 关键是！！每一帧都可以当做壁纸，真的是美翻天！！！ 本影评写于16年12月]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《沙漠之花》影评]]></title>
    <url>%2F2019%2F01%2F11%2F%E3%80%8A%E6%B2%99%E6%BC%A0%E4%B9%8B%E8%8A%B1%E3%80%8B%E5%BD%B1%E8%AF%84%2F</url>
    <content type="text"><![CDATA[导演：Sherry Hormann 编剧：Smita Bhide、Waris Dirie、Sherry Hormann 演员：Liya Kebede、Sally Hawkins、 这部电影讲的是一个受割礼的索马里女孩从非洲逃到英国，被唐纳森发掘而成为一代超模，而后勇敢站出来向全世界反映割礼的残忍与对女性的不尊重。 整部电影的基调比较平淡，却不时地透露出让人心塞的情景，尤其当女主角会议割礼的过程，让人无比揪心，悲恸却有种哭不出来的压抑。 看完电影后便查了很多关于割礼的资料，这种残害人身心的习俗真是太可怕了，千千万万的妇女死于这种惨无人道的习俗，千千万万的妇女因这种毫无因全弊无利的事情而无法享受很多美好的体验。好在总有人站出来，顶着巨大压力和危险与信仰做斗争，为女权奋斗，为更多人的幸福与正常生活而奋斗。 很庆幸自己一直活得没什么障碍，那些自以为很大的事很大的问题在这面前根本不值一提。任何困难都可以被解决，可能不一定恢复，但是能愈合。 本影评写自16年8月]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《爆裂鼓手》影评]]></title>
    <url>%2F2019%2F01%2F11%2F%E3%80%8A%E7%88%86%E8%A3%82%E9%BC%93%E6%89%8B%E3%80%8B%E5%BD%B1%E8%AF%84%2F</url>
    <content type="text"><![CDATA[导演：Damien Chazelle 编剧：Damien Chazelle 主演：Miles Teller、J.K. Simmons 与其说Andrew是在追求自己的梦想，还不如说他是对击鼓有着强烈的偏激的疯狂的热爱。当然这种热爱与Fletcher的魔鬼式训练与咄咄逼人是分不开的。有人把《爆裂鼓手》当做励志来看，寓意一切伟大背后必历经辛酸磨难，但我在观看的过程中却感受到了压迫的气息，不仅仅是Fletcher对学生们的压迫，还有Andrew对自己的逼迫，逼迫自己不断练习不断加速，到最后哪怕是出车祸了都不愿暂时放弃一次机会。 最终的Andrew应该是成功的，但是成功是需要代价的，也是需要突破的机遇。如此偏执的热爱若未完全突破很容易出问题的，从Andrew跟女朋友说分手及家庭聚餐上说的话就能感觉出来。 不管怎样，本宝宝还是偏向于快乐学习健康成长，娃哈哈！ 本影评写自16年8月]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome显示小于12px的字体]]></title>
    <url>%2F2019%2F01%2F10%2FChrome%E6%9C%80%E5%B0%8F%E6%98%BE%E7%A4%BA12px%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[问题描述Chrome上默认最小字体是12px，这就意味着你想设置某个元素(可能是个上标或下标)的font-size为9px，结果显示出来的是12px，有那么一点恼火是吧？ 曾经是可以使用-webkit-text-size-adjust: none来禁止网页调整字体大小，但是Chrome27之后就将该属性禁用了（该属性具体变更集）。这个禁用是有道理的，因为该属性很容易被滥用：很多开发者会直接将该属性设置为全局属性，然后当用户放大或缩小页面时（按住Ctrl滚动鼠标滚轮可缩放网页），文字却维持定义的大小而不放缩，给用户带来的不太友好的体验。 解决方案现在一般是使用transform: scale(0.82)来实现小于12px的字体显示。比如要显示8px的字体，那么可以将该元素加上以下属性： 123456font-size: 12px;-webkit-transform: scale(0.667);-moz-transform: scale(0.667);-ms-transform: scale(0.667);-o-transform: scale(0.667);transform: scale(0.667); 只要缩小到需要尺寸的比例即好。需要注意的是，这个方案需要该元素表现为inline-block。 具体效果戳这儿~ 上述代码可以使用sass的@mixin抽象一下（@mixin相关内容可以看这里），通过传参数来得到想要的字体。 12345678@mixin webkit-font-size($size: 10) &#123; font-size: 12px; -webkit-transform: scale($size / 12); -moz-transform: scale($size / 12); -ms-transform: scale($size / 12); -o-transform: scale($size / 12); transform: scale($size / 12);&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>问题记录</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《高性能JavaScript》- DOM编程]]></title>
    <url>%2F2017%2F09%2F15%2F%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDJavaScript%E3%80%8B-%20DOM%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[众所周知，用JS进行DOM操作那是灰常的昂贵，毕竟人家web应用的性能瓶颈之一啊，但也是有不少优化的法子的~~本章大致从三个方向阐述了DOM编程的优化方法。 尽量减少访问和修改DOM次数浏览器中通常是独立实现DOM和JavaScript的，这样可以允许其他技术和语言也能共享使用DOM和渲染函数，但这也意味着JS想去访问DOM，是要花费一定代价的，访问和修改的次数越高，代价就越高，代码运行速度就越慢。 优化点1 使用DOM更新页面内容时，克隆已有元素，而不是创建新元素在大多数浏览器中，节点克隆都更有效率，虽然效果不是特别明显~~所以对于一些需要多次重复创建的元素，可以先创建第一个，然后重复拷贝操作。也就是用element.cloneNode()代替document.createElement()。 优化点2 遍历HTML集合时，把集合存在局部变量中，并把length缓存在循环外部，用局部变量代替这些需要多次读取的元素看个例子就造了： 12345678910111213141516171819202122232425262728293031323334353637383940//最慢function collectionGlobal() &#123; var coll = document.getElementByTagName('div'), len = coll.length, name = ''; for (var count = 0; count &lt; len; count++) &#123; name = document.getElementByTagName('div')[count].nodeName; name = document.getElementByTagName('div')[count].nodeType; name = document.getElementByTagName('div')[count].tagName; &#125; return name;&#125;//较快function collectionGlobal() &#123; var coll = document.getElementByTagName('div'), len = coll.length, name = ''; for (var count = 0; count &lt; len; count++) &#123; name = coll[count].nodeName; name = coll('div')[count].nodeType; name = coll('div')[count].tagName; &#125; return name;&#125;//最快function collectionGlobal() &#123; var coll = document.getElementByTagName('div'), len = coll.length, name = '', ele = null; for (var count = 0; count &lt; len; count++) &#123; ele = coll[count]; name = ele.nodeName; name = ele.nodeType; name = ele.tagName; &#125; return name;&#125; 优化点3 访问元素节点时，推荐使用只返回元素节点的API，因为它们的执行效率比自己在JS代码中实现过滤的效率要高这些API如下： children – childNodes childElementCount – childNodes.length firstElementChild – firstChild lastElementChild – lastChild nextElementSibling – nextSibing previousElementSibling – previousSibing 优化点4 使用querySelectorAll()查询DOM当咱需要得到特定的DOM元素列表时，需要使用getElementById()和getElementByTagName()进行组合调用，而且还得手动遍历筛选，好不麻烦且效率低下~~ 后来~~querySelectorAll()就横空出世了，只要传入相应的CSS选择器字符串，就能得到咱需要的元素了，而且还是浏览器原生API，比起用JS和DOM操作来遍历查找元素不要快太多啊~~ 而且，querySelectorAll()返回的是一个NodeList，是一个快照而不是动态集合，所以还避免了HTML集合会导致的性能问题。 尽量避免重绘和重排浏览器下载完页面中所有的组件后会解析并生成两个内部数据结构–DOM树和Render树，DOM树都知道是表示页面结果，Render树则是表示DOM节点如何显示。Render树中的节点就是一个“盒”，一旦DOM树和Render树构建完成，浏览器就开始绘制元素了。 当DOM的变化影响了元素的几何属性（宽和高），浏览器就需要重新计算元素的几何属性，其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的元素的部分失效，并重新构建Render树，这就是传说中的重排。重排之后，浏览器会重新绘制受影响的部分，这就是重绘。 易得：重绘和重排都是代价很昂贵的操作，所以要尽量避免避免啊~ 优化点5 合并多次对DOM和样式的修改，然后一次处理 改变样式：可以用CSSText属性做批量修改 批量修改DOM：可以让DOM脱离文档流，修改完再带回文档中，具体有三种方式： 隐藏元素（display：none），修改后再重新显示 使用文档片段在当前DOM之外构建一个子树，再把它拷贝回文档 将原始元素拷贝到一个脱离文档流的节点中，修改该副本节点，完成后再替换原始元素 优化点6 缓存布局信息现在大多数浏览器对重排进行了优化，通过队列化修改并批量修改执行来实现，但是有种操作会强制刷新队列并要求计划任务立即执行！它！就！是！获取元素的布局信息！因为查询布局信息时，浏览器会为了返回最新值而会刷新队列并应用所有变更。 这个时候，局部变量又派上用场了，我们可以通过获取布局信息，把它赋值给局部变量，然后操作局部变量，尽可能地减少布局信息的获取次数。 优化点7 让元素脱离动画流假设有个元素处在页面顶部，然后它可以展开/折叠，那岂不是对它之后所有的元素位置都会产生影响？那岂不是要进行大规模重排？？那岂不是很消耗性能？？？ 咱可以让它脱离文档流啊~先给它设置绝对定位，然后它想咋动就咋动吧，反正就导致一小区域的重绘，等动画结束再恢复它本来的定位。 优化点8 使用事件委托元素绑定事件处理器是有代价的，会占用处理时间，而且浏览器还要跟踪这些处理器，又会占更多的内存。要是页面上一大堆元素都需要绑定一个或多个事件处理器，那还不堵死啊。。。 不过呢，大部分事件是能够冒泡的，咱就可以给外层元素绑定一个处理器，用来处理在其子元素上触发的事件。除了性能上有很大的优化，事件委托其实还有个好处，就是如果一个元素的子元素是动态的，它也可以进行处理。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《高性能JavaScript》- 数据存取]]></title>
    <url>%2F2017%2F09%2F14%2F%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDJavaScript%E3%80%8B-%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96%2F</url>
    <content type="text"><![CDATA[数据的存储位置会很大程度影响其读取速度，so本章就是从这个方向来讨论的优化点~ 优化点1 将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量函数在执行过程中，每遇到一个变量，都会经历一次标识符解析的过程，来决定从哪里获取或存储数据。这个过程就是在搜索执行环境的作用域链，从作用域头部（当前函数运行的活动对象）开始搜索，直到找到标识符。 然鹅，标识符的解析也是要产生性能开销的好不啦，标识符的位置越深，它的读写速度肯定会越慢啊~也就是说，函数中读写局部变量是最快的，因为它们是在作用域链最前线嘛，读取全局变量是最慢的，毕竟是在作用域链最末端位置嘛（emmm…优化了JavaScript引擎的先不管哈）。 所以啊，如果我们在一个函数中要多次引用全局变量或者是跨作用域的变量，最好是先用一个局部变量存起来，通过这个局部变量去访问就好啦。 优化点2 避免使用with语句，谨慎使用try-catch语句with语句和try-catch中的catch语句在执行时是有临时改变作用域链的能力的！这么强大的技能怎么能随便用呢？ with语句用来给对象的所有属性都创建一个变量，它会将指定的对象添加到作用域链中，看下这个例子： 1234567function buildUrl() &#123; var qs = "?debug=true"; with(location) &#123; var url = href + qs; &#125; return url;&#125; 当代码执行到with语句时，一个新的变量对象被创建，它包含了参数指定的对象的所有属性，这个对象会被推入到作用域链首位，也就是说，函数的所有局部变量就被挤到第二个作用域对象中了，访问的代价也就高了啊~~ try-catch语句中的catch子句也有同样的效果。当try代码块中发生错误时，执行过程会自动跳到catch子句，然后把异常对象推入一个变量对象并置于作用域链首位。 咱可以尽量简化代码来是的catch子句对性能的影响最小化，推荐将错误委托给一个函数来处理： 12345678910111213141516function mapArr(arr) &#123; var result; try &#123; result = arr.map((item) =&gt; &#123; return item*2; &#125;); &#125; catch(ex) &#123; handleError(ex); &#125;&#125;function handleError(ex) &#123; console.log('ex: ', ex);&#125;mapArr(&#123;&#125;); 其中catch子句的作用域链如下： 书中给出这种推荐的理由是：只执行一条语句，且没有局部变量的访问，作用域链的临时改变不会影响代码性能。但是！有点想不通的是，如果要访问局部变量，handleError()怎么访问得到嘛，难道是通过传参？那在catch子句中调用handleError()并传参的话也就意味着还是要在catch里访问局部变量嘛。。。如果handleError()不用访问局部变量，表示catch子句里也不用访问局部变量呀，那用不用这个委托函数岂不是没差？？？ 优化点3 确实必要时才使用动态作用域像with语句、try-catch语句中的catch子句、或者包含eval()的函数，都算是动态作用域。动态作用域只存在于代码运行时，也就是说不能通过静态分析（查看代码结构）检测出来。 有些经过优化的JavaScript引擎，会尝试通过分析代码来确定哪些变量可以在特定时候被访问，它们会试图避开传统作用域链的查找，当涉及动态作用域时，这种优化方式就失效了。 优化点4 只在必要时使用对象成员理由如下： 属性或方法在原型链中的位置越深，访问它的速度就越慢 嵌套的对象成员越深，其读取速度就越慢 比如说，在同一个函数中没有必要多次读取同一个对象成员。 123function hasEitherClass(element, className1, className2) &#123; return element.className == className1 || element.className == className2;&#125; 这个代码中读取了两次element.className，也就是说执行了两次对象查找，咱可以将值保存在局部变量中减少一次查找。改成下面这样子： 1234function hasEitherClass(element, className1, className2) &#123; var currentClassName = element.className; return currentClassName == className1 || currentClassName == className2;&#125; 反正这一章最重要的优化点就在于善用局部变量做缓存~把那些需多次使用的对象成员、数组元素、跨域变量都保存在局部变量就对了，谁叫它访问速度快呢~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《高性能JavaScript》- 加载并执行]]></title>
    <url>%2F2017%2F09%2F13%2F%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDJavaScript%E3%80%8B-%20%E5%8A%A0%E8%BD%BD%E5%B9%B6%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[这一章主要从管理浏览器中的js代码来进行阐述优化点。 优化点1：将脚本放在底部讲道理，按我们的理解，将js文件和css文件一起放在head中好像没什么毛病，先加载它们，有助于页面渲染和正确交互呀。 可是！可是坑爹的是，脚本是会阻塞页面渲染的啊，浏览器需要等到它们全部下载并执行完成后，才继续页面渲染。所以把脚本放页面头部会导致明显的延迟，表现为显示空白页面，用户无法浏览页面，也无法与页面进行交互。 更坑爹的是，有些浏览器下载js文件是串行的，也就是说每个文件必须等到前一个文件下载并执行完成后才会开始下载，在这些个文件逐个下载过程中，浏览器上的页面就是一片白茫茫啊~~现在很多浏览器都允许并行下载js文件了，但是仍然会阻塞其他资源的下载，比如图片。尽管脚本的下载过程不会相互影响了，但是页面还是得等所有的js代码下载并执行完才能继续。所以呀，新的浏览器只是治标不治本啊。 恩，综上所述，咱要把所有的&lt;script&gt;标签放到&lt;body&gt;标签的底部，来尽量减少对整个页面下载的影响。 优化点2：合并脚本这个当然是为了减少http请求带来的性能开销咯。下载1个100k的文件会比下载4个25k的文件要快的呀。 可以使用离线的打包工具或者类似Yahoo! combo handler的实时在线服务实现。 优化点3：无阻塞脚本上回讲到，合并脚本可以减少http请求数，提高性能。可是问题来了，合并完的脚本可能很大啊，那我浏览器得等这么大一个脚本下载并执行完再进行后面的操作嘛？ 当然，我们也是有办法解决的。咱实现无阻塞脚本不就好了？咱可以等页面加载完再加载js代码呀，专业点讲，就是在window对象的load事件触发后再下载脚本。实现方法有如下几种： 延迟的脚本主角：defer 技能：允许并行下载（包括其他资源哦），但不会执行，直到DOM加载完成（onload事件被触发前） 可以看个例子： 123456789101112131415161718&lt;html&gt;&lt;head&gt; &lt;title&gt;Script Defer Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; alert('defer'); &lt;/script&gt; &lt;script&gt; alert('script'); &lt;/script&gt; &lt;script&gt; window.onload = function() &#123; alert('load'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 猜猜弹出顺序是啥？恩，script、defer、load。 注：h5规范里讲了，defer属性仅当src属性声明时才生效~~ BTW，async也是允许并行下载的，但是它跟defer不同的在于它是下载完了就直接执行了，没有defer那么好的耐心，还等dom完成加载后才执行。 动态脚本元素原理：使用DOM操作创建一个&lt;script&gt;元素，这个元素中加载某个js文件，然后将该&lt;scirpt&gt;元素添加到页面中。 1234var script = document.createElement('script');script.type = "text/javascript";script.src = "file.js";document.head.append(script); 技能：无论何时启动下载，文件的下载和执行都不回阻塞页面其他进程。 这种方式还有个特点：返回的代码一般会立即执行（是不是想到了JSONP，哈哈哈）。但是我可能需要它下载完成且准备就绪的时候才执行啊，这个时候，&lt;script&gt;的onload事件就派上用场了~~封装一个loadScript方法如下： 1234567891011121314151617181920function loadScript(url, callback) &#123; var script = document.createElement('script'); script.type = "text/javascript"; if (script.readyState) &#123; //还不是为了兼容IE if (script.onreadystatechange) &#123; if (script.readyState === 'loaded' || script.readyState === 'completed') &#123; script.onreadystatechange = null; callback(); &#125; &#125; &#125; else &#123; script.onload = function() &#123; callback(); &#125; &#125; script.src = url; document.getElementByTagName('head')[0].appendChild(script);&#125; 如果需要按顺序下载执行代码的话，可以进行嵌套使用loadScript()方法。当然如果多个文件的下载顺序很重要，更好的做法还是把它们按正确的顺序合并成一个文件。 1234567loadScript('file1.js', function() &#123; loadScript('file2.js', function() &#123; loadScript('file3.js', function() &#123; alert('all files are loaded~~') &#125;) &#125;)&#125;); XMLHttpRequest脚本注入原理：创建一个xhr对象，用它下载js文件，然后通过创建动态&lt;script&gt;元素将代码注入页面中。 12345678910111213var xhr = new XMLHttpRequest();xhr.open('get', 'file1.js', true); //第三个参数表是否异步xhr.onreadystatechange = function() &#123; if (xhr.readystate === 4) &#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; var script = document.craeteElement('script'); script.type = "text/javascript"; script.text = xhr.responseText; document.body.appendChild(script); &#125; &#125;&#125;xhr.send(null); 优点：js代码下载后不会自动执行，你可以把脚本的执行推迟到准备好的时候。（为什么啊？？？书上说代码返回在script标签外，所以不自动执行…没看懂啊…） 局限：不能跨域请求js文件，也就不能从CDN下载咯。 推荐的无阻塞模式先添加动态加载所需的代码，然后加载初始化页面所需的剩下的代码。 有几个延迟加载工具： LazyLoad类库，其实就是loadScript()的增强版 LABjs，它的优点是管理依赖关系的能力]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易秋招面试]]></title>
    <url>%2F2017%2F08%2F31%2F%E7%BD%91%E6%98%93%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[2017年网易公共技术秋招-前端开发工程师。 记录一下噢。 一面 自我介绍一下 jQuery有哪些优势 jQuery插件怎么写 怎么学习前端的，看过哪些书 JS、CSS、HTML哪个比较熟 js的基本数据类型 js中比较经典的引用类型 基本数据类型和引用类型的区别 Function对象是干嘛用的 写一个构造函数继承（因为上面讲到了可以实现继承…） Array对象的slice方法（因为写继承的时候有用到…） 怎么处理浏览器兼容，比如添加事件这个方法（DOM0级事件添加我竟然忘了…IE的attachEvent也没想起来…） 事件委托的原理，举例，优点 哪些事件不能冒泡 写一个经典的闭包（刚好前两天在项目里实现了个函数防抖，就写了这个哈哈哈） 讲一下CSS的盒模型 position有哪几种值，分别表示什么 CSS选择器有哪些 兄弟选择器是用什么表示，举个用到了兄弟选择器的例子 CSS如果有重复，怎么判断哪些生效（计算权重） 伪类和伪元素是一样的吗？ cookie、sessionStorage、localStorage区别 chrome开发者工具有哪些部分很好用？ 最近在学什么？接下来半年准备学什么？ 总的来说一面还是蛮顺利的，二面就开始被吊打了。 二面 介绍一下项目（介绍了公司实习的项目，然而介绍完之后面试官并不问我项目啊啊，直接甩后面的问题了） 如何学习前端知识的 JS、CSS、HTML熟悉程度排序（我的回答是JS&gt;CSS&gt;HTML，他默默抬头看了我一眼…然后我有点虚，说这样排序并不是表示我真的对JS最熟悉，而是因为JS内容太多了，我在它上面花的时间最多…） 要你用原生JS实现一个模块预加载器的话，你会怎么做？（懵逼啊，题目都没搞明白，搞明白后就是懵逼啊…完全没思路…不过面试官看我很迷茫就说了句，没关系的，总有人知道有人不知道的） 要判断一个元素是否在数组中，你会怎么做？（我当时第一反应是indexOf啊，但是我想着这个问题不会这么简单，就说把数组遍历一遍，用forEach，后来又改成some。面试官竟然笑了…瘆得我呀…他说不用考虑我想考察你什么，你就平常怎么用的就怎么说好了。然后我就说那就用indexOf，要是不存在就返回-1咯。） 那一个数组中某个元素可能不止一个，你怎么判断？（这次直接就说了用lastIndexOf跟indexOf比较，相等就表示只有一个） 平常怎么给数组排序的？（我说如果不考虑性能的话就用Array自带的sort()，他问我那要是考虑性能呢？我弱弱地说了句，那就看情况吧…） 平常编码的时候有考虑代码层面的性能优化吗？（…表示除了eslint上的规范，其他没怎么考虑了…） H5和CSS3用了些什么？（这里又给自己挖了个坑，说用CSS3实现字符串长度过长就截取并用省略号代替，然后面试官让我写一下，我竟然把white-space属性名给忘了…） SEO有了解吗？（还真没去了解过…） 实现一个ajax 跨域知道哪些？（jsonp的安全攻防问题，cors怎么实现？） 要你实现一个UI和数据的双向绑定，你怎么做？（我问能用框架吗…他表示当然是用原生js实现啦，框架都帮你实现了…） 双向绑定和单向数据流的优缺点（表示只用过单向数据流的React，大致讲了一下，感觉他并不满意…） 能想起来的问题基本是这些了，最后他说那我这边基本上没问题了，你有什么问题要问的吗？我感觉才面了很短的时间啊，怎么这么快就面完了，然后就表示很惊讶，“恩？这么快？我感觉我比较熟的方向您都没有问诶。。。”他问我对什么比较熟，我说react，然后他回了一句，因为我们不用react，我们有自己实现的一套框架。我：…… 唉，然后我感觉没戏血崩炮灰，问的问题要么不会要么没答好。尤其是js基础方面太差，很多东西大概了解，但是没有去深入理解，所以问到一些实现思路的时候只能一脸懵逼了。所以后来问了下，面试下来您觉得我哪些方面需要加强，我感觉自己js基础比较差应该再深入学习一下。然后面试官停下敲键盘的手，以一个过来人的身份语重心长地跟我讲，其实基础才是最重要的。很多人会觉得会很多框架很炫酷，但其实不管怎么样你都只是在用别人的东西，只是一个不断找坑填坑的过程。但是真正牛逼的人都是基础很牢固，他们能在开发中发现一些底层的问题，然后考虑自己的业务场景和实际需求，自己实现，其实这个过程也就是框架的诞生过程。我们不能只看到市面上的各类框架，我们得知道为啥这些框架为什么会出现，为了解决什么问题，又是如何去实现解决的。 上面的话并不是原话…反正大概是这个意思吧，之前美团面试官也跟我讲过类似的话。不管怎么样，想成为一名合格的工程师，除了会用API，还要对底层原理很熟悉呀，不然就真的只是程序猿了… HR面我也觉得很神奇啊，二面答成那样还能有HR面。 HR面其实没啥好讲了，基本是闲聊。比如学习路径，实习的公司能留下来为啥还会参加秋招，投了哪些公司，职业规划，为啥投网易，薪资要求，还有就是一些调查式的问题了。 总结啊呀，虽然走完了流程，但是表示心里很方啊。不过也好，又深刻地认识到了一个不足之处，只有被吊打之后才有强劲动力去弥补啊。好的吧，自我安慰到此结束，还是继续学习吧…毕竟前路茫茫~~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常见编程题（下）]]></title>
    <url>%2F2017%2F08%2F28%2FJavaScript%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[用两个栈实现队列 实现对象的深克隆 deepClone 实现函数防抖和节流 debounce, thottle 模拟ES5 bind实现 Function.prototype.bind 用函数表达new实例化的过程 createObject 实现懒加载 lazyLoad 实现一个LazyMan LazyMan 用两个栈实现队列用两个栈来实现一个队列，完成队列的enqueue和dequeue操作。 队列中的元素为int类型。 123456789101112function enqueue(inputStack, item) &#123; return inputStack.push(item);&#125;function dequeue(inputStack, outputStack) &#123; if (outputStack.length &lt;= 0) &#123; while (inputStack.length &gt; 0) &#123; outputStack.push(inputStack.pop()); &#125; &#125; return outputStack.pop();&#125; 实现对象的深克隆123456789101112131415161718192021function deepClone(obj)&#123; if (obj === null || typeof obj !== 'object') &#123; return obj; &#125; if (typeof obj === 'function') &#123; return new Function('return' + obj.toString()); &#125; var target = Array.isArray(obj) ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj[key] === obj) &#123; continue ; &#125; if (Array.isArray(obj[key]) || typeof obj[key] === 'object') &#123; target[key] = deepClone(obj[key]); &#125; else &#123; target[key] = obj[key]; &#125; &#125; return target;&#125; 实现函数防抖和节流1234567891011121314151617181920212223242526272829303132333435363738//防抖：等待事件触发后等一段时间再执行，如果触发频率高于设定的延迟时间，就一直等下去function debounce(fn, interval) &#123; var timer, firstTime = true; return function () &#123; clearTimeout(timer); //每次触发前都清空定时器，重新计时 var args = arguments; var self = this; if(firstTime) &#123; firstTime = false; fn.apply(self, args); &#125; timer = setTimeout(function() &#123; fn.apply(self, args); &#125;, interval || 500); &#125;&#125;//节流：不论触发频率，单位时间内指定函数就只被调用一次function throttle(fn, interval) &#123; var timer, firstTime = true; return function () &#123; var args = arguments; var self = this; if (firstTime) &#123; //第一次立即执行 firstTime = false; fn.apply(this, args); &#125; if (timer) &#123; //上次的延迟还没执行 return false; &#125; timer = setTimeout(function()&#123; //延迟执行 clearTimeout(timer); timer = null; fn.apply(this, args); &#125;, interval || 500) &#125;&#125; ####模拟ES5bind实现Function.prototype.bind 1234567891011121314151617181920Function.prototype.bind2 = function (context) &#123; if (typeof this !== "function") &#123; throw new Error("Function.prototype.bind - what is trying to be bound is not callable"); &#125; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125; 参考 ####用函数表达new实例化的过程 createObject 1234567function createObj() &#123; var obj = new Object; var Constructor = Array.shift.call(arguments); obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, arguments); return typeof ret === 'object' ? ret : obj;&#125; 参考 ####实现一个LazyMan 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function _LazyMan(name) &#123; this.tasks = []; var self = this; var fn =(function(n)&#123; var name = n; return function()&#123; console.log("Hi! This is " + name + "!"); self.next(); &#125; &#125;)(name); this.tasks.push(fn); setTimeout(function()&#123; self.next(); &#125;, 0); // 在下一个事件循环启动任务&#125;/* 事件调度函数 */_LazyMan.prototype.next = function() &#123; var fn = this.tasks.shift(); fn &amp;&amp; fn();&#125;_LazyMan.prototype.eat = function(name) &#123; var self = this; var fn =(function(name)&#123; return function()&#123; console.log("Eat " + name + "~"); self.next() &#125; &#125;)(name); this.tasks.push(fn); return this; // 实现链式调用&#125;_LazyMan.prototype.sleep = function(time) &#123; var self = this; var fn = (function(time)&#123; return function() &#123; setTimeout(function()&#123; console.log("Wake up after " + time + "s!"); self.next(); &#125;, time * 1000); &#125; &#125;)(time); this.tasks.push(fn); return this;&#125;_LazyMan.prototype.sleepFirst = function(time) &#123; var self = this; var fn = (function(time) &#123; return function() &#123; setTimeout(function() &#123; console.log("Wake up after " + time + "s!"); self.next(); &#125;, time * 1000); &#125; &#125;)(time); this.tasks.unshift(fn); return this;&#125;/* 封装 */function LazyMan(name)&#123; return new _LazyMan(name);&#125; https://zhuanlan.zhihu.com/p/22387417 http://www.jianshu.com/p/f1b7cb456d37 实现懒加载1234567891011121314151617181920function lazyLoad() &#123; var imgs = document.getElementsByTagName('img'); var n = 0; //提升的变量，避免每次都从第一张图片进行遍历 return function() &#123; var clientHeight = document.documentElement.clientHeight; var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; var i, len; for (i = n, len = imgs.length; i &lt; length; i++) &#123; if (imgs[i].offsetTop &lt; clientHeight + scrollTop) &#123; if (imgs[i].getAttribute('src') === 'images/loading.gif') &#123; imgs[i].src = imgs[i].getAttribute('data-src'); &#125; &#125; &#125; n++; &#125;&#125;window.addEventListner('scroll', throttle(lazyLoad, 200), false);]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常见编程题（中）]]></title>
    <url>%2F2017%2F08%2F26%2FJavaScript%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[判断字符串是否为回文串 isPalindrom 乱序同字母字符串 isAnagram 统计一个字符串出现最多的字母 findMaxDuplicateChar 计算二进制中1的个数 countBit 随机生成指定长度的字符串 randomString 判断传入值是否为2的乘方 is2power 使用递归实现二进制转换 decimalToBinary 判断大括号是否闭合 isBalanced 生成斐波拉契数列 getFibonacci 判断字符串是否为回文串123456789101112131415//循环function isPalindrom(str) &#123; let i, len; for (i = 0, len = str.length; i &lt; len; i++) &#123; if (str.charAt(i) !== str.charAt(len-i-1)) &#123; return false; &#125; &#125; return true;&#125;//借用数组的reverse()function isPalindrom(str) &#123; return str.split('').reverse().join('') === str;&#125; 乱序同字母字符串给定两个字符串，判断是否颠倒字母而成的字符串，譬如 Mary 和 Army 就是同字母而顺序颠倒。 12345function isAnagram(str1, str2) &#123; var sortedStr1 = str1.toLowerCase().split('').sort().join(''); var sortedStr2 = str2.toLowerCase().split('').sort().join(''); return sortedStr1 === sortedStr2;&#125; 统计一个字符串出现最多的字母12345678910111213141516171819202122function getMaxDuplicateChar(str) &#123; var hashObj = &#123;&#125;; var i, len; for (i = 0, len = str.length; i &lt; len; i++) &#123; var char = str.charAt(i); if (hashObj[char]) &#123; hashObj[char]++; &#125; else &#123; hashObj[char] = 1; &#125; &#125; console.log(hashObj); var max = 0; var maxChar = null; for (var item in hashObj) &#123; if (hashObj[item] &gt; max) &#123; max = hashObj[item]; maxChar = item; &#125; &#125; return maxChar;&#125; 计算二进制中1的个数123456789101112131415161718192021222324252627//使用字符的toString方法，对负整数不管用function countBit(binaryNum) &#123; var binaryStr = binaryNum.toString(2).replace(/0/g,''); return binaryStr.length;&#125;//用1与n进行与运算，再将n进行无符号右移function countBit(n) &#123; var count = 0; while (n !== 0) &#123; if (1 &amp; n) &#123; count++; &#125; n = n &gt;&gt;&gt; 1; &#125; return count;&#125;//n与n-1进行与运算function countBit(n) &#123; var count = 0; while (n !== 0) &#123; count++; n = n &amp; (n - 1); &#125; return count;&#125; 参考 随机生成指定长度的字符串12345678910111213141516171819202122//使用36进制大数function randomString(len) &#123; var randomStr = ""; while (randomStr.length &lt; len) &#123; randomStr += Math.random().toString(36).substr(2); &#125; return randomStr.substr(0, len);&#125;//枚举所有字符，有点蠢额...function randomString(len) &#123; var randomStr = ""; var strArr = ["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"]; for(var i = 0; i &lt; len; i++) &#123; var pos = Math.round(Math.random() * strArr.length); console.log(pos); randomStr += strArr[pos]; &#125; return randomStr;&#125; 判断传入值是否为2的乘方123456789101112//若num是2的乘方，那么num &amp; num - 1为0//如num为8时，其二进制为1000，num-1的二进制为0111，num &amp; (num-1) === 0function is2power(num)&#123; if(num &lt; 1) &#123; return false; &#125; if ((num &amp; (num - 1)) === 0) &#123; return true; &#125; else &#123; return false; &#125;&#125; 使用递归实现二进制转换1234567891011function decimalToBinary(n) &#123; if (n &gt;= 1) &#123; if (n % 2) &#123; return decimalToBinary((n - 1) / 2) + 1; &#125; else &#123; return decimalToBinary(n / 2) + 0; &#125; &#125; else &#123; return ''; &#125;&#125; 判断大括号是否闭合创建一个函数来判断给定的表达式中的大括号是否闭合 1234567891011121314151617181920212223function isBalanced(expression) &#123; if (expression.length &lt;= 0) &#123; return true; &#125; var stack = []; var i, len; for (i = 0, len = expression.length; i &lt; len; i++) &#123; var char = expression.charAt(i); if (char === '&#123;') &#123; stack.push(char); &#125; else if (char === '&#125;') &#123; if (stack.length &gt; 0) &#123; stack.pop(); &#125; else &#123; return false; &#125; &#125; &#125; if (stack.pop())&#123; return false; &#125; return true;&#125; 生成斐波拉契数列1234567891011121314151617181920212223242526272829303132333435//for循环function getFibonacci(n) &#123; var arr = []; var i; for (i = 0; i &lt; n; i++) &#123; if (i &lt; 2) &#123; arr.push(1); &#125; else &#123; arr.push(arr[i-1] + arr[i-2]); &#125; &#125; return arr;&#125;//用闭包实现一个Fibonacci数的生成器function fibo() &#123; var a = 0; var b = 1; function genFibo() &#123; var res = a; a = b; b = res + b; return res; &#125; return genFibo;&#125;function getFibonacci(n) &#123; var arr = []; var genFibo = fibo(); for(var i = 0; i &lt; n; i++) &#123; arr.push(genFibo()); &#125; return arr;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的深拷贝]]></title>
    <url>%2F2017%2F08%2F26%2Fjs%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[深拷贝这个坑我一定要来填上了，毕竟绊了我好几次。。。 先交代一下这次填坑的背景，简单说来就是使用Object.assign来拷贝对象，结果这玩意儿有陷阱啊~害得我项目中setState没有被触发，子组件死活不更新，不render，找了半天问题才发现原来坑在这个地方。 Object.assign()的陷阱平常我们写React处理state时，希望数据是immutable，这样处理起来更容易更方便。一般我们喜欢用Object.assign()来复制对象，我一直以为Object.assign()是深复制，会连子节点一起复制。今天项目中的bug让我认识到，我真是错看了它啊~ Object.assign()其实是浅层拷贝，只会对非嵌套的对象进行拷贝，但是如果对象中有嵌套的话，它就只会对被嵌套的对象做引用拷贝了。 可以看一下Polyfill对Object.assign的实现源码： 1234567891011121314151617181920212223if (typeof Object.assign != 'function') &#123; (function () &#123; Object.assign = function (target) &#123; 'use strict'; if (target === undefined || target === null) &#123; throw new TypeError('Cannot convert undefined or null to object'); &#125; var output = Object(target); for (var index = 1; index &lt; arguments.length; index++) &#123; var source = arguments[index]; if (source !== undefined &amp;&amp; source !== null) &#123; for (var nextKey in source) &#123; if (source.hasOwnProperty(nextKey)) &#123; output[nextKey] = source[nextKey]; &#125; &#125; &#125; &#125; return output; &#125;; &#125;)();&#125; 好的吧，其实Object.assign只是这样设计的，并不能说是它的陷阱，当一回标题党。。。 js中的深拷贝虽然有些时候用Object.assign()也够了，但是一旦对象嵌套，用Object.assign()就很可能出现问题，那就要实现深拷贝了。 js深拷贝有两种方式： 一种是用JSON对象，简单粗暴 123function deepClone(obj) &#123; return JSON.parse(JSON.stringify(obj));&#125; 这个方法好处就是简单，粗暴，但是存在两个问题： 一个是会破坏原型链，深拷贝之后，不管这个对象原来的构造函数是什么，深拷贝之后都会变成Object 另一个是它只能处理Number、String、Boolean、Array、扁平对象，即能够被json直接表示的数据结构，无法拷贝属性为Function以及RegExp这类的属性 但是如果只是想单纯拷贝一个嵌套对象，用它还是可以的。 另一种实现方式就是递归拷贝： 123456789101112131415161718192021222324252627function deepClone(obj) &#123; if (obj === null || typeof obj !== 'object' &amp;&amp; !isFunction(obj)) &#123; return obj; &#125; if (isFunction(obj)) &#123; return new Function("return" + obj.toString())(); &#125; else &#123; var name,value; var target = isArray(obj) ? [] : &#123;&#125;; for (name in obj) &#123; value = obj[name]; //判断有没有循环引用 if (value === obj) &#123; continue; &#125; if (isArray(obj) || isObject(value)) &#123; target[name] = deepClone(obj[name]); &#125; else &#123; target[name] = value; &#125; &#125; return target; &#125;&#125; 这个方法考虑了obj是否为数组、函数以及是否有循环引用的问题，算是比较全面了，但是要实现isArray、isFunction、isObject的方法。 12345678910111213141516171819var $ = (function () &#123; 'use strict'; var types = 'Array Object String Date RegExp Function Boolean Number Null Undefined'.split(' '); function type () &#123; return Object.prototype.toString.call(this).slice(8, -1); &#125; for (var i = types.length; i--;) &#123; $['is' + types[i]] = (function (self) &#123; return function (elem) &#123; return type.call(elem) === self; &#125;; &#125;)(types[i]); &#125; return $;&#125;)();//类型判断 可以直接使用那些类库的deepClone方法，比如lodash的cloneDeep、jQuery.extend等 ImmutableJS中的对象一般是可变的，因为是使用了引用赋值，新的随心简单的引用了原始对象，这样可以节约内存，但是应用复杂后，会造成很大的隐患。要解决这个问题的话一般就是用浅拷贝或深拷贝来避免被修改了，但是这样会造成CPU和内存的浪费，就是很耗性能啦。 结合React来看，我们经常在对React应用进行性能优化时会用到shouldComponentUpdate，在这个函数中对state或props进行比较来判断要不要render，但是deepClone和deepCompare都非常消耗性能。但是用Immutable只需要使用===和is比较就能知道是否要执行render()了，所以性能提升是很大的。 不过具体要不要用，当然得看项目中对这个需求大不大了。。。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常见编程题（上）]]></title>
    <url>%2F2017%2F08%2F21%2FJavaScript%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[单个数组去重 unique 两个数组并集、交集、差集 union、intersection、difference 计算数组中元素乘积 productOfArrayExceptSelf 找出数组中最大差值 getMaxProfit 找出连续数组中的缺失数 findMissingNumber 找出整型数组中乘积最大的三个数 找出出现奇数次的数 findOddTimesNum 二分搜索递归实现 binarySearch 实现一个洗牌算法 shuffle 单个数组去重123456789101112131415161718192021222324252627282930313233343536373839//ES6function unique(arr) &#123; return Array.from(new Set(arr));&#125;//HashObject（会自动对传入的键执行toString()）function unique(arr) &#123; const result = []; let hashObj = &#123;&#125;; let i, len; for (i = 0, len = arr.length; i &lt; len; i++) &#123; if (!hashObj[arr[i]]) &#123; hashObj[arr[i]] = true; result.push(arr[i]); &#125; &#125; return result;&#125;//遍历数组，使用indexOf看元素是否已在result数组中function unique(arr) &#123; const result = []; let i,len; for (i = 0, len = arr.length; i &lt; len; i++) &#123; if (result.indexOf(arr[i]) === -1) &#123; result.push(arr[i]); &#125; &#125; return result;&#125;//用filter过滤出index和lastIndex相等的元素function unique(arr) &#123; const result = arr.filter((item, index) =&gt; &#123; return index === arr.lastIndexOf(item); &#125;); return result;&#125; 参考 两个数组求并集、交集、差集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//ES5function union(arr1, arr2) &#123; return arr1.concat(arr2.filter(function(item)&#123; return arr1.indexOf(item) === -1; &#125;));&#125;function intersection(arr1, arr2) &#123; return arr1.filter(function(item)&#123; return arr1.indexOf(item) !== -1 &amp;&amp; arr2.indexOf(item) !== -1; &#125;)&#125;function difference(arr1, arr2)&#123; return arr1.filter(function(item)&#123; return arr2.indexOf(item) === -1; &#125;).concat(arr2.filter(function(item)&#123; return arr1.indexOf(item) === -1; &#125;))&#125;//ES6const union = (arr1, arr2) =&gt; &#123; return Array.from(new Set([...arr1, ...arr2]));&#125;const intersection = (arr1, arr2) =&gt; &#123; return arr1.filter(item=&gt; new Set(arr2).has(item));&#125;const difference = (arr1, arr2) =&gt; &#123; const set1 = new Set(arr1); const set2 = new Set(arr2); return arr1.concat(arr2).filter(item =&gt; !set2.has(item) || !set1.has(item));&#125;//ES7const union = (arr1, arr2) =&gt; &#123; return arr1.concat(arr2.filter(item =&gt; !arr1.includes(item)));&#125;const intersection = (arr1, arr2) =&gt; &#123; return arr1.filter(item =&gt; arr2.includes(item));&#125;const difference = (arr1, arr2) =&gt; &#123; return arr1.concat(arr2).filter(item =&gt; !arr1.includes(item) || !arr2.includes(item));&#125; 计算数组中元素乘积给定某无序数组，要求返回新数组 output ，其中 output[i] 为原数组中除了下标为 i 的元素之外的元素乘积，要求以 O(n) 复杂度实现 123456789101112131415161718function productExceptSelf(numArray) &#123; var product = 1; var size = numArray.length; var output = []; for (var x = 0; x &lt; size; x++) &#123; output.push(product); product = product * numArray[x]; &#125; var product = 1; for (var i = size - 1; i &gt; -1; i--) &#123; output[i] = output[i] * product; product = product * numArray[i]; &#125; return output;&#125; 参考 找出数组中最大差值1234567//使用Math的max和min方法function getMaxProfit(arr) &#123; var max = Math.max.apply(Math, arr); var min = Math.min.apply(Math, arr); return max-min;// return Math.max(...arr) - Math.min(...arr);&#125; 找出连续数组中的缺失数给定某无序数组，其包含了 n 个连续数字中的 n - 1 个，已知上下边界，要求以O(n)的复杂度找出缺失的数字。 1234567function findMissingNumber(arr, max, min) &#123; var arrSum = arr.reduce((pre, cur) =&gt; &#123; return pre + cur; &#125;); var sum = (max * (max + 1) / 2) - (min * (min - 1) / 2); return sum - arrSum;&#125; 找出整型数组中乘积最大的三个数1234567891011//先把数组排序，最大乘积要么是min1*min2*max1，要么是max1*max2*max3function maxProduct(arr) &#123; var sortedArr = arr.sort(compare); var len = arr.length; var product1 = arr[len - 1] * arr[len - 2] * arr[len - 3]; var product2 = arr[0] * arr[1] * arr[len - 1];&#125;function compare(a, b) &#123; return a - b;&#125; 找出出现奇数次的数给你n个数，其中有且仅有一个数出现了奇数次，其余的数都出现了偶数次。用线性时间常数空间找出出现了奇数次的那一个数。 1234567891011121314151617//用hashObjfunction getShowOddTimesNumber(arr) &#123; let obj = Object.create(null); arr.forEach(item =&gt; obj[item] = !obj[item]); for(let key in obj) &#123; if(obj[key]) &#123; return key; &#125; &#125;&#125;//将所有元素都异或一遍，最后得到的就是那个出现奇数次的元素function getShowOddTimesNumber(arr) &#123; return arr.reduce((pre,cur) =&gt; &#123; return pre ^ cur; &#125;)&#125; 二分搜索递归实现12345678910111213function binarySearch(arr, value, left, right) &#123; if (left &gt; right) &#123; return -1; &#125; var mid = Math.floor((left + right) / 2); if (arr[mid] === value) &#123; return mid; &#125; else if (arr[mid] &gt; value) &#123; return binarySearch(arr, value, left, mid - 1); &#125; else &#123; return binarySearch(arr, value, mid + 1, right); &#125;&#125; ####实现一个洗牌算法 123456789101112131415161718192021222324252627//随机选取数组中的元素添加到另一个数组中，复杂度为n^2function shuffle(arr) &#123; var result = []; var random; while (arr.length &gt; 0) &#123; randomIndex = Math.floor(Math.random() * arr.length); result.push(arr[randomIndex]); arr.splice(randomIndex, 1); &#125; return result;&#125;//在原数组上进行交换元素的操作，时间复杂度为nfunction shuffle(arr) &#123; var len = arr.length; var randomIndex, tmp; while (len &gt; 1) &#123; randomIndex = Math.floor(Math.random() * len); len--; tmp = arr[randomIndex]; arr[randomIndex] = arr[len]; arr[len] = tmp; &#125; return arr;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM知识点--《高程》]]></title>
    <url>%2F2017%2F08%2F14%2FDOM%E7%9F%A5%E8%AF%86%E7%82%B9--%E3%80%8A%E9%AB%98%E7%A8%8B%E3%80%8B%2F</url>
    <content type="text"><![CDATA[《JavaScript高级程序设计》DOM相关知识点复习。 DOM层次 DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的树形结构 文档节点是每个文档的根节点，每个文档只能有一个文档元素（\&lt;html&gt;） Node类型 JS中所有节点类型都继承自Node类型，因此所有节点类型都共享相同的基本属性和方法 可用Node.nodeType确定节点类型 对于元素节点，nodeName保存了元素的标签名，nodeValue值为null 节点关系所有节点都有的三个属性： childNodes：其中保存着一个NodeList对象 NodeList是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点 NodeList是“动态的”，是在访问DOM文档时实时运行的查询，所以DOM结构的变化能自动反映在NodeList对象中（NamedNodeMap和HTMLCollection也是） parentNode：该属性指向文档树中的父节点 使用previousSibling和nextSibling可以分别访问节点的前一个节点和后一个节点 父节点的firstChild和lastChild分别指向childNodes列表中的第一个和最后一个节点 如果某父节点只有一个子节点，那么firstChild和lastChild指向同一个节点，该子节点的previousSibling和nextSibling都为null hasChildNodes()返回节点是否包含子节点 ownerDocument：指向表示整个文档的文档节点 任何节点都不能同时存在于两个或更多个文档中 操作节点 appendChild(newNode)：向childNodes列表的末尾添加一个节点 12//将第一个子节点移到最后一个var returnNode = someNode.appendChild(someNode.firstChild); insertBefore(newNode)：将节点插入到某个节点之前 1234567891011//插入后成为最后一个子节点var returnNode = someNode.insertBefore(newNode, null);//插入后成为第一个子节点var returnNode = someNode.insertBefore(newNode, someNode.firstNode);//插入到最后一个子节点之前var returnNode = someNode.insertBefore(newNode, someNode.lastChild);//实现insertAftersomeNode.parentNode.insertBefore(newNode, someNode.nextSibling); replaceChild(newNode，node)：替换某个子节点 removeChild(node)：删除某个子节点 12//移除某节点someNode.parentNode.removeChild(someNode); 前面四个方法操作的是某个节点的子节点，要使用这几个方法必须先获取父节点 其他方法有两个方法所有类型的节点都有： cloneNode()和normalize() cloneNode()：用于复制节点，参数为true时执行深复制（复制节点及整个子节点数） cloneNode()返回的节点属于文档所有，但是并没有为它指定父节点，需要使用插入操作将其插入到文档中 cloneNode()方法只复制特性、子节点，不会复制添加到节点上的js属性，如事件处理程序 normalize()： Document类型 document对象是HTMLDocument的一个实例，表示整个HTML页面，也是window对象的一个属性，因此可以作为全局对象来访问 文档的子节点 可以使用documentElement属性（始终指向HTML页面中的\&lt;html&gt;元素）或childNodes列表访问文档元素 body属性，直接指向\&lt;body&gt;元素 doctype属性，指向&lt;!DOCTYPE&gt;标签 多数情况下，不需要在document对象上调用appendChild()、removeChild()和replaceChild()方法，因为文档类型是只读的，且只能有一个元素子节点 文档信息document对象包含一些可表现网页信息的属性。 title：包含元素中的文本 URL：包含页面的整个URL domain：包含页面的域名 referrer：保存着链接到当前页面的那个页面的URL 上面三个属性中，只有domain是可以设置的，但是不能将domain设置为URL不包含的域。 [通过将不同子域页面的document.domain设为相同的值，就能相互访问对方包含的JavaScript对象了] 查找元素 getElementById(id)：返回文档中第一次出现的元素（若无则返回null） getElementsByTagName(tagName)：返回包含零或多个元素的NodeList（在HTML文档中，返回一个HTMLCollection对象） getElementByName()：返回带有给定name特性的所有元素（一般用来取得单选按钮） 其他 使用document.implementation.hasFeature(name, version)检测浏览器是否支持某版本的DOM功能 使用write()和whiteln()动态向页面中添加内容 使用open()和close()分别用于打开和关闭网页的输出流 Element类型 要访问元素的标签名，可以用codeName或tagName属性 HTML中，标签名始终全部大写，XML中，标签名始终与源代码中保持一致 HTML元素HTMLElement类型直接继承自Element并添加了一些属性（每个HTML元素中都存在）：id、title、lang、dir、className 操作特性 获取特性：DOM对象的属性（div.id）、div.getAttribute(&quot;id&quot;)。有两类特殊的特性，其属性值与getAttribute()返回的值不同： style：通过属性访问返回一个对象，而用getAttribute()访问返回CSS文本 事件处理程序（如onClick）：通过属性访问返回一个js函数，用getAttribute()返回相应代码的字符串 一般使用对象属性获取特性，除非需要自定义特性值，才使用getAttribute() 设置特性：setAttribute()。既可以操作HTML特性也可以操作自定义特性。 删除特性：removeAttribute()。用于彻底删除元素的特性。 attribute属性 Element类型是唯一一个使用attributes属性的DOM节点类型 attribute属性中包含一个NamedNodeMap，元素的每个特性都由一个Attr节点表示，每个结点都保存在NamedNodeMap对象中。 NamedNodeMap对象有如下方法： getNamedItem(name)：返回nodeName为name的特性 removeNamedItem(name)：删除nodeName为name的特性，并返回该特性的Atrr节点 setNameItem(node)：添加节点，以节点的nodeName属性为索引 item(pos)：返回位于数字pos位置处的节点 [一般要遍历元素的特性时，才会使用attributes属性] 其他 创建元素：document.createElement() 子节点：元素的childNodes属性中包含了它所有子节点 其他类型其他还比较常见的节点类型有：Text类型、Comment类型、DocumentFragment类型 Text类型 文本节点包含的是纯文本内容，其中包含转义后的HTML字符，但不能包含HTML代码 每个可以包含内容的元素最多只能有一个文本节点，且必须确实有内容存在 使用document.createTextNode()创建新文本节点 在一个包含两个或多个文本节点的父元素上调用normalize()方法，会将所有文本节点合并成一个节点（浏览器在解析文档时永远不会创建相邻的文本节点，这种情况只可能出现在DOM操作中） 使用splitText()可以将一个文本节点分成两个文本节点（从文本节点中提取数据的DOM解析技术） Comment类型 使用document.createComment()创建注释节点 Comment类型与Text类型继承自相同的基类，拥有除了splitText()之外的所有字符串操作方法 DocumentFragment类型 所有节点类型中，只有DocumentFragment在文档中没有对应的标记，它可以包含和控制节点，但是不会像完整的文档那样占用额外资源 可以使用一个文档片保存创建的列表项，然后在一次性将他们添加到文档中，这样可以避免重复渲染 DOM扩展对DOM的两个主要的扩展是SelectAPI和HTML。 选择符APISelectAPI致力于让浏览器原生支持CSS查询。 querySelector()：接收一个CSS选择符，返回与该模式匹配的第一个元素: querySelectorAll()：返回一个NodeList的实例（类似于一组元素的快照，而非不断对文档进行搜索的动态查询） matchesSelector()：若调用元素与选择符匹配，则返回true，否则返回false 元素遍历Element Traversal API为DOM元素添加了以下5个属性（为了弥补浏览器元素间空格处理不同的差异）： childElementCount：返回子元素（不包括文本节点和注释）的个数 firstElementChild：指向第一个子元素，firstChild的元素版 lastElementChild：指向最后一个子元素，lastChild的元素版 previousElementSibling：指向前一个同辈元素，previousSibling的元素版 nextElementSibling：指向后一个同辈元素，nextSibling的元素版 HTML5与类相关的扩充 getElementByClassName()：返回带有指定类的所有元素的NodeList className属性：用于操作类名，如添加、删除和替换类名 classList属性：也用于操作类名，比className使用更方便安全，有如下方法： add(value)：添加类名 remove(value)：删除类名 contains(value)：判断列表中是否存在该类名 toggle(value)：若列表中存在该类名则删除，否则就添加 焦点管理 document.activeElement属性：始终引用DOM中当前获得了焦点的元素 元素获得焦点的方式有页面加载、用户输入以及在代码中调用focus()方法 默认情况下，文档加载过程中，document.activeElement的值为null，文档刚刚加载完时，其值为document.body元素的引用 document.hasFocus()可以判断文档是否获得了焦点 其他属性 readyState属性：用来实现一个指示文档已经加载完成的指示器，有两个值： loading：正在加载文档 complete：已经加载完文档 compatMode属性：说明渲染页面的模式是标准的还是混杂的 CSS1Compat：标准模式（按照W3C的标准解析和渲染页面） BackCompat：混杂模式（按浏览器自己的标准解析渲染页面） head属性：指向文档的\&lt;head&gt;元素 charset属性：表示文档中实际使用的字符集，也可以用来指定新字符集 dataset属性：用于访问自定义属性的值，为一个DOMStringMap的实例 scrollIntoView()方法：通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中 插入标记 innerHTML属性： 读模式下，innerHTML返回与所有子节点对应的HTML标记 写模式下，innerHTML的值会被解析成DOM子树，替换调用元素原来的所有子节点 可以使用window.toStaticHTML()处理HTML字符串，删除所有脚本节点和事件处理程序属性 outerHTML属性：返回调用它的元素及其所有子节点的HTML标签 insertAdjacentHTML()：接受两个参数，插入位置和要插入的HTML文本，第一个参数必须是下列值之一： beforeBegin：在当前元素之前插入一个紧邻的同辈元素 afterBegin：在当前元素下插入一个新的子元素或在第一个子元素前插入新的元素 beforeEnd：在当前元素下插入一个新的子元素或在最后一个子元素后再插入新元素 afterEnd：在当前元素之后插入一个紧邻的同辈元素 在使用上面的属性将元素从文档中删除时，元素与事件处理程序之间的绑定关系在内存中并没有一并删除，所以最好手动删除要被替换的元素的所有事件处理程序和JS对象属性 DOM2和DOM3 importNode()：从一个文档中取得一个节点，然后将其导入另一个文档（跟Element的cloneNode()相似） isSameNode()：两个节点引用的是同一个对象时返回true isEqualNode()：两个节点是相同的类型，具有相等的属性，且其attributes和childNodes属性也相等，就返回true 样式元素大小 偏移量：包括元素在屏幕上占用高度所有可见空间 offsetHeight：height+padding(top+bottom)+border(top+bottom) offsetWidth：width+padding(top+bottom)+border(top+bottom) offsetTop：top+marginTop，表示距离offsetParent的左间距 offsetLeft：left+marginLeft 12345678910//得到某个元素在页面上的偏移量，将该元素的offsetLeft和offsetTop与其offsetParent的相同属性想家，如此循环至根元素function getElementLeft(element) &#123; var actualLeft = element.offsetLeft; var current = element.offsetParent; while(current != null) &#123; actualLeft += current.offsetLeft; current = current.offsetElement; &#125; return actualLeft;&#125; 客户区大小（clientWidth，clientHeight）：指元素内容及其内边距所占据的空间大小，通常用于确定浏览器视口大小（document.body.clientWidth || document.documentElementWidth） 滚动大小：包含滚动内容的元素的大小 scrollHeight：在没有滚动条的情况下，元素内容的总高度 scrollWidth：在没有滚动条的情况下，元素内容的总宽度 [scrollHeight和scrollWidth主要用于确定元素内容的实际大小] scrollLeft：被隐藏在内容区域左侧的像素数 scrollTop：被隐藏在内容区域上方的像素数 [元素未被滚动时，scrollLeft和scrollTop的值为0，将这两个值设为0可以重置元素的滚动位置] getBoundingClientRect()：返回一个矩形对象，包含left、top、right和bottom四个属性，给出了元素在页面中相对于视口的位置 遍历DOM2级遍历和范围模块定义了两个类型用于辅助进行DOM结构的遍历：NodeIterator、TreeWalker，这两个类型都是基于给定的起点对DOM结构进行深度优先的遍历操作。 NodeIterator 可以使用document.createNodeIterator()创建NodeIterator实例，该方法接收四个参数： root：搜索起点节点 whatToShow：表示要访问哪些节点的数字节点 filter：一个NodeFilter对象，或一个表示应该接收还是拒绝某种特定节点的函数 entityReferenceExpansion：表示是否要扩展实体引用 nextNode()：在深度优先的DOM子树遍历中，用于向前前进一步，第一次调用会返回根节点 previousNode()：用户向后后退一步 TreeWalker TreeWalker是NodeIterator的一个更高级的版本，除了nextNode和previousNode以外，还有几个其他方法： parentNode()：遍历到当前节点的父节点 firstChild()：遍历到当前节点的第一个子节点 lastChild()：遍历到当前节点的最后一个子节点 nextSibling()：遍历到当前节点的下一个同辈节点 previousSibling()：遍历到当前节点的上一个同辈节点 使用document.createTreeWalker()创建TreeWalker实例]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来自M小姐的毒药]]></title>
    <url>%2F2017%2F08%2F02%2F%E6%9D%A5%E8%87%AAM%E5%B0%8F%E5%A7%90%E7%9A%84%E6%AF%92%E8%8D%AF%2F</url>
    <content type="text"><![CDATA[M小姐是我上研究生认识的，是我的硕士同班同学兼实验室伙伴兼项目战友兼寝室室友兼实习同事兼实习室友兼我的亲人。 在见到她之前，听另一个室友说，她比我还瘦。我感到无比惊讶，比那时候的我还瘦得瘦成什么样。 第一眼见到她时，是在二舍寝室，她面向着门背对着窗，明明无比逆光，我却清楚地看到了她脸上洋溢的微笑，热情而亲切。而逆光下的她的身形一览无遗，当时我就在想，真是个小巧玲珑的妹子。 M小姐是个特别善良的妹子。 某个周六我们赖在寝室不想出门吃饭，M回来后看到我们一副懒虫样，提出可以帮我们带饭。我们也不是那么无理的人啊，怎么好意思让人家专门跑一趟给带饭呢，就拒绝了。结果M小姐特别执着地说，没关系的，我刚好想出去走走，就顺便帮你们带吧，不然你们下午会饿的，硬生生地说服了我们接受了她的帮助。回来时可开心了，还怕我们过意不去一个劲儿地给我们洗脑说是她自己想出去走走的，当时我就在想，真是个善良可爱的妹子。 知乎上有句话我特别同意，一个人最大的善良就是在别人休息时轻手关门轻声讲话。我曾经觉得我就属于这类人，但是认识了M小姐后，我才发现M小姐才是高手啊。在学校时，M小姐早上都醒得很早，还没7点就醒了，而我们寝室的水龙头声音特别大，开关门的声音也特别大，M小姐怕这么早会影响我们休息，就在床上躺到7点半才起床。实际上，M小姐啥时候起床啥时候走的我们也不知道，因为她动作特别轻。M小姐没有准备台灯，但是早上起来既不开灯也不拉开点窗帘，每早都是举着手机收拾完自己。有次无意间发现，M小姐为了不让光透进寝室照醒我们，她竟然是从窗帘缝里钻出寝室去的阳台，这个妹子，实在是太为人着想了。 M小姐是个特别细心的妹子。 我是出了名的健忘，自从跟M小姐混在一起后，我就更健忘了。因为细心的M小姐什么都会帮我记住，什么时候要去哪里，出门要带什么东西，去超市要买什么，欠了谁的钱谁欠了我的钱都给我记着了。M小姐有时候在认真看电视，突然来一句，你上次说的那件事办了吗？我：……额，差点忘了……有了细心的M小姐，我根本没理由逼自己记住这一切啊。 以前出去玩手机电量一定不能低于90%，因为要查路线查导航，但是跟M小姐出去手机关机都不怕～毕竟M小姐是我公认的活地图，去过一次的地方就记住地点了，走过一遍的路就记住路线了。所以跟M小姐出门，只管带上自己就好了。 M小姐是个特别认真的妹子。 309实验室是个特别不正经的场所，但是里面出了个特别认真的M小姐。起初这对M小姐可不是什么好事，认真的M小姐在我们这群老司机段子手中间总是略显格格不入。可这也不是什么坏事，正经的M小姐不知不觉中就被带偏了，现在是个开车稳段子冷的正经妹子了。不过尽管那群老司机们带偏了M小姐，M小姐仍然是个非常认真的人。有句话怎么说的来着，狗改不了吃屎？（原谅我没文化……） 不管你跟M小姐讲什么，她都会非常认真地帮你分析。虽然你的有些观点她未必赞同，但她会认真地站在你的角度去理解，然后一本正经地告诉你应该怎样，不敷衍。 M小姐是个特别有活力的妹子。 在跟M小姐同居之前，我们一直都觉得M小姐是个永动机，从来都不知累为何物。每次我们出去浪，临近回来时我就开始叫累不迭，连回去的力气都没了。可是M小姐还是精力不减，还能又蹦又跳，继续奋战。但是有一点M小姐比不上我，那就是…吃！M小姐有时候很想多尝试些美食，无奈胃容量有限，只能安慰自己下次再来了。 M小姐给我下毒了。 上面夸了M小姐那么多，那都是可忽略的，接下来这点才重要，她对我下毒这件事才重要。 曾经，我生活独立精神独立，可以一个人背着书包去自习室，一个人带着饭卡去食堂，一个人拿着球拍去球馆，一个人拉着行李去实习，不需要朋友的关心不需要倾诉的对象不需要所谓的精神寄托，很会掩饰自己的感情不轻易表现自己的情绪。用高中闺蜜们的话来说，就是太坚强，让人有距离感。 可是M小姐竟然给我下了慢性毒药。我有什么决定会愿意告诉M小姐，M小姐会先帮我分析一波然后表示支持我的决定；我有什么开心的事情会乐于跟M小姐分享，M小姐会特别开心地为我的开心而开心；我有什么难过伤感的情绪会在M小姐面前流露，M小姐都会想办法帮我排解忧愁；更可怕的是，有些事情我以为可以藏在心里一辈子，但会不经意间跟M小姐说起。想到这，真是觉得可怕，M小姐都知道我所有的秘密了。 在学校的时候，我们都亲切地称M小姐为“天使”，但是这个天使都快把我毒害成孩子了，那个坚强独立的人设已经被毒没了。毕竟，健忘的时候有人帮你记着事情，出门的时候有人帮你导航路线，犯懒的时候有人帮你做好早餐，难过的时候有人切好水果放你面前，开心有人跟你分享，伤心有人陪你聊天，委屈有人替你心疼。还要啥坚强！要啥独立！ 我在想啊，要是我以后找不到男朋友，M小姐是要背一半锅的。 这才是重点。 恩，上面其实都不是重点，重点是，这么好这么优秀的一个妹子，是单身哦~现附上背影一张~ 心动不如行动，汉子们，燥起来吧^O^]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>人物</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React相关面试题]]></title>
    <url>%2F2017%2F07%2F31%2FReact%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[React解决了什么问题 如何设计一个好的组件 组件的render函数在何时被调用 调用render时DOM就一定会被更新吗 组件的生命周期 进行远程数据加载时，应该在哪个周期中完成 在哪些生命周期中可以修改组件的state 不同父节点的组件需要对彼此的状态进行改变时应该怎么实现 state里应该有什么 如何对组件进行优化 组件中的key属性有什么用 Component与Element和Instance的区别 调用setState时，发生了什么事 什么时候使用类组件（Class Component）而非功能组件（Functional Component） 什么是React的refs，为什么它们很重要 受控组件（controlled component）和不受控组件（uncontrolled component）有什么区别 描述事件在React中的处理方式 React解决了什么问题？a. React实现了Virtual DOM 在一定程度上提升了性能，尤其是在进行小量数据更新时。因为DOM操作是很耗性能的，而Virtual DOM是在内存中进行操作的，当数据发生变化时，通过diff算法比较两棵树之间的变化，再进行必要的DOM更新，省去了不必要的高消耗的DOM操作。当然，这种性能优化主要体现在有小量数据更新的情况下。因为React的基本思维模式是每次有变动就重新渲染整个应用，简单想来就是直接重置innerHTML，比如说在一个大型列表所有数据都变动的情况下，重置innerHTML还比较合理，但若是只有一行数据变了，它也需要重置整个innerHTML，就会造成大量的浪费。而Virtual DOM虽然进行了JS层面的计算，但是比起DOM操作来说，简直不要太便宜。 为什么操作真实DOM比React更快？ b. React的一个核心思想是声明式编程。 命令式编程是解决做什么的问题，就像是下命令一样，关注于怎么做，而声明式编程关注于得到什么结果，在React中，我们只需要关注“目前的状态是什么”，而不是“我需要做什么让页面变成目前的状态”。React就是不断声明，然后在特定的参数下渲染UI界面。这种编程方式可以让我们的代码更容易被理解，从而易于维护。 c. 组件化 React天生组件化，我们可以将一个大的应用分割成很多小组件，这样有好几个优势。首先组件化的代码像一棵树一样清楚干净，比起传统的面条式代码可读性更高；其次前端人员在开发过程中可以并行开发组件而不影响，大大提高了开发效率；最重要的是，组件化使得复用性大大提高，团队可以沉淀一些公共组件或工具库。 d. 单向数据流 在React中数据流是单向的，由父节点流向子节点，如果父节点的props发生了变化，那么React会递归遍历整个组件树，重新渲染所有使用该属性的子组件。这种单向的数据流一方面比较清晰不容易混乱，另一方面是比较好维护，出了问题也比较好定位。 如何设计一个好组件组件的主要目的是为了更好的复用，所以在设计组件的时候需要遵循高内聚低耦合的原则。 可以通过遵循几种设计模式原则来达到高复用的目的，比如单一职责原则：React推崇的是“组合”而非“继承”，所以在设计时尽量不设计大的组件，而是开发若干个单一功能的组件，重点就是每个组件只做一件事；开放/封闭原则，就是常说的对修改封闭，对扩展开放。在React中我们可以用高阶组件来实现。 使用高阶组件来实现组件的复用。高阶组件就是一个包装了另一个React组件的React组件，它包括属性代理（高阶组件操控着传递给被包裹组件的属性）和反向继承（实际上高阶组件继承被包裹组件）。我们可以用高阶组件实现代码复用，逻辑抽象。 使用容器组件来处理逻辑，展示组件来展示数据（也就是逻辑处理与数据展示分离）。比如可以在容器组件中进行数据的请求与处理，然后将处理后的数据传递给展示组件，展示组件只负责展示，这样容器组件和展示组件就可以更好地复用了。 编写组件代码时要符合规范，总之就是要可读性强、复用性高、可维护性好。 组件的render函数何时被调用 组件state发生改变时会调用render函数，比如通过setState函数改变组件自身的state值 继承的props属性发生改变时也会调用render函数，即使改变的前后值一样 React生命周期中有个componentShouldUpdate函数，默认返回true，即允许render被调用，我们也可以重写这个函数，判断是否应该调用render函数 调用render时DOM就一定会被更新吗不一定更新。 React组件中存在两类DOM，render函数被调用后， React会根据props或者state重新创建一棵virtual DOM树，虽然每一次调用都重新创建，但因为创建是发生在内存中，所以很快不影响性能。而 virtual dom的更新并不意味着真实DOM的更新，React采用diff算法将virtual DOM和真实DOM进行比较，找出需要更新的最小的部分，这时Real DOM才可能发生修改。 所以每次state的更改都会使得render函数被调用，但是页面DOM不一定发生修改。 组件的生命周期组件生命周期有三种阶段：初始化阶段（Mounting）、更新阶段（Updating）、析构阶段（Unmouting）。 初始化阶段： constructor()：初始化state、绑定事件 componentWillMount()：在render()之前执行，除了同构，跟constructor没啥差别 render()：用于渲染DOM。如果有操作DOM或和浏览器打交道的操作，最好在下一个步骤执行。 componentDidMount()：在render()之后立即执行，可以在这个函数中对DOM就进行操作，可以加载服务器数据，可以使用setState()方法触发重新渲染 组件更新阶段： componentWillReceiveProps(nextProps)：在已挂载的组件接收到新props时触发，传进来的props没有变化也可能触发该函数，若需要实现props变化才执行操作的话需要自己手动判断 componentShouldUpdate(nextProps，nextState)：默认返回true，我们可以手动判断需不需要触发render，若返回false，就不触发下一步骤 componentWillUpdate()：componentShouldUpdate返回true时触发，在render之前，可以在里面进行操作DOM render()：重渲染 componentDidUpdate()：render之后立即触发 组件卸载阶段： componentWillUnmount()：在组件销毁之前触发，可以处理一些清理操作，如无效的timers等 componentDidMount()：卸载后立即触发 进行远程数据加载时，应该在哪个周期中完成 最好是在componentDidMount中进行异步请求。如果我们将ajax请求放在生命周期其他函数中，如constructor或componentWIllMount中，我们并不能保证请求仅在组件挂载完毕后才响应。如果我们的数据请求在组件挂载前就完成，并调用setState函数将数据添加到组件状态中，对于未挂载的组件会报错。而在componentDidMount中进行ajax请求能有效避免这个问题。 1Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。[没深入] 顺便说说componentWillMount函数，这个方法是在render前立刻执行的，也是服务器渲染中唯一调用的钩子，其实除了同构的需求，通常情况下可以用constructor()方法代替。 在哪些生命周期中可以修改组件的state componentDidMount和componentDidUpdate constructor、componentWillMount中setState会发生错误：setState只能在mounted或mounting组件中执行 componentWillUpdate中setState会导致死循环 不同父节点的组件需要对彼此的状态进行改变时应该怎么实现 在没有Flux之前，Facebook推荐使用事件机制，但是一旦应用中这种需求增多，事件和回调会满天飞 传递接口，就是需要root传递两个接口给A和B，当A想改变B的状态时，A调用root传递给它的接口，然后这个接口再调用root传给B的接口（这个方法也很不科学） 用Flux管理状态 state里应该有什么应该有啥： 事件函数可能进行修改的会导致UI进行渲染的数据 不应该有啥： 计算得出的值 React组件 props复制来的数据 如何对组件进行优化 使用上线构建（Production Build）：会移除脚本中不必要的报错和警告，减少文件体积 避免重绘：重写shouldComponentUpdate函数，手动控制是否应该调用render函数进行重绘 尽可能使用Immutable Data：尽可能不修改数据，而是重新赋值数据。这样在检测数据对象是否发生修改方面会非常快，因为只需要检测对象引用即可，不需要挨个检测对象属性的更改 在渲染组件时尽可能添加key，这样virtual DOM在对比的时候就更容易知道哪里是修改元素，哪里是新插入的元素 组件中的key属性有什么用React中的key是一个特殊的属性，它的出现不是给开发者用的，而是给React自己用的（给一个组件设置了key属性，并不能获取这个组件的key props） React使用key来识别组件，它是一种身份标识，每一个key对应一个组件，react认为相同的key是同一个组件，这样后续相同的key就不会被创建 有了key属性后，就可以与组件建立一种对应关系，react根据key来决定是销毁重新创建组件还是更新组件： key相同：若组件属性有变化，react只更新对应的属性；没有变化则不更新 key值不同：react会先销毁该组件，然后重新创建该组件 Component与Element和Instance的区别 Element其实是一个纯粹的Object对象，用于描述在屏幕上看到的DOM节点，这个对象包括type、props、key和ref属性，但不包括DOM方法（React.createElement()） Component是组件级别的类：接收参数并返回React元素的函数或类 Instance：当使用ReactDOM.render()将一个组件渲染到一个具体的DOM元素中，返回的值就为一个实例 调用setState时，发生了什么事调用setState时，react会做的第一件事就是将传递给setState的对象合并到组件的当前状态，然后会触发调和过程。经过调和过程，React会以相对高效的方式根据新的状态构建React元素树，并准备重新渲染整个UI界面。在React得到元素树后，React会通过diff算法算出新的树与老树之间的节点差异，然后根据差异对界面进行最小化重渲染。在diff算法中，React能够相对精确地算出哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。 什么时候使用类组件（Class Component）而非功能组件（Functional Component）若组件需要有state或需要使用生命周期，就用类组件，否则就用功能组件 什么是React的refs，为什么它们很重要我们用render方法得到了组价的实例，然后就可以对它进行相关操作，但是在组件内，JSX是不会返回一个组件的实例，它只是一个ReactElement，只是告诉React被挂载的组件应该是长什么样。 refs是组件的一个很特殊的prop，可以附加到任何一个组件上，refs就是reference，组件被调用时会新建一个该组件的实例，refs就会指向这个实例 我们把refs放到原生的DOM组件input中，就可以通过refs得到DOM结点；如果把refs放到React组件中，就可以获得组件的实例，可以调用该组件的实例方法 受控组件（controlled component）和不受控组件（uncontrolled component）有什么区别受控组件：在HTML中，标签\、\等值的改变通常是根据用户输入进行更新，在React中，可变状态通常保存在组件的状态属性中，并且只能用setState()更新，而呈现表单的React组件也控制着在后续用户输入时该表单发生的情况，以这种由React控制输入表单元素而改变其值的方式，就称为“受控组件” 不受控组件：表单数据不受setState控制，而是由DOM本身处理，与传统HTML表单输入相似，input输入值即显示最新值（使用ref从DOM获取表单值） 描述事件在React中的处理方式React在virtual DOM的基础上实现了一个SyntheticEvent（合成事件）层，所有事件都绑定到最外层上。 在React底层，主要对合成事件做了两件事：事件委托和自动绑定。 事件委托：React的事件代理机制不会把事件处理函数直接绑定到真实的结点上，而是把所有事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。 自动绑定：在React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。在使用ES6 classes和纯函数时，这种自动绑定就不存在了，需要我们手动绑定this：bind方法、双冒号语法、构造器内声明、箭头函数。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美团实习生面试(一面)]]></title>
    <url>%2F2017%2F07%2F29%2F%E7%BE%8E%E5%9B%A2%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[JS 平常用JS做什么 平常写项目用ES6吗，用什么比较多 箭头函数和普通函数有什么区别 用原生JS写一个删除元素的函数 浅克隆和深克隆，用原生JS写一个clone函数 动态添加和删除一条消息要怎么用JS实现 cookie是什么，怎么设cookie，前端可以修改cookie吗，cookie的安全性 localStorage和sessionStorage CSS 你用过的display属性值，讲讲block，inline，inline-block的差别 讲讲几种position属性值 什么选择器用得比较多 用CSS写过什么有趣或炫酷的东西 网络 网络7层协议，数据是怎么传输的 http协议是哪一层的 http协议有哪些header http请求方法，get和post的使用场景，post和put的本质区别 http返回码，什么时候返回200，什么时候返回500，201表示什么 React React生命周期 在哪几个生命周期里可以使用setState 有没有function的方式写过组件 异步请求一般在哪个生命周期 谈一下你怎么理解render的触发 refs用来干什么 react如何实现事件委托 redux的流程 用过哪些redux中间件，中间件实现原理，有没有自己写过中间件 用redux时遇到过什么坑 其他 为什么要用mongodb MySQL有办法存json数据吗 编程题123456789// 有一个数组arr代表外卖的价格，比如[1, 2, 2.5, 30, 25]，用户现在有购物车已经买了N元了，需要凑到&gt;=M元，求给出一个最佳凑单组合// [1,2,3] 20 25 [2,3] [1, 1, 1, 1, 1] [1,1,3]// [1,2,3] 19.5 20 [1]function func(itemPrice, N, M) &#123; let items = []; ... return items;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express+MongoDB搭建多人博客系统]]></title>
    <url>%2F2017%2F07%2F25%2FExpress%2BMongoDB%E6%90%AD%E5%BB%BA%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[项目地址 目前还是bug多多~ 本项目完全该教程，教程很详细很入门很通俗，本文是纯为面试准备的啦。 开发环境 Node.js: 6.11.0 Express: 4.15.3 MongoDB: 3.4 ExpressExpress的基本使用方法可以查看其使用指南。 路由本项目使用的是express.Router。 创建一个routes的文件夹，将路由控制都写在该文件夹内，每个路由文件通过生成一个express.Router实例router并导出，通过app.use挂载到不同的路径。 模板引擎本项目模板引擎使用的是ejs。 1234//设置模板目录app.set('views', path.join(__dirname, 'views'));//设置模板引擎为ejsapp.set('view engine', 'ejs'); 通过调用res.render()渲染ejs模板，第一个参数是模板的名字，第二个参数传给模板的数据。 123res.render('error',&#123; error: err&#125;); res.render()的作用就是将模板和数据结合成HTML，同时响应头中的Content-Type：text/html，告诉浏览器返回的是HTML，不是文本，要按HTML展示。 中间件 express-session：实现对会话的支持 由于HTTP协议是无状态协议，所以服务器需要记录用户的状态时，需要用某种机制来识别具体的用户，这个机制就是会话（session）。 本项目中session配置： 123456789101112app.use(session(&#123; name: config.session.key, //设置cookie中保存session id的字段名称 secret: config.session.secret, resave: true, //强制更新session saveUninitialized: false, //设置为false，强制创建一个session，即使用户未登录 cookie: &#123; maxAge: config.session.maxAge &#125;, store: new MongoStore(&#123; url: config.mongodb &#125;)&#125;)); session中间件会在req上设置session对象，及req.session={}，当用户登录后设置req.session.user=用户信息，返回浏览器的头信息中会带上set-cookie，将session id写到浏览器cookie中，所以用户下次请求时，通过带上来的cookie中的session id就能查找到该用户，并将用户信息保存早req.session.user。 session资料： http://justsee.iteye.com/blog/1570652 https://www.zhihu.com/question/19786827 connect-mongo：将session存入到mongodb中 作用就是将connect的session持久化到mongodb中，配置见上面的session配置。 connect-flash：通知功能 1app.use(flash()); 原理：设置初始值req.session.flash={}，通过req.flash(name, value)设置flash字段和值，通过req.flash(name)获取该对象下的值，同时删除该字段。 express-formidable：处理表单及文件上传 1234app.use(require('express-formidable')(&#123; uploadDir: path.join(__dirname, 'public/img'), //上传文件目录 keepExtensions: true //保留后缀&#125;)); 获取文件： 1var avatar = req.files.avatar.path.split(path.sep).pop(); config-lite：读取配置文件 config-lite会根据环境变量（NODE_ENV）的不同从当前执行进程目录下的config目录加载不同的配置文件。如果不设置NODE_ENV，则读取默认的default配置文件，若指定了NODE_ENV，则会合并指定的配置文件和default配置文件作为配置。config-lite支持.js、.json、.node、.yml、.yaml后缀的文件。 如果程序以 NODE_ENV=test node app 启动，则 config-lite 会依次降级查找 config/test.js、config/test.json、config/test.node、config/test.yml、config/test.yaml 并合并 default 配置; 如果程序以 NODE_ENV=production node app 启动，则 config-lite 会依次降级查找 config/production.js、config/production.json、config/production.node、config/production.yml、config/production.yaml 并合并 default 配置。 winston和express-winston：记录日志 1234567891011121314151617181920212223242526//正常请求的日志app.use(expressWinston.logger(&#123; transports: [ new (winston.transports.Console)(&#123; json: true, colorize: true &#125;), new winston.transports.File(&#123; filename: 'logs/success.log' &#125;) ]&#125;));//路由routes(app);//错误请求的日志app.use(expressWinston.errorLogger(&#123; transports: [ new winston.transports.Console(&#123; json: true, colorize: true &#125;), new winston.transports.File(&#123; filename: 'logs/error.log' &#125;) ]&#125;)); 将正常请求的日志打印到终端并写入logs/success.log，将错误请求的日志打印到终端并写入logs/error.log。 注：记录正常请求日志的中间件要放到routes(app)之前，记录错误请求日志的中间件要放到routes(app)之后 功能目前只实现了最最基本的功能，即登录注册登出、查看文章发表文章修改文章删除文章、创建留言删除留言。以及会话、消息通知、权限控制。会话及消息通知用的第三方中间件，权限控制为自定义中间件。 权限控制（主要是验证用户是否登录）： 12345678910111213141516module.exports = &#123; checkLogin: function checkLogin(req, res, next) &#123; if(!req.session.user)&#123; req.flash('error','未登录'); return res.redirect('/signin'); &#125; next(); &#125;, checkNotLogin: function checkNotLogin(req, res, next) &#123; if(req.session.user)&#123; req.flash('error','已登录'); return res.redirect('back'); //返回之前的页面 &#125; next(); &#125;&#125;; MongoDBmodel项目中目前只有三个model，分别为User、Post及Comment]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题（二）]]></title>
    <url>%2F2017%2F07%2F20%2F%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CSS单位有哪些，简述其计算方法尺寸单位： 相对长度单位：em、ex、px em：相对于当前对象内文本的字体尺寸，1em等于当前字体尺寸 ex：相对于字符”x”的高度，通常为字体尺寸的一半，1ex等于当前字体的x-height px：像素，相对于显示器屏幕分辨率而言 %：百分比 绝对长度单位：in、cm、mm、pt、pc in：英寸 cm：厘米 mm：毫米 pt：磅，1pt=1/72in pc：12点活字，1pc=12px px：像素（计算机屏幕上的一个点） 不太常见的单位：rem、vh和vw、vmin和vmax rem：rem中的”r“代表”root“，等同于font-size基于根元素进行设置，在大多数情况下根元素为html元素 vh：viewport高度的1/100 vw：viewport宽度的1/100 vmin：视口高度及宽度中最小值的1/100 vmax：视口高度及宽度中最大值的1/100 颜色单位： 颜色名：如red rgb(x, x, x)：RGB值 rgb(x%, x%, x%)：RGB百分比值 `#rrggbb：十六进制数(\#ff0000`) 参考： http://www.w3school.com.cn/cssref/css_units.asp http://www.w3cplus.com/css/7-css-units-you-might-not-know-about.html CSS优先顺序层叠样式顺序： 浏览器默认样式 &lt; 浏览器用户自定义样式 &lt; 外部样式表 &lt; 内部样式表 &lt; 内联样式表 样式表内部选择器： 类选择器 &lt; 类派生选择器 &lt; id选择器 &lt; id派生选择器 生效规则： 样式表的元素选择器选择越精确，其中的样式优先级越高 id选择器指定的样式 &gt; 类选择器指定的样式 &gt; 元素类型选择器指定的样式 对于相同类型选择器指定的样式，在样式表文件中，越靠后的优先级越高 一个元素同时应用多个class，后定义的优先（就近原则） 如果要让某个样式的优先级变高，可以使用!important来指定 简述CSS单位rem，以及rem适合使用的场景rem是相对于HTML根元素的字体大小的单位 适用于响应式布局，每个元素的高宽、文字大小、行距、补白等一切可以使用长度单位的地方都可以用rem 画出一个内半径为10px，外边框白色1px的纯红色圆圈12345678.circle &#123; width: 20px; height: 20px; border: 1px solid white; border-radius: 50%; background-color: red; background-clip: padding-box&#125; 感觉比较重要的两个属性是border-radius和background-clip 举出三个行内元素和块级元素行内元素：a、span、strong、em、br、img、input、select、label、textarea、cite 块级元素：div、form、hr、h1-h6、p、ul、li、ol、fieldset、menu、table]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题（一）]]></title>
    <url>%2F2017%2F07%2F17%2F%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[new操作符做了哪些事new操作符接收一个函数F和参数：new F(arguments…)，它做了简单的三个步骤： 创建这个类的实例instance：将实例的__proto__设为F.prototype 初始化实例：调用函数F并将this指向该实例 判断F的返回值： 若为值类型，就丢弃它，返回该实例instance 若为引用类型，就返回这个引用类型的对象，替换掉instance 代码实现： 1234567function New(f) &#123; var n = &#123;'__proto__': f.prototype&#125;; return function() &#123; f.apply(n, arguments); return n; &#125;&#125; 注： 若函数F没有写return，相当于return undefined，JS中undefined是值类型，因此返回instance 若return this相当于返回一个引用类型的对象，这个对象就是instance，所以无所谓替换不替换 参考：http://blog.vjeux.com/2011/javascript/how-prototypal-inheritance-really-works.html JS怎么判断变量的类型判断JS中数据类型有以下几种方法：typeof、instanceof、constructor、prototype、$.type()/jquery.type() 先举几个例子啊： 123456var a = "iamstring.";var b = 222;var c= [1,2,3];var d = new Date();var e = function()&#123;alert(111);&#125;;var f = function()&#123;this.name="22";&#125;; typeof（最常见） 123456alert(typeof a) ------------&gt; stringalert(typeof b) ------------&gt; numberalert(typeof c) ------------&gt; objectalert(typeof d) ------------&gt; objectalert(typeof e) ------------&gt; functionalert(typeof f) ------------&gt; function 注：typeof在判断除Object类型的对象时比较方便。 instanceof（判断已知对象类型） 1234alert(c instanceof Array) ---------------&gt; truealert(d instanceof Date) ----------------&gt; truealert(f instanceof Function) ------------&gt; truealert(f instanceof function) ------------&gt; false 注：instanceof后面一定是对象类型，该方法适合一些条件选择或分支。 constructor（根据对象的constructor判断） 123alert(c.constructor === Array) ----------&gt; truealert(d.constructor === Date) -----------&gt; truealert(e.constructor === Function) -------&gt; true 注：constructor在类继承时可能会出错 eg: 123456function A()&#123;&#125;;function B()&#123;&#125;;A.prototype = new B(); //A继承自B(原型链继承)var aObj = new A();alert(aobj.constructor === B) -----------&gt; true;alert(aobj.constructor === A) -----------&gt; false; 而instanceof不会出现该问题，对象直接继承和间接继承都是true: 12alert(aobj instanceof A) ----------------&gt; true;alert(aobj instanceof B) ----------------&gt; true; 要解决这个问题，一般是将对象的constructor手动指向自己： 123aobj.constructor = A; //将自己的类赋值给对象的constructor属性alert(aobj.constructor === A) -----------&gt; true;alert(aobj.constructor === B) -----------&gt; false; //基类不会报true了; 所以一般继承的严格写法应该是寄生组合继承（不懂就看这里） prototype（通用但繁琐） 123456alert(Object.prototype.toString.call(a) === ‘[object String]') -------&gt; true;alert(Object.prototype.toString.call(b) === ‘[object Number]') -------&gt; true;alert(Object.prototype.toString.call(c) === ‘[object Array]') -------&gt; true;alert(Object.prototype.toString.call(d) === ‘[object Date]') -------&gt; true;alert(Object.prototype.toString.call(e) === ‘[object Function]') -------&gt; true;alert(Object.prototype.toString.call(f) === ‘[object Function]') -------&gt; true; 麻烦是麻烦了点，但是通用啊~ jquery.type()（万能啊） 如果对象是undefined或null，则返回相应的”undefined”或”null”： 1234jQuery.type( undefined ) === "undefined"jQuery.type() === "undefined"jQuery.type( window.notDefined ) === "undefined"jQuery.type( null ) === "null" 如果对象有一个内部的[[Class]]和一个浏览器的内置对象的[[Class]]相同，会返回相应的[[Class]]名字: 12345678jQuery.type( true ) === "boolean"jQuery.type( 3 ) === "number"jQuery.type( "test" ) === "string"jQuery.type( function()&#123;&#125; ) === "function"jQuery.type( [] ) === "array"jQuery.type( new Date() ) === "date"jQuery.type( new Error() ) === "error" // as of jQuery 1.9jQuery.type( /test/ ) === "regexp" 总结一下：一般用typeof就OK了，如果预知Object类型的话可以选用instanceof或constructor，实在没辙就用$.type()好了。 ​ apply和call是干什么用的？有啥区别？ JS中通过call和apply来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为thisObj指定的新对象。简单说就是改变函数执行的上下文，换句话说，就是改变函数体内部this的指向。 call和apply的作用完全一样，只是接收参数的方式不太一样： call(obj, arg1, arg2, arg3); call第一个参数传对象，可以是null，参数以逗号分开进行传值，参数可以是任何类型。 apply(obj, [arg1, arg2, arg3]); apply第一个参数传对象，参数可以是数组或arguments对象 具体用法： “劫持”别人的方法： 12345678910var foo = &#123; name:"mingming", logName:function()&#123; console.log(this.name); &#125;&#125;var bar=&#123; name:"xiaowang"&#125;;foo.logName.call(bar);//xiaowang 此时foo中的logName方法被bar引用，this指向了bar 实现继承 12345678910111213function Animal(name)&#123; this.name = name; this.showName = function()&#123; console.log(this.name); &#125; &#125; function Cat(name)&#123; Animal.call(this, name); &#125; var cat = new Cat("Black Cat"); cat.showName(); //Black Cat 借用构造函数继承时，需要用到call方法 ​ 两个数组去重，将去重后的数据放到新的数组中1234567891011121314151617//做比较的两个数组var array1 = ['a','b','c','d','e'];//数组1var array2 = ['d','f','e','a','p'];//数组2//临时数组存放var tempArray1 = [];//临时数组1var tempArray2 = [];//临时数组2for(var i=0;i&lt;array2.length;i++)&#123; tempArray1[array2[i]]=true;//将数array2 中的元素值作为tempArray1 中的键，值为true；&#125;for(var i=0;i&lt;array1.length;i++)&#123; if(!tempArray1[array1[i]])&#123; tempArray2.push(array1[i]);//过滤array1 中与array2 相同的元素； &#125;&#125; 还有种比较蠢且有限制的方法，也贴出来好了： 1234567891011mergeArray:function (arr1, arr2)&#123; for (var i = 0 ; i &lt; arr1.length ; i ++ )&#123; for(var j = 0 ; j &lt; arr2.length ; j ++ )&#123; if (arr1[i] === arr2[j])&#123; arr1.splice(i,1); //利用splice函数删除元素，从第i个位置，截取长度为1的元素 &#125; &#125; &#125; var newArr = arr1.contact(arr2); return newArr;&#125; 顺便贴一下一个数组的去重吧，有好几种方式： 遍历数组：新建一个新数组，遍历传入的数组，若值不在新数组就加入到新数组中 12345678910111213// 最简单数组去重法 function unique1(array)&#123; var n = []; //一个新的临时数组 //遍历当前数组 for(var i = 0; i &lt; array.length; i++)&#123; //如果当前数组的第i已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if (n.indexOf(array[i]) == -1) &#123; n.push(array[i]); &#125; &#125; return n; &#125; hashtable结构：用hashtable结构记录已有元素 12345678910function unique(arr) &#123; var result = [], hash = &#123;&#125;; for (var i = 0, elem; (elem = arr[i]) != null; i++) &#123; if (!hash[elem]) &#123; result.push(elem); hash[elem] = true; &#125; &#125; return result;&#125; ES6的方法 123456789// ES6function unique (arr) &#123; const seen = new Map() return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))&#125;// orfunction unique (arr) &#123; return Array.from(new Set(arr))&#125; ​]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不要做个懂事的孩子]]></title>
    <url>%2F2017%2F06%2F14%2F%E4%BD%A0%E4%B8%8D%E8%A6%81%E5%81%9A%E4%B8%AA%E6%87%82%E4%BA%8B%E7%9A%84%E5%AD%A9%E5%AD%90%2F</url>
    <content type="text"><![CDATA[“哎呀，还好有个懂事争气的女儿”，老爸心情不好的时候很喜欢讲这句话。 “我可能再也遇不到你这么好的女孩儿了”，分手的时候他这么说。 “我以后一定要找个珊珊这样子的男票！”，藜爷总爱捧着脸看着我憧憬。 以前我以为这是夸赞，夸我懂事乖巧善解人意，我以此自豪为此骄傲。但现在，我却因此略感无奈心疼。 无奈为什么自己要这么懂事，心疼自己懂事了二十多年。 “生你的时候，家里生意亏本，你妈因为营养不良没有母乳，我们想着可不能亏待你啊，就狠狠心买了高级奶粉，你这个娃啊，不爱喝奶粉，就爱吃那种便宜的米糊。”这个故事，我爸都给我讲了半辈子了。现在每次提到这个梗，我都会故意开玩笑说，“你看看你们多幸运，有个如此懂事的女儿，一生下来就知道给你们省钱。”可是，心里却有一丝丝难过。 今天上班车上突然开始思考，以后要是有孩子了，我要把他调教得很懂事。然而三秒后，我就打了个寒颤，no no no，以后我的孩子可不能太懂事了。 其实家长还是比较喜欢懂事的孩子呀，谁不希望自己的孩子听话懂事自立自强少让自己操心。但是讲真，你想过为啥他们会懂事吗？ 你还记得《无声告白》里的乖乖女莉迪亚吗？从五岁开始就决定成为一个乖乖女，继承母亲当医生的梦想，承载父亲融入人群的期望。任何时候母亲拿来习题册问她要不要学习，她的回答都是“好的，妈妈”。为了让父亲觉得她有很多亲密的朋友，每天晚上坐在楼梯口打电话，而其实电话那头并没有人，一直都是她在自言自语。莉迪亚是家里三个孩子中最受宠的，爸爸妈妈甚至把所有的爱都给了她，她想要什么都给她买，当然，她想要的并不是自己真正想要的，而是爸妈想要的。多么懂事啊，从来不让爸妈操心担心，可就是这么一个懂事的姑娘，最后却沉没在家门口的湖水中。她太懂事了，懂事到只知道爸妈想要什么而不清楚自己想要什么，懂事到压抑到抑郁也几乎未表现出任何不满。在她16岁那天，她突然想通了，为爸妈活了十多年，是该为自己而活了，是该成为自己想成为的人了。可是她却意外落水了。 你知道她为什么突然变得懂事吗？因为害怕失去。母亲的一次长达两个月的离家出走，让她幼小的心灵有了无穷的阴影，她再也不希望母亲离开她了，她会做任何事情，只要父母开心。真悲哀。 我第一次看到我爸哭，是把弟弟送去文武学校那天。我记得很清楚，老爸在给我们做晚饭，切菜时我总觉得他在擦眼泪，可是我不信啊，二十年来我从未见过老爸流眼泪，那一定是假象。可是后来他甚至开始啜泣，肩膀开始一抖一抖。他说他不放心弟弟，很担心很不舍。他的这份担心也感染了我和老妈，结果就是吃饭的时候三个人都默不作声，只是红着眼哽咽。 后来回忆这件事的时候，我发现当时除了担心和不舍，我还有另一种感觉–嫉妒。对，就是嫉妒。我嫉妒弟弟能赢得爸妈的担心与不舍，而我因为从来都太懂事，他们已经习惯了我的独立。 那是我第一次想要犯个事儿，想让爸妈痛扁我一顿，担心我一次。可是我不会，因为我怕他们会对我失望。 我记得有一次约会，回来的时候哭成了泪人儿，藜爷跟我说，分手吧，看你这么懂事我都心疼。那天我突然意识到，原来不仅仅是长辈觉得我懂事啊。 可是懂事并不能换来什么，你会活得唯唯诺诺患得患失精疲力竭，你会害怕失望害怕失去害怕别人对你评价不好，你会活在别人的期望里活在别人对你的印象中。 你可以让所有人都不讨厌你，做个隐形人便好，但是你不可能让所有人都喜欢你。你的一言一行一举一动，总有人会喜欢，也总有人会不喜欢。那又怎么样呢？做自己想做的事，成为自己想成为的人，表达自己想表达的观点，不去顾虑别人是否喜欢是否在意是否因此看不起你，做最真实最自由的自己，这难道不是一件幸福的事吗？ 很多挚友说我变了，从以前那个文文静静唯命是从的小女生变成了敢想敢说有主见的自由灵魂了。我的境界还太低，所以我会很高兴听到这种评价。等真的做到只做自己的时候，才能在听到这种评价时仅是莞尔一笑。 开心是真的，做自己很开心。不用那么为别人考虑，多爱自己一点很开心。 所以啊，以后我要是有孩子，我肯定不舍得ta变得那么懂事，我希望ta有自己的想法，开开心心做自己就好了。 我会跟我的孩子说，你要做个善良的孩子，但是一定不会跟ta说，你要做个懂事的孩子。 以上。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不吹不黑聊聊前端框架 - 尤雨溪 - 知乎live笔记]]></title>
    <url>%2F2017%2F06%2F06%2F%E4%B8%8D%E5%90%B9%E4%B8%8D%E9%BB%91%E8%81%8A%E8%81%8A%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%20-%20%E5%B0%A4%E9%9B%A8%E6%BA%AA%20-%20%E7%9F%A5%E4%B9%8Elive%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[尤大大的live购买地址 尤大大原话：这次 Live 会从尽可能客观的角度分析现代前端框架所涉及的各个问题领域，各领域目前的主流解决方案，以及未来可能的趋势。 组件组件类型 纯展示型：数据进，DOM出 接入型：如container，将数据往下传给展示型组件 交互型：如对表单组件的封装和加强（交互逻辑复杂但通用，强调复用） 功能型：如&lt;route-view&gt;，不渲染任何内容，作为一种扩展、抽象机制 模板 VS. JSX JSX最大的优势是灵活性，因为它就是JavaScript的语法糖，获得了JavaScript语言的完全灵活度，其最大的价值体现在书写功能型组件，这点远超模板 模板在书写纯展示型组件时更爽，它会强制将尽可能少的逻辑放在视图结构中，虽然展示型组件逻辑少，但是样式比较复杂，这样更容易用一种视图化的方式去思考 Colocation 意思就是该放在一起的东西就放在一起 传统的Seperate Concerns是以语言为切分，组件以组件本身作为切分抽象 变化侦测和渲染机制渲染机制 渲染最重要的是声明式（Declarative） 声明式与命令式比较： 命令式：就是干，直接，爽，但是维护性不好 声明式：直接描述数据跟DOM的映射关系，不需要手动做这些操作 view = render(state)：输入state，输出DOM，不去顾虑输入到输出发生了什么事情（可用Virtual DOM或细粒度绑定） 变化侦测 巴黎演讲PPT 主要分push和pull，本质是用侦测成本换一定程度的自动优化 pull：如React的setState、Angular的脏检查。系统需要一个信号，告诉它数据可能变了，然后系统才去进行暴力比对，如React的Virtual DOM的diff、Angular中整个脏检查的流程 push：如Vue的响应式数据、RxJS的observable。数据变动之后，我们立刻就知道数据变了，且一定程度上知道哪些数据变了，这样可以进行相对更细粒度的更新 pull的更新是最粗粒度的，所以在大型项目中需要帮助系统减少一些无用功。如React的PureComponent或shouldComponentUpdate，可以跳过一部分来减少暴力比对 push时信息更多，可以做耕细粒度的更新，但是有一定的代价（粒度越细，每一个绑定需要有一个对应的Observable或Watcher，这会带来内存及依赖追踪的开销） Vue2采取折中的方式：每个组件是一个Watcher，组件内部用Virtual DOM进行比对，组件级别为push 状态管理 本质：从源事件（source event）映射到事件的迁移，映射到状态的改变，再映射到UI的变化 声明式渲染已经解决了状态的变化到UI的变化之间的映射，所以状态管理这些库主要管理将事件源映射到状态变化的过程，并将映射的过程从视图组件中剥离出来，提高可维护性 状态管理库：Flux、Redux、MobX、Vuex Redux和MobX是两种截然不同的思维方式（paradise）： Redux：数据不可变（immutable），函数式，reducer中是纯函数，拿到preState和action返回一个新的state（把Vue当redux用） Mobx：数据可变，但数据是响应式的，前提是已经在数据上做好了声明式的副作用的声明（把Vue当MobX用） 这些方案都没回答如何处理异步（Redux将其交给middleWare，MobX和VueX让用户自己在action里想干嘛干嘛） 状态的改变：在传统的管理机制中需要将其写出来，如Redux中有reducer，Vuex中有mutation，但RxJS可以没有这一步，一切状态直接从事件源映射到想要的结果，一切都用RxJS流来表示（Cycle.js，从头到尾都是一个流） 状态管理方案所面临的问题： 组件的局部状态和全局状态如何区分（Elm对这个问题没那么明显） 全局状态和服务端数据之间的问题 路由 路由是只有大型的单页应用（SPA）才会遇到的问题 最早在前端有路由这个概念的是Ember，比较早的一个专门针对单页应用的框架，很重，侵入性比较强 从组件出发去思考路由，本质上就变成了一个把URL映射到组件树结构的一个过程 URL到组件的映射有个分歧：是从URL出发还是以状态出发（尤大大觉得本质是一样的，URL就是一个序列化的状态，可以把它当做一个状态） 最最最简单的路由就是一个动态组件，Vue可以用\\，React可以用一个对象表（一个key对应一个组件） 路由涉及很多其他的问题：hash模式和history模式如何兼容如何互相fallback、重定向、叠名、懒加载、路由之间的跳转（需要提供各种钩子，钩子里面又需要有异步操作） 最新的React-Router4推崇的是一种用组件本身来做路由的思路（利用功能型组件），可以在父组件里用Router组件来声明式渲染其他组件，它与其他Router的区别是去中心化的（不是将整个表写在一个地方，而是分散地写在各个组件里），这样灵活性比较好，但是对跳转的管理比较弱 Web路由跟App路由的区别 目前Web路由整体思路都是将URL映射到组件树，但是这个映射是2D的（比如从一个URL跳转到另一个URL，就是将新的URL push到历史的stack中，但stack中前一个位置对应的界面状态被丢弃了，从一个状态迁移到另一个状态整个应用界面就迁移到另一个状态了） 原生的应用比较像一叠卡片，它是新的界面盖在现有界面，是叠加的，退回去时只是把当前的卡片拿到，之前的卡片就会出现，就有点3D的赶脚 Web的路由方案在做移动应用时比较别扭，Ionic专门针对App的路由方案，但是它比较imperative，不够声明式 CSS方案主流的CSS方案 跟JS完全解耦，靠预处理器和如BEM这样的规范来保持可维护性，偏传统 CSS Modules，依然是CSS，但是通过编译来避免CSS类名的全局冲突 各类CSS-in-JS方案，React社区为代表，比较激进 Vue的单文件组件CSS，或Angular的组件CSS（写在装饰器里面），一种比较折中的方案 CSS-in-JS的价值（根据这篇文章） 组件CSS的作用域问题：CSS modules、inline-style、Vue的单文件组件里直接加scoped Critical CSS：在服务端渲染时需要侦测到渲染时要用到哪些CSS，CSS-in-JS实现起来比较简单，因为有运行时。（尤大大：Vue2.3也带这种功能，单文件组件里有个编译的功能，可以把CSS的插入和组件的生命周期挂钩） Atomic CSS：CSS-in-JS中有个方案自带atomic CSS优化，用它写CSS-in-JS时，产出的类名自动是原子类（尤大大：通过静态编译也可以完成，不一定非要用CSS-in-JS） 分发复用：CSS-in-JS都是JS，所以可以跟JS一样可以直接发包到npm上复用。（尤大大：webpack也可以直接引用npm包里的CSS，所以这不是完全的优势。） 跨平台复用：因为它放在JS里，所以可以实现。（尤大大：可以把静态的CSS pass之后编译成JS，来实现跨平台复用，Weex就是这么做的） 尤大大个人对CSS-in-JS持保留态度，尽管它有很多有意思的想法，但是本质上没有什么点要求必须把CSS写在JS里才能做，很多事情用静态的CSS进行编译时的分析和优化反而更简单 构建工具 前端Web平台能力越来越强，业务上对前端的要求越来越高，需求越来越复杂。面对复杂度不一样的任务，需要的工具的复杂度自然也不一样。所谓磨刀不误砍柴工，构建工具就是磨刀。 解决的问题 任务的自动化 开发体验和效率（新的语言功能，语法糖，hot reload等） 部署相关的需求 编译时优化 开发体验 不可避免想用些浏览器还没有支持的功能，但是对最终代码运行的环境没有控制器，所以我们只能从构建去下功夫 前端的构建工具链已经很完善了，HTML、CSS、JavaScript都有很完善的开源编译工具链 想自己打造前端的编译工具时，不需要做手动去pass、再做成AST（语法树），只要写转换的规则 预处理器（有人持反对态度）已经普及了，因为它们的使用成本很低，所以其带来了高的开发效率 部署 张云龙的回答 部署优化的注意点： 请求的合并（打包） 模板里JS用到的静态资源路径的映射（小资源用内联） 不同的资源在发新版时如何确保缓存 如何代码分割 webpack配置比较复杂，那是因为它要解决的问题比较复杂，但是第一次配置完后获得的收益很大，“一劳永逸” 服务端数据通信 传统做法是围绕Rest，若服务端暴露一个标准的Rest Api，客户端可以直接拿fetch去抓，或围绕Rest做一个资源的抽象，这个比较适用于于传统的CRUD的应用 实时数据的解决方案 Meteor Firebase：单纯做数据层 RethinkDB出了个开源实时方案–Horizon 在客户端很适合用RxJS，因为它最合适用来处理事件流 数据关联问题的解决方案 GraphQL：暴露一个接口，可以像基于graph的查询语言进行查询 对于有复杂关联的数据的表达力比传统Rest强很多，且对数据量的优化更精确 如果只是单纯用fetch抓graph的接口很简单，但是会遇到query的优化、如何缓存已经抓取过的query等问题，所以大部分情况下需要客户端 目前主流的GraphQL的客户端抽象：Relay 、Apollo Client GraphQL门槛比较高，对服务端的要求比较高，而且得考虑应用是否复杂到了需要GraphQL的程度 Vue的服务端渲染指南 跨平台渲染 从前端框架角度看，跨平台渲染本质是：在设计框架时，让框架的渲染机制跟DOM解耦，不一定使用Virtual DOM实现，本质上只需要把框架更新时节点操作封装起来便可做到跨平台。 一个原生的渲染引擎，比如 React Native 和 Weex 本质都是在底层针对每个平台有一个适配的渲染引擎，只要把渲染引擎暴露的结点操作的 API，跟框架的运行时对接一下，就可以实现将框架里面的代码渲染到原生的目的。这里的解耦很清晰，这也是为什么 NG 可以接 React Native，Weex 可以跑 Vue 文件，Weex 可以跑在 NativeScript 上等等。 新规范： Web components：尤大大推荐的一个回答 Web Sembly：面向Web的通用二进制和文本格式，可以跑在浏览器里，但暂时还操作不了DOM 总结技术方案都是先有问题，再有思路，同时伴随着取舍。在选择衡量技术时，尽量去思考这个技术在背后是在解决什么问题，它做了怎样的取舍。这样一方面可以帮助我们更好的理解和使用这些技术，也为以后哪天你遇到业务中的特殊情况，需要自己做方案时打好基础。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6新特性--笔记（五）]]></title>
    <url>%2F2017%2F05%2F27%2FES6%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文完全参考 阮一峰的博客（ECMAScript 6 入门），只是简单的做个笔记。 Generator函数的语法 执行Generator函数会返回一个普通函数，Generator函数除了状态机，还是一个遍历器对象生成函数。 概述 形式上，Generator函数是一个普通函数，但是function关键字与函数名之间有一个*，且函数体内部使用yield表达式，定义不同的内部状态 Generator函数的调用方法与普通函数一样，但是调用后并不执行，返回的也不是函数运行结果，二是一个指向内部状态的指针对象 调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针，之后每次调用next方法就会返回一个对象，包括value和done两个属性，value是yield表达式后面的表达式的值，done表示是否遍历结束 yield表达式 Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所有提供了一种可以暂时执行的函数，yield表达式就是暂停标志 yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行 yield与return的区别： 每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能 一个函数里，只能执行一次return语句，但是可以执行多次yield表达式 正常函数只能返回一个值，因为只能执行一次return，但是Generator函数可以返回一系列的值，因为可以有任意多个yield Generator函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数 yield表达式只能用在Generator函数里，用在其他地方都会报错 yield表达式如果用在另一个表达式中，必须放在圆括号里面 由于Generator函数就是遍历器生成函数，因此可以把Generator赋给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口 Generator.prototype.throw() Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后再Generator函数体内捕获 如果Generator函数内部没有部署try...catch代码块，那么throw方法抛出的错误将被外部try...catch代码块捕获 throw方法被捕获之后，会附带执行一次next方法 如果Generator函数内部和外部都没有部署try...catch代码块，那么程序将报错，直接中断执行 只要Generator函数内部部署了try...catch代码块，那么遍历的throw方法抛出的错误，不影响下一次遍历 一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了 Generator函数的this Generator函数返回的是遍历器对象，而不是this对象 Generator函数不能跟new命令一起用，会报错，因为它不是构造函数 可以使用call绑定Generator函数内部的this来获取正常的this 1var f = F.call(F.prototype) 其他 yield表达式本身没有返回值，或者说总是返回undefined，next方法可以带一个参数，该参数就会被当做上一个yield表达式的返回值 for...of循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法 Generator.prototype.return()：可以返回给定的值，并终结遍历Generator函数 如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上*，表明它返回的是一个遍历器对象 如果被代理的Generator函数有return语句，那么可以向代理它的Generator函数返回数据 应用 异步操作的同步化表达：处理异步操作，改写回调函数 控制流管理 部署Iterator接口 作为数据结构：可以看作是一个数组结构，因为Generator函数可以返回一系列值，意味着它可以对任意表达式提供类似数组的接口 async 函数 async函数就是Generator函数的语法糖。 async函数返回一个Promise对象，可以使用then方法添加回调函数。 async函数内部return语句返回的值，会成为then方法回调函数的参数 async函数返回的Promise对象，必须等到内部所有await命令后面的Promise对象执行完，才会发生状态改变，除非遇到return语句或抛出错误（也就是，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数） 正常情况下，await命令后面是一个Promise对象，如果不是，会被转成一个立即resolve的Promise对象 只要一个await语句后面的Promise变为reject，那么整个async函数都会中断执行 防止出错的方法，将其放在try...catch代码块中 多个await命令后面的异步操作，若不存在继发关系，最好让它们同时触发 await命令只能用在async函数中，若用在普通函数就会报错 forEach方法的参数改成async函数，也可能出错，最好是用for循环 Class基本语法 ES6提供了更接近传统语言的的写法，引入了Class的概念，作为对象的模板。通过class关键字，可以定义类。 ES6的class可以看作一个语法糖，只是让对象原型的写法更加清晰、更像面对对象编程的语法 类的数据类型就是函数，类本身就指向构造函数 类的所有方法都定义在类的prototype属性上，在类的实例上调用方法，实际就是调用原型上的方法 类的内部所有定义的方法，都是不可枚举的 类的属性名，可以采用表达式 一个类必须有constructor方法，若没显式定义，则默认添加一个空的constructor，该方法默认返回实例对象（即this），完全可以指定返回另一个对象 类的构造函数不使用new无法调用，会报错 实例的属性除非显示定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上） 与ES5一样，类的所有实例共享一个原型对象 与ES5不同，Class不存在变量提升 与函数一样，类也可以使用表达式的形式定义 ES6不提供私有方法，可以通过变通方法模拟实现： 将私有方法移除模块，因为模块内部所有方法都是对外可见的 利用Symbol值的唯一性，将私有办法的名字命名为一个Symbol值 Class的继承 Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰方便得多 子类必须在constructor方法中调用super方法，否则新建实例时会报错，因为子类没有自己的this对象，而是继承父类的this对象 Class同时有prototype属性和__proto__属性，因此存在两条继承链： 子类的__proto__属性，表示构造函数的继承，总是指向父类 子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性 123456class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true ​ Object.getPropertyOf()可以用来从子类上获取父类（可以用其来判断一个类是否继承另一个类） ES6要求，子类的构造函数必须执行一次super函数 super作为对象时，在普通方法中，指向父类的原型对象（由于super指向父类的原型对象，所以定义在父类实例上的方法或属性是无法通过super调用的），在静态方法中，指向父类 子类的原型的原型，是父类的原型，所以通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为 原生构造函数的继承 ES5先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。 ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承 extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数 其它 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。若在一个方法前，加上static关键字，表示该方法不会被实例继承，而是直接通过类来调用。 父类的静态方法，可以被子类继承 静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性，ES6规定，Class内部只有静态方法，没有静态属性 ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数，若构造函数不是通过new命令调用的，new.target会返回undefined，因此该属性可以用来确定构造函数是怎么调用的]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6新特性--笔记（四）]]></title>
    <url>%2F2017%2F05%2F26%2FES6%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文完全参考 阮一峰的博客（ECMAScript 6 入门），只是简单的做个笔记。 Reflect Reflect对象与Proxy对象一样，是ES6为了操作对象而提供的新的API。 设计目的 将Object对象的一些明显属于语言内部的方法（如Object.defineProperty），放到Reflect对象上 修改某些Object方法的返回结果，让其变得更合理 让Object操作都变成函数行为 Reflect对象的方法与Proxy对象的方法一一对应，因此不管Proxy怎么修改默认行文，都能在Reflect上获取默认行为 静态方法Reflect对象共有13个静态方法： Reflect.apply(target, thisArg, args) Reflect.construct(target, args) Reflect.get(target, name, receiver) Reflect.set(target, name, value, receiver) Reflect.defineProperty(target, name, desc) Reflect.deleteProperty(target, name) Reflect.has(target, name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensible(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target)（若参数不是对象，不会将其转为对象，而是会报错） Reflect.setPrototypeOf(target, prototype) Promise对象 Promise简单说是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）结构。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。 概述 Promise对象代表一个异步操作，有pending、resolving和rejected三种状态，只有异步操作的结构可以决定当前是哪种状态，其他任何操作都无法改变这个状态。 Promise对象的状态改变只有两种可能：pending到resolving和pending到rejected，只要改变发生，状态就凝固了，不会再变了。 有了Promise操作，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。 Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。 resolve函数的作用是将Promise对象的状态由pending变为resolving，在异步操作成功时调用，并将异步操作的结果作为参数传递出去。 reject函数的作用是将Promise对象的状态由pending变为rejected，在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去。 Promise实例生成后，可以用then方法接受两个回调函数作为参数，分别为resolved和rejected状态的回调函数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数，reject函数的参数通常是Error对象的实例，resolve函数的参数除了正常值外，还可能是另一个Promise实例。 Promise相关方法 Promise.prototype.then()：为Promise实例添加状态改变时的回调函数 Promise.prototype.catch()：.then(null, rejection)的别名，用于指定发生错误时的回调函数 如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数处理该错误 如果Promise状态已经变成resolved，再抛出错误是无效的 Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获 建议总是使用catch方法而不使用then方法的第二个参数，这样可以捕获前面then方法执行中的错误 Promise.all()：用于将多个Promise实例，包装成一个新的Promise实例 1var p = Promise.all([p1, p2, p3]); 接收一个数组（或具有Iterator接口的数据结构）作为参数，其中所有成员都是Promise实例 若p1、p2、p3的状态都变成resolved，p的状态才会变成resolved，且p1、p2、p3的返回值组成一个数组，传递给p的回调函数 只要p1、p2、p3中有一个被rejected，p的状态就会变成rejected，此时第一个被rejected的实例的返回值，会传递给p的回调函数 Promise.race()：var p = Promise.race([p1, p2, p3]);只要实例中有一个实例率先改变状态，p的状态就跟着改变，率先改变的Promise实例的返回值，就传递给p的回调函数 Promise.resolve()：将现有对象转为Promise对象 Promise.reject()：返回一个新的Promise对象，该实例的状态为rejected Promise.prototype.done()：总是处于回调链的尾端，保证抛出任何可能出现的错误 Promise.prototype.finally()：不管Promise对象最后状态如何，都会执行的操作 Iterator Iterator是一种接口，为各种不同的数据结构提供统一的访问机制。 作用： 为各种数据结构，提供一个统一的、简便的访问接口； 使得数据结构的成员能够按照某种次序排列； ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费 ES6中，有些数据结构原生具备Iterator接口，即不用任何处理就可以被for...of循环遍历，因为这些数据结构原生部署了Symbol.iterator属性 一种数据结构只要部署了Iterator接口（只要具有Symbol.iterator属性），我们就称这种数据结构是“可遍历的” ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构，for...of循环会自动遍历它们 一个对象如果要有可被for...of循环调用的Iterator接口，就必须在Symbol.iterator的属性上部署遍历器生产方法（原型链上的对象具有该方法也可） 给类似数组的对象（存在数值键名和length属性）部署Iterator接口，可以Symbol.iterator方法直接引用数组的Iterator接口 1NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator]; 字符串是一个类似数组的对象，也原生具有Iterator接口 Symbol.iterator方法的最简单实现，是使用Generator函数 遍历器对象除了next方法，还可以具有return方法（必须返回一个对象）和throw方法 调用Iterator接口的场合 解构赋值：对数组和Set结构进行解构赋值时 扩展运算符（...）调用默认的iterator接口 yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口 由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口 for…of循环 ES6引入了for...of循环，作为遍历所有数据结构的统一方法。 for...of循环可以使用的范围包括数组、Set和Map结构，某些类似数组的对象（arguments对象，DOM NodeList对象）、Generator对象，以及字符串 for...in循环，只能获得对象的键名，不能直接获取键值，for...of循环，允许遍历获得键值 对于普通对象，for...in循环可以遍历键名，而for...of结构不能直接使用 for...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性 若要通过for...of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法 Set结构和Map结构的遍历顺序是按照各自成员被添加进数据结构的顺序 Set结构遍历时，返回的是一个值，Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值 不是所有类似数组的对象都具有Iterator接口，可以使用Array.from方法将其转为数组 与其他遍历语法的比较 最原始的for循环，写法比较麻烦 数组内置的forEach方法：无法中途跳出循环，break命令或return命令都不能奏效 for...in循环可以遍历数组的键名，但有几个缺点（主要是为遍历对象而设计的，不适用于数组）： 数组的键名是数字，但是for...in是以字符串作为键名“0”、“1”等 for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键 某些情况下，for...in循环会以任意顺序遍历键名 for...of循环的优点： 语法同for...in一样简洁，但是没有for...in那些缺点 它可以与break、continue和return配合使用 提供了遍历所有数据结构的统一操作接口]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6新特性--笔记（三）]]></title>
    <url>%2F2017%2F05%2F26%2FES6%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文完全参考 阮一峰的博客（ECMAScript 6 入门），只是简单的做个笔记。 Symbol Symbol是ES6中第七种原始数据类型，表示独一无二的值。 概述 Symbol可以接收一个字符串作为参数，表示对Symbol实例的描述 相同参数的symbol函数的返回值是不相等的 Symbol值不能与其他类型的值进行运算，会报错 Symbol值可以显示转为字符串、布尔值，但是不能转为数值 用途： 作为属性名：作为标识符，保证不会出现同名的属性 消除魔术字符串：降低耦合，利于维护 可以实现一种非私有的内部方法 模块的单例模式 Symbol作为属性名，该属性不会出现在for...in、for...of中， 也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回 Object.getOwnPropertySymbols返回一个数组，成员是当前对象的所有用作属性名的Symbol值 Reflect.ownKeys可以返回所有类型的键名，包括常规键名和Symbol键名 Symbol.for() Symbol.for()也会生成新的Symbol，它接收一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值，若有则返回该Symbol值，否则新建并返回一个以该字符串为名称的Symbol值 Symbol.keyfor返回一个已登记的Symbol类型值的key Symbol.for为Symbol登记的名字，是全局环境的，可以在不同iframe或service worker中取到同一值 内置的Symbol值* Symbol.hasInstance属性：指向一个内部方法，当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法 Symbol.isConcatSpreadable属性：一个布尔值，表示对象使用Array.prototype.concat()时，是否可以展开 Symbol.species属性：指向当前对象的构造函数，创建实例时，默认会调用这个方法，即使用这个属性返回的函数作为构造函数，来创造新的实例对象 Symbol.match属性：指向一个函数，当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值 Symbol.replace属性：指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值 Symbol.search属性：指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值 Symbol.split属性：指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值 Symbol.iterator属性：指向该对象的默认遍历器方法 Symbol.toPrimitive属性：指向一个方法，该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值 Symbol.toStringTag属性：可以用来定制[object object]或[object Array]中object后面那个字符串 Symbol.unscopables属性：指向一个对象，该对象指定了使用with关键字时，哪些属性会被with环境排除 Set和Map数据结构Set ES6提供了新的数据结构Set，它类似于数组，但是成员的值都是唯一的，没有重复值 set函数可以接收一个数组（或类数组对象）作为参数，用来初始化 向set加入值时不会发生类型转换，类似于（===），但是NaN等于自身 Set实例的属性： Set.prototype.constructor：构造函数，默认为Set函数 Set.prototype.size：返回Set实例的成员总数 Set实例的操作方法： add(value)：添加某个值，返回Set结构本身 delete(value)：删除某个值，返回一个布尔值，表示是否删除成功 has(value)：返回一个布尔值，表示该值是否为Set的成员 clear()：清除所有成员，没有返回值 Set实例的遍历方法（遍历顺序就是插入顺序）： keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 foreach()：使用回调函数遍历每个成员 数组的map和filter也可以用于Set 使用Set可以很容易实现并集、交集和差集 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; WeakSet WeakSet结构与Set类似，也是不重复的值的集合 WeakSet的成员只能是对象，不能是其他类型的值 WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，所有WeakSet不可遍历 WeakSet可以接收一个数组或类似数组的对象作为参数，该数组所有成员（只能是对象）都会自动成为WeakSet实例对象的成员 WeakSet可以用来存储Dom节点，不用担心这些节点从文档移除时会引发内存泄漏 Map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型（包括对象）的值都可以当作键。 任何具有Iterator接口的数据结构都可以当作Map构造函数的参数 若对同一个键多次赋值，后面的值将覆盖前面的值 Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键 Map实例的属性和操作方法： size属性：返回Map结构的成员总数 set(key,value)设置键名key对应的键值为value，然后返回整个Map结构 get(key)读取key对应的键值，如果找不到key，返回undefined has(key)返回一个布尔值，表示某个键是否在当前Map对象之中 delete(key)删除某个键，返回是否返回成功的布尔值 clear()清除所有成员，没有返回值 Map的遍历方法与Set一样，遍历顺序就是插入顺序 Map结构转为数组结构，比较快速的方法是使用扩展运算符(…) 结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法） 与其他数据结构互相转换： Map转为数组：使用扩展运算符(…) 数组转为Map：将数组传入Map构造函数 Map转为对象：若Map的键都是字符串，它可以转为对象 1234567function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125; 对象转为Map 1234567function objToStrMap(obj) &#123; let strMap = new Map(); for(let k of Object.keys(obj))&#123; strMap.set(k,obj[k]); &#125; return strMap;&#125; Map转为JSON：Map的键名都是字符串，可以转为对象JSON（JSON.stringify(strMapToObj(strMap))） Map转为JSON：Map的键名有非字符串，可以转为数组JSON（JSON.stringify([...map])） JSON转为Map：objToStrMap(JSON.parse(jsonStr)) WeakMap WeakMap只接受对象作为键名 WeakMap的键名所指向的对象不计入垃圾回收机制 如果想往对象上添加数据，又不想干扰垃圾回收机制，就可以使用WeakMap WeakMap只有四种方法：get()、set()、has()、delete() 用途： DOM节点作为键名 注册监听事件的listener对象，很适合用WeakMap实现 部署私有属性 Proxy 用于修改某些操作的默认行为，属于一种“元编程”，即对编程语言进行编程。可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种可以对外界的访问进行过滤和改写的机制。 Proxy.revocable()：返回一个可取消的Proxy实例。使用场景：目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问 Proxy支持的拦截操作 get(target, propKey, receiver)：拦截对象属性的读取 set(target, propKey, value, receiver)：拦截对象属性的设置 has(target, propKey)：拦截propKey in proxy的操作 deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作 ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回目标对象所有自身的属性的属性名 apply(target, object, args)：拦截Proxy实例作为函数调用的操作 construct(target, args)：拦截Proxy实例作为构造函数调用的操作 this问题 在Proxy代理的情况下，目标对象内部的this关键字会指向Proxy代理 有些原生对象的内部属性，只有通过正确的this才能拿到，所以Proxy无法代理这些原生对象的属性（可以通过this绑定原始对象来解决） ​ ​]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实力赢得尊重]]></title>
    <url>%2F2017%2F05%2F24%2F%E5%AE%9E%E5%8A%9B%E8%B5%A2%E5%BE%97%E5%B0%8A%E9%87%8D%2F</url>
    <content type="text"><![CDATA[前不久老弟找我吐槽，说老妈控制欲太强不给他隐私不尊重他。我问他，你觉得怎么样才能让别人尊重你。他想了想说，尊重别人呀，我觉得我在这方面做得挺好的呀。 不是的，赢得尊重的唯一方法是有实力。 我就这个论点给他讲了一堆大道理，他不能理解，所以没听进去。但是我说，如果你现在靠自己的能力赚了比别人更多的钱，你看他们会不会尊重你。然后他好像明白了。 当然，我不是指有钱就能赢得尊重，我想说的是实力。 有一个很好的论据就是欢乐颂的安迪。五美当中，大家最尊重的就是安迪。其实论性格，安迪没有小曲有趣好玩，论情商，她没有樊胜美处事圆滑，她做事有原则说话不拐弯，反倒容易让人不爽，但是却最受尊重。为什么呢？还不是因为人家有能力有实力，人家讲的话有分量有道理。人家比你厉害不止一个层级你当然只能仰望了。 其实生活中很多这样的例子，越有实力的人越深得别人尊重。哪怕是言辞恶毒咄咄逼人的豪斯医生都不缺同事和老板的尊重，我这里只说了同事是因为他的实力是体现在诊断技术上，尽管他的手下一次次被他逼得分分钟要发疯，却几乎每次都还是按照他的指示去做，是因为他们不敢反抗吗？不是，他们不是那种不敢反抗的人，而是因为他们知道豪斯的判断是正确的。 很多人喜欢抱怨啊，说我明明很尊重别人，可是别人没那么尊重我，尊重不应该是平等的吗？ 我反倒是觉得尊重本来就是不平等的，不是指你尊重一个人，那个人就不应该尊重你。你可能因为某个方面尊重某个人，那个人也可能因为某个方面尊重你，这是相互尊重，却不是严格上的平等尊重。你尊重比你牛逼的人是你的本能，而比你牛逼的人尊重你是他的教养。 所以啊，少点抱怨，多点沉淀。有一天你会突然发现，身边的人一下子对你尊重起来了呢。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6新特性--笔记（一）]]></title>
    <url>%2F2017%2F05%2F23%2FES6%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文完全参考 阮一峰的博客（ECMAScript 6 入门），只是简单的做个笔记。 let和const命令 let命令 let命令用来声明变量，用法类似于var，但是所声明的变量只在let命令所在的代码块内有效 for循环的计数器，很适合使用let命令 不存在变量提升：let所声明的变量一定要在声明后使用，否则报错 暂时性死区（TDZ）：在代码块内，使用let命令声明变量之前，该变量都是不可用的 不允许重复声明：let不允许在相同作用域内，重复声明同一个变量，不能在函数内部重新声明参数 let为JS新增了块级作用域 const命令 const声明一个只读的常量，一旦声明，常量的值就不能改变。 const一旦声明变量，就必须立即初始化 const作用域和let相同：只在声明所在的块级作用域内有效 const保证的，是变量指向的那个内存地址不得改动，但对象本身是可变的 es6声明变量的六种方法ES5只有两种声明变量的方法：var和function ES6添加了let和const，以及import和class 变量的解构赋值 ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构(Destructing)。 1let [a,b,c] = [1,2,3]; 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予相应的值。 数组的解构赋值 解构不成功，变量的值会等于undefined 不完全解构：等式左边的模式只匹配一部分等号右边的数组（可以成功） 若等号右边不是数组（不是可遍历的结构，不具备Iterator接口），将会报错 解构赋值允许指定默认值（数组成员不严格等于undefined，默认值不会生效） 对象的解构赋值 对象的属性没有次序，变量必须与属性同名，才能取到正确的值 对象的解构赋值的内部机制，是先找到同名属性，再赋给对应的变量。真正被赋值的是后者，不是前者。 123let &#123; foo: baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // "aaa"foo // error: foo is not defined 嵌套解构的对象也可以进行解构赋值 对象的解构也可指定默认值（对象的属性值严格等于undefined） 如果解构模式是嵌套的对象，且子对象所在的父属性不存在，将会报错 可以很方便地将现有对象的方法，赋值到某个变量 1let &#123; log, sin, cos &#125; = Math; 可以对数组进行对象属性的解构（数组本质是特殊的对象） 其他解构赋值 字符串的解构赋值（字符串被转换成了一个类似数组的对象，还可以对length属性进行解构赋值） 数值和布尔值的解构赋值（解构赋值时，若等号右边是数值和布尔值，则会先转为对象） 函数参数如果是数组，就会被解构成变量 12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 undefied和null无法转为对象，所以对它们进行解构赋值都会报错 用途 交换变量的值 从函数返回多个值 函数参数的定义 提取JSON数据 函数参数的默认值 遍历Map解构 输入模块的指定方法 字符串的扩展增加的方法 includes()：返回布尔值，表示是否找到了参数字符串 startsWith()：返回布尔值，表示参数字符串是否在源字符串头部 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部 repeat()：返回一个新字符串，表示将原字符串重复n次 padStart()：从头部补全字符串长度 padEnd()：从尾部补全字符串长度 模板字符串 模板字符串（template string）是增强版的字符串，用反引号标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 用模板字符串表示多行字符串，所有空格和缩进都会被保留在输出中 模板字符串中嵌入变量，需要将变量名卸载$()之中 大括号内部可以放入任意的JavaScript表达式，可以进行运算以及引用对象属性 模板字符串中能调用函数 若大括号中的值不少字符串，将按照一般规则转为字符串（调用toString方法） 模板字符串可以嵌套 String.raw() String.raw方法，用来充当模板字符串的处理函数，返回一个斜杠都被转义的字符串，对应于替换变量后的模板字符串。 数值的扩展Number对象的扩展 Number.isFinite()：检查一个数值是否为有限的 Number.isNaN()：检查一个值是否为NaN （传统方法先调用Number()将非数值的值转为数值，而这两个方法只对数值有效） Number.parseInt()和Number.parseFloat()：行为完全不变，只是将其移到Number对象上，减少全局性方法 Number.isIteger()：判断一个数是否为整数（在JS内部，整数和浮点数是同样的存储方式） Number.EPSILON：引入一个极小的常量，在于为浮点数计算设置一个误差范围 Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER：表示安全整数的上下限（-2^53-2^53，不包含端点） Number.isSafeInteger()：判断一个整数是否落在这个范围之内 Math对象的扩展 Math.trunc()：去除一个数的小数部分，返回整数部分 Math.sign()：判断一个数是正数、负数还是零，返回五种值：+1（整数）、-1（负数）、0（0）、-0（-0），NaN(其余值) Math.cbrt()：计算一个数的立方根 Math.clz32()：返回一个数的32位无符号整数形式有多少个前导0 Math.imul()：返回两个数以32位带符号整数形式相乘的结果（保证返回正确的低位数值） Math.fround()：返回一个数的单精度浮点数形式 Math.hypot()：返回所有参数的平方和的平方根 对数方法： Math.expm1()：返回e^x-1，即Math.exp(x)-1 Math.log1p()：返回1+x的自然对数，即Math.log(1+x) Math.log10(x)：返回以10为底的x的对数 Math.log2(x)：返回以2为底的x的对数 三角函数方法： Math.sinh(x) 、Math.cosh(x) 、Math.tanh(x)、Math.asinh(x) 、Math.acosh(x)、Math.atanh(x) 指数运算符 ES6新增了一个指数运算符(**) 122 ** 2 // 42 ** 3 // 8 可以与等号结合，形成一个新的赋值运算符(**=)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6新特性--笔记（二）]]></title>
    <url>%2F2017%2F05%2F23%2FES6%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文完全参考 阮一峰的博客（ECMAScript 6 入门），只是简单的做个笔记。 数组的扩展 Array对象的扩展 Array.from()方法用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组 Array.from()可以接收第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组 应用： 第一个参数指定第二个参数运行的次数 12Array.from(&#123; length: 2 &#125;, () =&gt; 'jack')// ['jack', 'jack'] 将字符串转为数组，然后返回字符串的长度（可以避免将大于\uffff的Unicode字符算作两个字符的bug） 123function countSymbols(string) &#123; return Array.from(string).length;&#125; Array.of()：将一组值转换为数组（总是返回参数值组成的数组） 数组实例的扩展方法 copyWith()：在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组 12[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] find()：用于找出第一个符合条件的数组成员，其参数为一个回调函数，所有数组成员依次执行该回调函数，直到找到第一个返回值为true的成员，然后将其返回 findIndex()：用法与find类似，返回第一个符合条件的数组成员的位置 （以上两个方法都可以接收第二个参数，用于绑定回调函数的this对象） fill()：使用给定值，填充一个数组（可以接收第二个和第三个参数，用于指定填充的起始位置和结束位置） entries()、keys()、values()方法：用于遍历数组，返回一个遍历器对象，可以用for...of循环进行遍历 数组的空位 数组的空位指，数组的某一个位置没有任何值。如，Array构造函数返回的数组都是空位。 Array.from方法会将数组的空位，转为undefined，这个方法不会忽略空位 扩展运算符(...)也会将空位转为undefined copyWithin()会连空位一起拷贝 fill()会将空位视为正常的数组位置 for...of循环会遍历空位（map方法会跳过空位） entries()、keys()、values()、find()、findIndex()会将空位处理成undefined 函数的扩展函数参数的默认值 ES6允许为函数的参数设置默认值，即直接写在参数定义的后面 参数变量是默认声明的，所以不能用let或const再次声明 使用参数默认值时，函数不能有同名函数 通常定义了默认值的函数，应该是函数的尾参数（如非尾部的参数设置默认值，这个参数就没法省略） 指定了默认值后，函数的length属性将失真（返回没有指定默认值的参数个数） 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域 利用默认参数，可以指定某个参数不得省略，否则就抛出一个错误 rest参数 ES6引入rest参数，用于获取函数的多余参数 rest参数的写法比较自然简洁 rest参数后不能再有其他参数 函数的length属性，不包括rest参数 扩展运算符 扩展运算符(...)好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列 扩展运算符可以展开数组，所以不再需要apply方法将数组转为函数的参数 扩展运算符提供了数组合并的新写法 1[1,2,...more] 扩展运算符可以与解构赋值结合起来，用于生成数组 123const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5] 如将…用于数组赋值，只能放在参数的最后一位 js的函数只能返回一个值，如需要返回多个值，只能返回数组或对象，扩展运算符可以解决这个问题 扩展运算符可以将字符串转为真正的数组（能够正确识别32位的Unicode字符） 任何Iterator接口的对象，都可以用扩展运算符转为真正的数组 箭头函数 ES6允许用“箭头” ( =&gt; ) 定义函数 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号 1var getTempItem = id =&gt; (&#123; id: id, name: "Temp" &#125;); 箭头函数的一个用处：简化回调函数 箭头函数的注意点： 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象（箭头函数没有自己的this） 不可以当作构造函数，不可以使用new命令，否则会抛出错误 不可以使用arguments对象，该对象在函数体内不存在，可以用rest参数代替 不可以使用yield命令，因此箭头函数不能用作Generator函数 对象的扩展Object.assign() Object.assign()用于对象的合并，将源对象的所有可枚举属性，复制到目标对象 若目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性 如果只有一个参数，Object.assign会直接返回该参数 若该参数不是对象，则会先转成对象再返回，如果无法转成对象就会跳过（undefined和null无法转成对象，所以作为参数会报错，但是不在首参数就不会报错） Object.assign实行的是浅拷贝，目标对象拷贝得到的是这个对象的引用 用途： 为对象添加属性 为对象添加方法 克隆对象（只能克隆原始对象自身的值，不能克隆它继承的值） 合并多个对象 为属性指定默认值 属性的遍历ES6一共有5种方法可以遍历对象的属性 for...in：循环遍历对象自身的和继承的可枚举属性（不含Symbol属性） Object.keys(obj)：返回一个数组，包括对象自身（不含继承的）所有可枚举属性（不含Symbol属性） Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身所有属性（包括不可枚举，不含Symbol属性） Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有Symbol属性 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有属性，不管属性名是Symbol或字符串，也不管是否可枚举 以上5中方法遍历对象的属性，都遵守同样的属性遍历的次序规则： 先遍历所有属性名为数值的属性，按照数字排序 再遍历所有属性名为字符串的属性，按照生成时间排序 最后遍历所有属性名为Symbol值的属性，按照生成时间排序 12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// ['2', '10', 'b', 'a', Symbol()] Object其他扩展方法 Object.is()：比较两个值是否严格相等，与（===）行为一致，但是+0不等于-0，且NaN等于自身 Object.setPrototypeOf()：设置一个对象的prototype对象，返回参数对象本身 Object.getPrototypeOf()：读取一个对象的原型对象 Object.keys()：返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键名 Object.values()：返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值 Object.entries()：返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值对 Object.getOwnPropertyDescriptors()：返回指定对象所有自身属性（非继承性）的描述对象]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入网址到页面呈现发生了什么]]></title>
    <url>%2F2017%2F04%2F05%2F%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[本文转自该博客 从输入网址到页面呈现发生了什么？这是前端面试官很喜欢问的一个问题，我就被问了好几次，但是每次答的都比较笼统，十句话就讲完了。但实际上，这个问题涉及的知识面很广，要细细说的话可以说一个小时不止了。刚好看到有篇博文写的挺详细的，就摘过来了，自己再敲一遍加深点印象。 前话在前端开发中我们常需要考虑首屏加载时间，为了尽可能减少首屏加载时间我们最好弄清楚从输入网址到页面最终呈现的过程中都发生了哪些事情，然后才能具体问题具体分析，从而达到提升网页性能的目的。 总的来说，从输入网址到页面呈现这个过程大致可分为两个部分： 网络通信 页面渲染 网络通信输入网址当我们在浏览器的地址栏输入网址例如(http://www.baidu.com)，http://代表使用超文本传输协议，www.baidu.com代表服务器地址，baidu.com代表域名。一个完整的URL包括协议、服务器地址(主机)、端口、路径。 负责域名查询与解析的DNS服务用户通常使用主机名或域名来访问某网站，而不是直接通关IP来访问，因为字母数字配合的表示形式更符合人类的记忆习惯，但是计算机可不理解这些名称。所以DNS服务应运而生。DNS协议通过提供域名查找IP地址，或逆向从IP地址反查域名的服务。 DNS查询过程如下： 操作系统先检查本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器。在此我们叫它本地DNS服务器。此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析。（此解析具有权威性） 如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析。（此解析不具有权威性） 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置进行查询。如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名（.com）是来谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址（baidu.com）给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找baidu.com域服务器，重复上面的动作进行查询，直至找到www.baidu.com主机。 如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS把请求转至上上级，以此循环。不管是本地DNS服务器用转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 从客户机到本地DNS服务器是属于递归查询，而DNS服务器之间的就是交互查询（迭代查询）。 应用层 客户端发送http请求报文http报文包括： 报文首部（请求行+各种首部字段+其他） 空行 报文主体（应被发送的数据）通常不一定要有报文主体 下面对百度首页请求报文首部进行分析：请求行 12请求方法GET 请求URI / HTTP协议版本 1.1GET / HTTP/1.1 首部字段 123456789101112131415161718请求资源所在服务器Host: www.baidu.com连接方式：持久连接 HTTP/1.1之前版本默认非持久连接Connection: keep-alive报文指令：要求所有中间服务器不返回缓存资源Pragma: no-cache控制缓存的行为：缓存前必须先确认其有效性，防止从缓存中返回过期的资源Cache-Control: no-cache用户代理可处理的媒体类型Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 q表示权重从而区分优先级http客户端浏览器信息User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36可接受的内容编码类型Accept-Encoding: gzip, deflate, sdch可接受的语言Accept-Language: zh-CN,zh;q=0.8相关信息或标记Cookie: BAIDUID=3C67AA3EF6B3347D3AA986CE489268C4:FG=1; BIDUPSID=3C67AA3EF6B3347D3AA986CE489268C4; 传输层 确保传输报文可靠性的TCP协议位于传输层的TCP协议为传输报文提供可靠的字节流服务。为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。 “三次握手”的过程是，发送端先发送一个带有SYN（synchronize）标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK（acknowledgement）标志的数据包以传达确认信息。接收方收到后再发送一个带有ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。 网络层 负责传输的IP协议IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在一个局部网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。具体过程如下图： 链路层 传输数据的硬件部分在网络层找到对方的MAC地址后，就将数据发送到数据链路层传输。至此请求报文已发出，客户端发送请求的阶段结束。 服务器接收报文接收端服务器在链路层接收到数据后，删除该层的首部信息并向网络层传递，网络层将接收的数据向传输层传递，在传输层会将传输的数据按序号从组请求报文并传送给应用层。当数据传输到应用层才能算真正接收到由客户端发送过来的http请求。 应用层 服务器发送http相应报文下面对百度首页响应报文首部进行分析： 状态行 12协议版本 状态码 状态码原因短语HTTP/1.1 200 OK 首部字段 1234567891011121314151617181920212223242526当前服务器上安装的HTTP服务器程序信息bfe:Baidu Front End。百度人自己写的反向代理及防攻击接入层Server: bfe/1.0.8.18响应日期时间Date: Thu, 08 Dec 2016 14:48:19 GMT说明报文实体的媒体类型Content-Type: text/html; charset=utf-8传输编码方式：分块编码Transfer-Encoding: chunked链接方式：持久链接 http/1.1之后这个已经没必要了Connection: keep-alive只接受对持相同自然语言的请求返回缓存Vary: Accept-Encoding缓存控制：仅向特定用户返回响应Cache-Control: privateCxy_all: baidu+43a6e396a3ed26dc7d1de13c6af79e49缓存过期时间Expires: Thu, 08 Dec 2016 14:47:38 GMTX-Powered-By: HPHPX-UA-Compatible: IE=Edge,chrome=1Strict-Transport-Security: max-age=172800BDPAGETYPE: 1BDQID: 0xc9d964a600018bb8BDUSERID: 0设置cookieSet-Cookie: H_PS_PSSID=1451_21116_17001_21408_21417_21554_20929; path=/; 响应报文的传输方式与请求报文相同，简单点说就是原路返回。 网络通信流程图 在网络通信阶段对前端优化建议 减少http请求数 合并资源，如合并JavaScript文件、CSS文件、利用CSS Spite合并图片等 内联图片，data url节省了http请求，但是如果这个图像在网页多个地方显示会加大网页的内容，延长下载时间。 域名体现解析，在页面中不同域名的链接需指定预取域名： 1&lt;link rel="dns-prefetch" href="http://this-is-a.com"&gt; 避免重定向（重定向会增加http请求的次数） cookie优化，cookie越多会导致请求头部越大 启用GZIP压缩（Accept-Encoding:g-zip） 使用CDN加速，减小服务器压力 合理利用http缓存，通过设置expires等 页面渲染客户端在接收到HTML代码后，接下来就是要进行页面渲染了。 解析HTML以构建DOM树解析一个文档即将其转换为具有一定意义的结构（编码可以理解和使用的东西）。解析的结果通常是表达文档结构的节点树，称为解析树或语法树。 解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础的。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为与上下文无关的语法。 解析的过程可以分成两个子过程：词法分析和语法分析： 词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。 语法分析是应用语言的语法规则的过程。 解析器通常将解析工作分给以下两个组件来处理： 词法分析器（标记生成器），负责将输入内容分解成一个个有效标记； 而解析器负责根据语言的语法规则分析文档的结构，从而构建解析树。 由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析HTML。此解析算法由两个阶段组成：标记化和树构建。 解析器的输出“解析树”是由DOM元素和属性节点构成的树结构。DOM是HTML文档的对象表示，同时也是外部内容（如JavaScript）与HTML元素之间的接口。解析树的根节点是“Document”对象。 当解析到link标签时会请求相应的CSS文件，并将其CSS规则解析为StyleSheet对象，CSS文件中的其他外链资源如背静图片等只有等到其规则与DOM树某节点相匹配时才会加载。 当解析遇到img标签时会根据路径向服务器相应的资源文件夹中请求图片资源，但并不会等待图片资源下载完再去解析接下来的HTML，而是并发执行即图片资源仍在下载，HTML解析也在进行。如果没有定义图片的height和width属性，那么浏览器为了显示每一个加载的图像，它需要先下载图像，然后解析出图像的高度和宽度，并在显示串口留出相应的屏幕空间，这样就会导致浏览器不断地重新计算/调整页面的布局，这可能会延迟文档的显示，并导致页面重绘。 当解析遇到script标签时，将启动JavaScript引擎，这时将阻塞DOM树的构建。因为JavaScript执行过程中，JavaScript很可能会对DOM树进行读写操作。直到JavaScript执行完毕（此时执行的是全局对象初始创建和全局上下文中代码的执行），DOM树才会恢复构建。 构建render树为了更好地用户体验效果，浏览器会在构建DOM树的同时，也在构建render树。呈现树的每一个节点即为与其相对于的DOM节点的CSS框，框的类型与DOM节点的display属性有关，block元素生成block框，inline元素生成inline框。 每一个呈现树节点都有与之相对应的DOM节点，但DOM节点不一定有与之相对应的呈现树节点。比如display属性为none的DOM节点，而且呈现树节点在呈现树中的位置与他们在DOM树中的位置不一定相同，比如float与绝对定位元素。 在构建render树的时候需要为DOM树匹配CSS规则，在这个阶段由于匹配规则是从右往左匹配的，所以css的编写规则很重要。不好的CSS选择器写法会影响到页面渲染的效率。 布局render树在创建render树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。布局是一个递归的过程，它从根元素开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。 布局通常具有以下模式： 父呈现器确定自己的宽度 父呈现器依次处理子呈现器： 放置子呈现器（设置x,y坐标） 如果有必要，调用子呈现器的布局，这会计算子呈现器的高度 父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用 将其dirty位设置为false 绘制render树在绘制阶段，系统会遍历render树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将在其屏幕上对应的矩形区域设为无效，这导致OS将其视为一块dirty区域，并申城“paint”事件。 绘制顺序： 背景颜色 背景图片 边框 子代 轮廓 页面变化造成的影响在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。 添加DOM节点后，会对该结点进行布局和重绘。一些重大变化（例如增大“HTML”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。 在页面渲染阶段对前端优化建议 建议将CSS文件放在页首，以便构建DOM树；将JavaScript文件尽量放在页面下方，放置阻塞构建DOM树；而JavaScript的onload事件里，不要写太多影响首屏渲染的、操作DOM树的JavaScript代码。 精简JavaScript和CSS代码，并进行代码压缩，使得css和js资源下载得更快 编写高效的CSS代码 重要的图片或者想让用户优先看到的图片使用img标签，次要的图片使用background引入]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox扩展虚拟机Ubuntu的硬盘容量]]></title>
    <url>%2F2017%2F03%2F14%2FVirtualBox%E6%89%A9%E5%B1%95%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E7%9A%84%E7%A1%AC%E7%9B%98%E5%AE%B9%E9%87%8F%2F</url>
    <content type="text"><![CDATA[之前在Virtual Box安装Ubuntu系统时，分区建议8G，然后我就傻傻地只给了8G，还以为够用了，然而今天各种安装应用软件发现空间不够了啊啊！只好想办法来扩充存储空间了。 添加虚拟硬盘Virtual Box 4.0之后，添加虚拟硬盘就非常简单了。 先找到安装Virtual Box的目录，我的是D:\Program Files\Oracle\VirtualBox。cmd进入这个目录。 输入命令查看需要修改的虚拟硬盘 我这里有三个虚拟电脑，我要修改的是Ubuntu1 找到需要扩容的vdi地址，然后使用如下命令修改空间大小：VBoxManage modifyhd YOUR_HARD_DISK.vdi –-resize SIZE_IN_MB YOUR_HARD_DISK.vdi是你要扩容的vdi，我的是Ubuntu1 SIZE_IN_MB是调整后的空间大小，我设的是20G 在查看一下虚拟硬盘的大小，会发现该虚拟的硬盘变成的20G，但是这20G还没有分配。 扩展Ubuntu文件系统大小 虚拟机开机（Ubuntu1） 查看磁盘情况：df -H 这里可以看到我的空间已经用得差不多了，100%了都。 你可能会想，我不是扩容为20G了嘛，咋文件系统空间还是没了呢？那是因为你还没给它分区指定文件系统啊~ 可以用如下命令看一下总空间：sudo fdisk -l /dev/sda ) 看，其实是有20G的。 下载一个gparted：sudo apt-get install gparted 启动gparted：sudo gparted 很多时候，新增的硬盘并不紧挨着需要扩展的硬盘，这时候需要做一些调整。选择加在中间的磁盘块，选择“swapoff”，然后再选中将其删除。 我这里删除后有两个分区：sda1和sda2，选中sda2将其删除。 这个时候就能选中sda1（你要扩展的分区），右键，选择“resize/move”，然后手动拖动就好了。 最后不要忘了点击上面工具栏的“√”，这样才能应用成功。 然后重启，再执行“df -h”看一下是否扩展成功 boom~成功啦~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的继承]]></title>
    <url>%2F2017%2F03%2F11%2FJavaScript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[JavaScript虽然也是面向对象语言，但是跟Java和c之类的语言不太一样，她没有类的概念（ES6里有了），所以在ES6之前，也没有类继承的概念。但是我们需要复用啊，所以就只能实现各种各样的模拟类继承，主要都是依靠原型链来实现的。 在《JavaScript高级程序设计》中有讲到几种继承方式：原型链、借用构造函数、组合继承、原型链继承、寄生式继承、寄生组合式继承等。下面就讲几种用的比较多的继承方式。 原型链继承基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。 核心：将父类的实例作为子类的原型。 123456789101112131415function Person (name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.say = function()&#123; console.log('hello, my name is ' + this.name);&#125;;function Man() &#123;&#125;Man.prototype = new Person('pursue');var man1 = new Man();man1.say(); //hello, my name is pursuevar man2 = new Man();console.log(man1.say === man2.say);//trueconsole.log(man1.name === man2.name);//true 这种继承方式很直接，为了获取Person的所有属性方法(实例上的和原型上的)，直接将父类的实例new Person(&#39;pursue&#39;)赋给了子类的原型，其实子类的实例man1,man2本身是一个完全空的对象，所有的属性和方法都得去原型链上去找，因而找到的属性方法都是同一个。 特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 缺点： 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 借用构造函数继承基本思想：在子类型构造函数中调用超类构造函数，通过使用call()和apply()方法可以在新建对象上执行构造函数。 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）。 123456789101112131415function Person (name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.say = function()&#123; console.log('hello, my name is ' + this.name);&#125;;function Man(name, age) &#123; Person.apply(this, arguments);&#125;//Man.prototype = new Person('pursue');var man1 = new Man('joe');var man2 = new Man('david');console.log(man1.name === man2.name);//falseman1.say(); //say is not a function 这里子类的在构造函数里利用了apply去调用父类的构造函数，从而达到继承父类属性的效果，比直接利用原型链要好的多，至少每个实例都有自己那一份资源，但是这种办法只能继承父类的实例属性，因而找不到say方法，为了继承父类所有的属性和方法，则就要修改原型链，从而引入了组合继承方式。 特点： 解决了1中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call多个父类对象） 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 组合继承基本原理：将原型链和借用构造函数结合在一起，从而发挥两者之长。 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。 12345678910111213141516function Person (name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.say = function()&#123; console.log('hello, my name is ' + this.name);&#125;;function Man(name, age) &#123; Person.apply(this, arguments);&#125;Man.prototype = new Person();var man1 = new Man('joe');var man2 = new Man('david');console.log(man1.name === man2.name);//falseconsole.log(man1.say === man2.say);//trueman1.say(); //hello, my name is joe 需要注意的是man1和man2的实例属性其实是覆盖了原型属性，但是并没要覆盖掉原型上的say方法（因为它们没有），所以这里man1.say === man2.say依然返回true，因而需要十分小心没有覆盖掉的原型属性，因为它是所有实例共有的。 特点： 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 既是子类的实例，也是父类的实例 不存在引用属性共享问题 可传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 寄生组合继承基本思想：通过借用函数来继承属性，通过原型链的混成形式来继承方法。 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点。 123456789101112131415161718function Person (name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.say = function()&#123; console.log('hello, my name is ' + this.name);&#125;function Man(name, age) &#123; Person.apply(this, arguments);&#125;Man.prototype = Object.create(Person.prototype);//a.Man.prototype.constructor = Man;//b.var man1 = new Man('pursue');var man2 = new Man('joe');console.log(man1.say == man2.say);console.log(man1.name == man2.name); 其实寄生组合继承和上面的组合继承区别仅在于构造子类原型对象的方式上（a.和b.），这里用到了Object.creat(obj)方法，该方法会对传入的obj对象进行浅拷贝。 因此，a.会将子类的原型对象与父类的原型对象进行很好的连接，而并不像一般的组合继承那样直接对子类的原型进行复制（如Man.prototype = new Person();）,这样只是很暴力的在对属性进行覆盖。而寄生组合继承方式则对实例属性和原型属性分别进行了继承，在实现上更加合理。 注：代码b.并不会改变instanceof的结果，但是对于需要用到construcor的场景，这么做更加严谨。 特点： 堪称完美 缺点： 实现较为复杂]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的this关键字]]></title>
    <url>%2F2017%2F03%2F09%2FJavaScript%E4%B8%AD%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[JS里面this关键字是一个很重要的概念，所以面试的时候经常会被问到this机制，你可能了解这个东西，但是讲不清楚，那也是白搭~~我就被问到好几次，但是每次就是几句话就讲完了，讲的也很乱，每次讲完之后面试官都有种“卧槽，这么重要的东西你两句话就讲完了”的感觉。。。唉~还是好好总结梳理一下吧。 this是个啥this是JavaScript中顶一个的众多关键字之一，它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。看个例子： 123function test()&#123; this.x = 1;&#125; 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是调用函数的那个对象。 this有啥用简单来说，this给函数带来了复用。再看个例子： 1234567891011121314151617function identify() &#123; return this.name.toUpperCase();&#125;function sayHello() &#123; var greeting = "Hello, I'm " + identify.call(this); console.log( greeting );&#125;var person1= &#123; name: "Kyle"&#125;;var person2= &#123; name: "Reader"&#125;;identify.call( person1); // KYLEidentify.call( person2); // READERsayHello.call( person1); // Hello, I'm KYLEsayHello.call( person2); // Hello, I'm READER 这段代码中，我们定义了两个函数，identify和sayHello。并且在不同的对象环境下执行了它们，达到了复用的效果，而不用为了在不同的对象环境下执行而必须针对不同的对象环境写对应的函数了。 不过有人会说，那我用其他的方式一样可以实现啊，如： 1234567891011121314151617function identify(context) &#123; return context.name.toUpperCase();&#125;function sayHello(context) &#123; var greeting = "Hello, I'm " + identify( context); console.log( greeting );&#125;var person1= &#123; name: "Kyle"&#125;;var person2= &#123; name: "Reader"&#125;;identify( person1); // KYLEidentify( person2); // READERsayHello( person1); // Hello, I'm KYLEsayHello( person2); // Hello, I'm READER 恩，确实是实现了类似的效果。但是~这个例子比较简单，这样实现是没啥问题的，但当代码复杂的时候，比如函数嵌套、各级调用等，那么传递一个对象的引用将变得很不明智，因为它会把你的代码搞得很混乱，甚至你自己都没办法理清楚。而this机制提供了一个更加优雅而灵便的方案，传递一个隐式的对象引用让代码变得简洁和复用。 this是咋使用的this到底绑定或引用的是哪个对象环境取决于函数被调用的地方。也就是说，谁调用这个函数或方法，this关键字就指向谁。 函数的几种调用方式 普通函数调用 作为方法调用 作为构造函数来调用 使用apply/call方法来调用 Function.prototype.bind方法 es6箭头函数 this的具体使用规则知道了函数的几种调用方式，下面就详细地讨论一下this在这些情况下的使用吧。 普通函数调用这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。 1234567function person()&#123; this.name="xl"; console.log(this); console.log(this.name);&#125; person(); //输出 window xl 在这段代码中person函数作为普通函数调用，实际上person是作为全局对象window的一个方法来进行调用的，即window.person()；所以这个地方是window对象调用了person方法，那么person函数当中的this即指window，同时window还拥有了另外一个属性name，值为xl。 12345var name="xl";function person()&#123; console.log(this.name);&#125;person(); //输出 xl 同样这个地方person作为window的方法来调用，在代码的一开始定义了一个全局变量name，值为xl,它相当于window的一个属性，即window.name=&quot;xl&quot;，又因为在调用person的时候this是指向window的，因此这里会输出xl。 作为方法来调用函数可以作为某个对象的方法调用，这时this就指向这个上级对象。 12345678910111213var name="XL";var person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125;&#125;person.showName(); //输出 xl//这里是person对象调用showName方法，很显然this关键字是指向person对象的，所以会输出name var showNameA=person.showName;showNameA(); //输出 XL//这里将person.showName方法赋给showNameA变量，此时showNameA变量相当于window对象的一个属性，因此showNameA()执行的时候相当于window.showNameA(),即window对象调用showNameA这个方法，所以this关键字指向window 再换种形式： 12345678910111213var personA=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125; &#125;var personB=&#123; name:"XL", sayName:personA.showName&#125; personB.sayName(); //输出 XL//虽然showName方法是在personA这个对象中定义，但是调用的时候却是在personB这个对象中调用，因此this对象指向 作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象，这时，this就指向这个对象。 12345function test()&#123; this.x = 1;&#125;var o = new test();alert(o.x); // 1 运行结果为1。为了表明这时this不是全局对象，对代码做一点改变： 123456var x = 2;function test()&#123; this.x = 1;&#125;var o = new test();alert(x); //2 运行结果为2，表明全局变量x的值根本没变。 再看一个复杂点的例子： 1234567891011function Person(name)&#123; this.name=name;&#125;var personA=Person("xl");console.log(personA.name); // 输出 undefinedconsole.log(window.name);//输出 xl//上面代码没有进行new操作，相当于window对象调用Person("xl")方法，那么this指向window对象，并进行赋值操作window.name="xl". var personB=new Person("xl");console.log(personB.name);// 输出 xl//这部分代码的解释见下 new操作符： 12345678910//下面这段代码模拟了new操作符(实例化对象)的内部过程function person(name)&#123; var o=&#123;&#125;; o.__proto__=Person.prototype; //原型继承 Person.call(o,name); return o;&#125;var personB=person("xl"); console.log(personB.name); // 输出 xl 在person里面首先创建一个空对象o，将o的proto指向Person.prototype完成对原型的属性和方法的继承 Person.call(o,name)这里即函数Person作为apply/call调用(具体内容下方)，将Person对象里的this改为o，即完成了o.name=name操作 返回对象o 因此person(&quot;xl&quot;)返回了一个继承了Person.prototype对象上的属性和方法，以及拥有name属性为”xl”的对象，并将它赋给变量personB.所以console.log(personB.name)会输出”xl” call/apply方法的调用在JS中函数也是对象，因此函数也有方法。从Function.prototype上继承到Function.prototype.call/Function.prototype.apply方法。 apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。也就是说，this指的就是这第一个参数。 Obj.method.apply(AnotherObj,arguments); 先看一个简单的例子： 12345678var x = 0;function test()&#123; alert(this.x);&#125;var o=&#123;&#125;;o.x = 1;o.m = test;o.m.apply(); //0 apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。 如果把最后一行代码修改为: 1o.m.apply(o); //1 运行结果就变成了1，证明了这时this代表的是对象o。 再来看一个复杂点的例子： 123456789101112131415161718funtion FruitA(n1,n2)&#123; this.n1=n1; this.n2=n2; this.change=function(x,y)&#123; this.n1=x; this.n2=y; &#125;&#125;var fruitA=new FruitA("cheery","banana");var FruitB=&#123; n1:"apple", n2:"orange"&#125;;fruitA.change.call(FruitB,"pear","peach");console.log(FruitB.n1); //输出 pearconsole.log(FruitB.n2);// 输出 peach FruitB调用fruitA的change方法，将fruitA中的this绑定到对象FruitB上。 Function.prototype.bind()接下来的例子可能有点绕额，不过仔细看还是很好理解哒~ 123456789101112var name="XL";function Person(name)&#123; this.name=name; this.sayName=function()&#123; setTimeout(function()&#123; console.log("my name is "+this.name); &#125;,50) &#125;&#125;var person=new Person("xl");person.sayName() //输出 “my name is XL”;//这里的setTimeout()定时函数,相当于window.setTimeout(),由window这个全局对象对调用,因此this的指向为window, 则this.name则为XL 那怎样才能输入&quot;my name is xl&quot;呢？bind()就上场了~ 1234567891011var name="XL";function Person(name)&#123; this.name=name; this.sayName=function()&#123; setTimeout(function()&#123; console.log("my name is "+this.name); &#125;.bind(this),50) //注意这个地方使用的bind()方法，绑定setTimeout里面的匿名函数的this一直指向Person对象 &#125;&#125;var person=new Person("xl");person.sayName(); //输出 “my name is xl”; 这里setTimeout(function(){console.log(this.name)}.bind(this),50);，匿名函数使用bind(this)方法后创建了新的函数，这个新的函数不管在什么地方执行，this都指向的Person，而非window，因此最后的输出为”my name is xl”而不是”my name is XL”。 另外几个需要注意的地方：setTimeout/setInterval/匿名函数执行的时候，this默认指向window对象，除非手动改变this的指向。在《javascript高级程序设计》当中，写到：“超时调用的代码(setTimeout)都是在全局作用域中执行的，因此函数中的this的值，在非严格模式下是指向window对象，在严格模式下是指向undefined”。这里都是在非严格模式下的情况。 123456789101112var name="XL";function Person()&#123; this.name="xl"; this.showName=function()&#123; console.log(this.name); &#125; setTimeout(this.showName,50);&#125;var person=new Person(); //输出 "XL"//在setTimeout(this.showName,50)语句中，会延时执行this.showName方法//this.showName方法即构造函数Person()里面定义的方法。50ms后，执行this.showName方法，this.showName里面的this此时便指向了window对象。则会输出"XL"; 修改上面的代码： 1234567891011var name="XL";function Person()&#123; this.name="xl"; var that=this; this.showName=function()&#123; console.log(that.name); &#125; setTimeout(this.showName,50)&#125;var person=new Person(); //输出 "xl"//这里在Person函数当中将this赋值给that，即让that保存Person对象，因此在setTimeout(this.showName,50)执行过程当中，console.log(that.name)即会输出Person对象的属性"xl" 匿名函数也是一样样的~ 12345678910111213var name="XL";var person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125; sayName:function()&#123; (function(callback)&#123; callback(); &#125;)(this.showName) &#125;&#125;person.sayName(); //输出 XL 123456789101112131415var name="XL";var person=&#123; name:"xl", showName:function()&#123; console.log(this.name); &#125; sayName:function()&#123; var that=this; (function(callback)&#123; callback(); &#125;)(that.showName) &#125;&#125;person.sayName() ; //输出 "xl"//匿名函数的执行同样在默认情况下this是指向window的，除非手动改变this的绑定对象 Eval函数该函数执行的时候，this绑定到当前作用域的对象上。 123456789101112var name="XL";var person=&#123; name:"xl", showName:function()&#123; eval("console.log(this.name)"); &#125;&#125;person.showName(); //输出 "xl"var a=person.showName;a(); //输出 "XL" 箭头函数es6里面this指向固定化，始终指向外部对象，因为箭头函数没有this,因此它自身不能进行new实例化，同时也不能使用call, apply, bind等方法来改变this的指向。 123456789101112function Timer() &#123; this.seconds = 0; setInterval( () =&gt; this.seconds ++, 1000); &#125; var timer = new Timer(); setTimeout( () =&gt; console.log(timer.seconds), 3100); // 3 //在构造函数内部的setInterval()内的回调函数，this始终指向实例化的对象，并获取实例化对象的seconds的属性,每1s这个属性的值都会增加1。否则最后在3s后执行setTimeOut()函数执行后输出的是0]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web缓存]]></title>
    <url>%2F2017%2F03%2F08%2Fweb%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[缓存的重要性应该不需要再强调了，直接切入正题~ 为什么要用缓存虽然说了不再强调，但还是再稍微说一下缓存的作用好了O(∩_∩)O。 一般针对静态资源如CSS,JS,图片等使用缓存，原因如下： 请求更快：通过将内容缓存在本地浏览器或距离最近的缓存服务器（如CDN），在不影响网站交互的前提下可以大大加快网站加载速度。 节省带宽：对于已缓存的文件，可以减少请求带宽甚至无需请求网络。 降低服务器压力：在大量用户并发请求的情况下，服务器的性能受到限制，此时将一些静态资源放置在网络的多个节点，可以起到均衡负载的作用，降低服务器的压力。 缓存分类缓存分为服务端侧（server side，比如 Nginx、Apache）和客户端侧（client side，比如 web browser）。常用的服务端缓存有CDN缓存，客户端缓存就是指浏览器缓存。 浏览器缓存机制缓存类型浏览器缓存氛围强缓存和协商缓存： 强缓存： 浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器； 协商缓存： 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回（304），但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；若未命中请求，则将资源返回客户端，并更新本地缓存数据（200）。 强缓存与协商缓存区别：强缓存不发请求到服务器，协商缓存会发请求到服务器。 设置缓存HTML Meta标签控制缓存（非HTTP协议定义）1&lt;META HTTP-EQUIV="Pragma" CONTENT="no-cache"&gt; 上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。这种方法使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。 HTTP头信息控制缓存HTTP头信息控制缓存是通过Expires（强缓存）、Cache-control（强缓存）、Last-Modified/If-Modified-Since（协商缓存）、Etag/If-None-Match（协商缓存）实现。 Expires：Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2016 23:55:55 GMT 读取缓存数据条件：缓存过期时间（服务器的）&lt; 当前时间（客户端的） 缺点：它是服务器返回的一个绝对时间，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大。 Cache-ControlCache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。 读取缓存数据条件：上次缓存时间（客户端的）+max-age &lt; 当前时间（客户端的） Cache-Control值可以是public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age: 12345678各个消息中的指令含义如下：Public //指示响应可被任何缓存区缓存。Private //指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当前用户的部分响应消息，此响应消息对于其他用户的请求无效。no-cache //指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，而是需要和服务器确认no-store //在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。max-age //指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。上次缓存时间（客户端的）+max-age（64200s）&lt;客户端当前时间min-fresh //指示客户机可以接收响应时间小于当前时间加上指定时间的响应。max-stale //指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 注意：这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。 Last-Modified/If-Modified-SinceLast-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。 If-Modified-Since：当资源过期时（强缓存失效），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。 缺点： Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间（无法及时更新文件） 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存，有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形（无法使用缓存）。 Etag/If-None-MatchEtag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。 注意：Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag一起使用时，服务器会优先验证ETag。 浏览器请求流程浏览器第一次请求流程图： 浏览器再次请求时：]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2017%2F03%2F07%2F%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[自古安全性和方便性相互对立，十位数的密码提高了安全性，但是也增加了记忆的不方便性。同样，同源策略提升了Web前端的安全性，但牺牲了Web拓展上的灵活性。由于现在项目大多比较大，如果将所有资源设在同一台服务器上，早就崩掉了。所以，为了兼顾安全和方便，现代浏览器选择了一个平衡点，在遵循同源策略的基础上，选择性地为同源策略“开放了后门”。 同源策略概念：同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。 这里的同源指的是：同协议，同域名和同端口。 精髓：它认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。 为什么要有同源限制？比如一个黑客程序，他利用IFrame把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 跨域方式jsonpjsonp = json + padding其实对于常用性来说，jsonp应该是使用最经常的一种跨域方式了，他不受浏览器兼容性的限制。但是他也有他的局限性，只能发送 GET 请求，需要服务端和前端规定好，写法丑陋。它的原理在于浏览器请求 script 资源不受同源策略限制，并且请求到 script 资源后立即执行。主要做法是这样的： 在浏览器端：首先全局注册一个callback回调函数，记住这个函数名字（比如：resolveJson），这个函数接受一个参数，参数是期望的到的服务端返回数据，函数的具体内容是处理这个数据。然后动态生成一个 script 标签，src 为：请求资源的地址＋获取函数的字段名＋回调函数名称，这里的获取函数的字段名是要和服务端约定好的，是为了让服务端拿到回调函数名称。（如：www.qiute.com?callbackName=resolveJson）。 1234567function resolveJosn(result) &#123; console.log(result.name);&#125;var jsonpScript= document.createElement("script");jsonpScript.type = "text/javascript";jsonpScript.src = "https://www.qiute.com?callbackName=resolveJson";document.getElementsByTagName("head")[0].appendChild(jsonpScript); 服务端 在接受到浏览器端 script 的请求之后，从url的query的callbackName获取到回调函数的名字，例子中是resolveJson。 然后动态生成一段javascript片段去给这个函数传入参数执行这个函数。比如： 1resolveJson(&#123;name: 'qiutc'&#125;); 执行 服务端返回这个 script 之后，浏览器端获取到 script 资源，然后会立即执行这个 javascript，也就是上面那个片段。这样就能根据之前写好的回调函数处理这些数据了。 为什么script标签引入的文件不受同源策略的限制？ 因为script标签引入的文件内容是不能够被客户端的js获取到的，不会影响到被引用文件的安全，所以没必要使script标签引入的文件遵循浏览器的同源策略。而通过ajax加载的文件内容是能够被客户端js获取到的，所以ajax必须遵循同源策略，否则被引入文件的内容会泄漏或者存在其他风险。 JSONP的缺点： 它只支持GET请求而不支持POST等其它类型的HTTP请求（虽然采用post+动态生成iframe是可以达到post跨域的目的，但这样做是一个比较极端的方式，不建议采用）。一般get请求能完成所有功能。比如如果需要给其他域服务器传送参数可以在请求后挂参数（注意不要挂隐私数据），即 1&lt;script src="http://www.google.com/getUsers.php?flag=do&amp;time=1"&gt;&lt;/script&gt; JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。可以看出来JSONP跨域一般用于获取其他域的数据。 一般能够用JSONP实现跨域就用JSONP实现，这也是前端用的最多的跨域方法。 document.domain一个页面框架（iframe／frame）之间（父子或同辈），是能够获取到彼此的window对象的，但是这个 window 不能拿到方法和属性. 123456789// 当前页面域名 https://blog.qiutc.me/a.html&lt;script&gt;function onLoad() &#123; var iframe =document.getElementById('iframe'); var iframeWindow = iframe.contentWindow; // 这里可以获取 iframe 里面 window 对象，但是几乎没用 var doc = iframeWindow.document; // 获取不到&#125;&lt;/script&gt;&lt;iframe src="https://www.qiutc.me/b.html" onload="onLoad()"&lt;/iframe&gt; 这个时候，document.domain 就可以派上用场了，我们只要把 https://blog.qiutc.me/a.html 和 https://www.qiutc.me/b.html 这两个页面的 document.domain 都设成相同的域名就可以了。前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致。但要注意的是，document.domain 的设置是有限制的，我们只能把 document.domain 设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com 中某个文档的 document.domain 可以设成a.b.example.com、b.example.com、example.com中的任意一个，但是不可以设成 c.a.b.example.com,因为这是当前域的子域，也不可以设成baidu.com,因为主域已经不相同了。这样我们就可以通过js访问到iframe中的各种属性和对象了。 12345678910// 主页面：https://blog.qiutc.me/a.html&lt;script&gt;document.domain = 'qiutc.me';function onLoad() &#123; var iframe =document.getElementById('iframe'); var iframeWindow = iframe.contentWindow; // 这里可以获取 iframe 里面 window 对象并且能得到方法和属性 var doc = iframeWindow.document; // 获取到&#125;&lt;/script&gt;&lt;iframe src="https://www.qiutc.me/b.html" onload="onLoad()"&lt;/iframe&gt; 1234// iframe 里面的页面&lt;script&gt;document.domain = 'qiutc.me';&lt;/script&gt; window.namewindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内，窗口载入的所有的页面都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。比如有一个www.qiutc.me/a.html页面，需要通过a.html页面里的js来获取另一个位于不同域上的页面www.qiutc.com/data.html里的数据。data.html页面里的代码很简单，就是给当前的window.name设置一个a.html页面想要得到的数据值。data.html里的代码： 123&lt;script&gt;window.name = '我是被期望得到的数据';&lt;/script&gt; 那么在 a.html 页面中，我们怎么把 data.html 页面载入进来呢？显然我们不能直接在 a.html 页面中通过改变 window.location 来载入data.html页面（这简直扯蛋）因为我们想要即使 a.html页面不跳转也能得到 data.html 里的数据。 答案就是在 a.html 页面中使用一个隐藏的 iframe 来充当一个中间人角色，由 iframe 去获取 data.html 的数据，然后 a.html 再去得到 iframe 获取到的数据。 充当中间人的 iframe 想要获取到data.html的通过window.name设置的数据，只需要把这个iframe的src设为www.qiutc.com/data.html就行了。然后a.html想要得到iframe所获取到的数据，也就是想要得到iframe的window.name的值，还必须把这个iframe的src设成跟a.html页面同一个域才行，不然根据前面讲的同源策略，a.html是不能访问到iframe里的window.name属性的。这就是整个跨域过程。 1234567891011121314151617181920// a.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function getData() &#123; var iframe =document.getElementById('iframe'); iframe.onload = function() &#123; var data = iframe.contentWindow.name; // 得到 &#125; iframe.src = 'b.html'; // 这里b和a同源 &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src="https://www.qiutc.com/data.html" style="display:none" onload="getData()"&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; window.postMessagewindow.postMessage(message, targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。兼容性： 调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 * 。 需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。 上面所说的向其他window对象发送消息，其实就是指一个页面有几个框架的那种情况，因为每一个框架都有一个window对象。在讨论第种方法的时候，我们说过，不同域的框架间是可以获取到对方的window对象的，虽然没什么用，但是有一个方法是可用的－window.postMessage。下面看一个简单的示例，有两个页面： 123456789// 主页面 blog.qiutc.com&lt;script&gt;function onLoad() &#123; var iframe =document.getElementById('iframe'); var iframeWindow = iframe.contentWindow; iframeWindow.postMessage("I'm message from main page.");&#125;&lt;/script&gt;&lt;iframe src="https://www.qiutc.me/b.html" onload="onLoad()"&lt;/iframe&gt; 1234567// b 页面&lt;script&gt;window.onmessage = function(e) &#123; e = e || event; console.log(e.data);&#125;&lt;/script&gt; WebSocketweb sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用) web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。 只有在支持web socket协议的服务器上才能正常工作。 12345var socket = new WebSockt('ws://www.baidu.com');//http-&gt;ws; https-&gt;wsssocket.send('hello WebSockt');socket.onmessage = function(event)&#123; var data = event.data;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你是一个循规蹈矩的女孩]]></title>
    <url>%2F2017%2F02%2F22%2F%E4%BD%A0%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BE%AA%E8%A7%84%E8%B9%88%E7%9F%A9%E7%9A%84%E5%A5%B3%E5%AD%A9%2F</url>
    <content type="text"><![CDATA[昨天有个朋友跟我说了句，你是个很循规蹈矩的女孩。 我洗漱完回来看到这句话的时候，不知道该怎么回复。 我循规蹈矩吗？是啊，从小就按着大人们的期望一路走来，小时候做个不让爸妈操心的乖女儿，上学做个不让老师烦恼的好学生。努力学习，考上一个985高校念本科，再努力学习，报送到一个C9联盟高校念硕士，再努力学习，争取找个好工作，然后过上大人们期望的那种坐办公室有双休日拿高薪的白领生活。一直以来，我就是长辈眼里的乖乖女，同辈眼里的高材生，同学眼里的学霸。我的人生，至少到目前为止，都是遵照着大多数的好学生模板复刻的。是啊，我是循规蹈矩来着。 我循规蹈矩吗？不是啊，从小逃课，喜欢冒险，喜欢恶作剧，热爱所有男孩子热爱的东西（除了游戏，毕竟手残），因为做过很多危险的事情不知道被揍过多少回。高中早恋，因为早恋这件事，让我这个好学生乖乖女受尽了精神折磨。大学谈了场义无反顾的恋爱，不顾劝阻不管世俗，虽然没能敌过两个人的沟壑。慢慢长大成熟后，开始认识世界，认识剖析自我，开始有思想有自我改变的冲动与行动。熟悉我的人一般都不觉得这是个传统学霸，而是个新兴伪学霸。 你说我循规蹈矩吗？没有啊，我骨子里充满着桀骜不驯。 你说我浪荡不羁吗？也没有啊，我的多数行为还是符合传统观念。 突然想到了《七月与安生》，有人说，她们就是对方的另一面，我觉得她们就是我的两面。七月，从小被家人守护者长大，一步步都按照家人的期望，乖巧懂事，善解人意，内心总有打破束缚的冲动却不敢行动，所以最擅长的是装，也只有安生最懂她是个什么样的人。安生，从小没爹，妈妈也常年不在身边，她像个弃儿，因为没有太多牵挂所以只身远走，浪迹天涯，但是却一直渴望爱渴望家渴望安定。 在长辈眼里，我大概就是七月的模样吧，不违背父母意愿，一次次达到新的高度让父母高兴为之自豪。在闺蜜们眼里，我大概有着安生的影子吧，思想独立，敢爱敢恨，做想做的人想做的事，一次次做出让她们觉得不可思议无法理解的决定。 可是，我很幸运。因为我知道自己是什么样的，我知道自己想要什么，我可以在一次次失意或挫折中自我剖析，然后一次次自我治愈，我知道该如何使自己变得强大。更幸运的是，当我有想法的时候，只要好好跟家人说，尽管他们不太赞同，也还是会支持我的选择。 我身边有很多朋友，生活精神都很独立，哪怕这个世界上只有他一个人了，他也能活得很精彩。他们有了改变的想法，就一定会有去改变的行动，品尝过不少苦头，也领略过不少精彩。现在一个个意气风发，没有不敢去做的事，只有不想去做的事，选择题都是自己出的，标准答案都是自己写的。 但是身边也有很多朋友，因为从小父母管得比较多，对父母或其他人比较依赖，一遇到事情就惊慌失措。思想单纯简单，屈服于一成不变的生活，别说他们没有改变的勇气，他们是没有改变的想法，这才是最可悲的。他们的人生没有选择题，只有填空题，而答案是他们根深蒂固的三观。 唉，貌似该去复习了，不多说了。最后说一句，如果有人跟我说，“你是个循规蹈矩的女孩”，那一定是因为我敬你是长辈。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2F2017%2F02%2F17%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[之前分析jQuery的sizzle引擎的时候，发现它是用css选择器来查找元素，出于为面试做准备的角度，把css选择器过一遍吧。 css选择器分类css选择器大致分为五类：基本选择器、关系选择器、属性选择器、伪类、伪元素 基本选择器 \*： 通用元素选择器 \#id : ID选择器 \.class : 类选择器 element : 属性选择器 1p &#123;line-height:1.5em; margin-bottom:1em;&#125; 关系选择器 E F：后代选择器，该选择器定位元素E的后代中所有元素F： 1ul li &#123;margin-bottom:0.5em;&#125; E &gt; F：子选择器，该选择器定位元素E的直接子元素中的所有元素F，它将忽略任何进一步的嵌套： 1ul &gt; li &#123;list-style:none;&#125; //仅限ul的直接子元素li，如果li里面还嵌套着另一个 ul 结构时，最里面的 li 将被忽略 E + F：相邻兄弟选择器，该选择器定位与元素E具有相同父元素且在标记中紧邻E的元素F： 1li + li &#123;border-top:1px solid #ddd;&#125; //定位具有相同父元素ul里除第一个li之外的所有li E ~ F：一般兄弟选择器，该选择器定位与元素E具有相同父元素且在标记中位于E之后的所有元素F： 1h1 ~ p &#123;color:#f00;&#125; //定位具有相同父元素的，h1标签之后的所有p标签 属性选择器 E[attr]：该选择器定位具有属性attr的任何元素E： 1input[required] &#123;border:1px solid #f00;&#125; //定位页面里所有具有必填属性"required"的input E[attr=val]：该选择器定位具有属性attr且属性值为val的任何元素E： 1input[type=password] &#123;border:1px solid #aaa;&#125; //定位页面里的密码输入框 E[attr|=avl]：该选择器定位具有属性attr且属性值为val或以val-开始的任何元素E： 1p[class|=a] &#123;color:#333;&#125; //定位页面里所有的P段落里具有class属性且属性值为a或是a-开始的，比如class="a"以及class="a-b" E[attr~=val]：该选择器定位具有属性attr且属性值为完整单词 val 的任何元素E： 1div[title~=english] &#123;color:#f88;&#125; //定位页面里所有具有属性title且属性值里拥有完整单词english的div容器，比如title="english"以及title="a english" E[attr^=val]：该选择器定位具有属性attr且属性值以val开头的任何元素E： 1div[class^=a] &#123;color:#666;&#125; //定位页面里具有属性class且属性值以a开头的div容器，比如class="a"以及class="ab" E[attr$=val]：该选择器与E[attr^=val]正好相反，定位具有属性attr且属性值以val结尾的任何元素E： 1div[class$=a] &#123;color:#f00;&#125; //定位页面里具有属性class且属性值以a结尾的div窗口，比如class="nba"以及class="cba" E[attr*=val]：该选择器与E[attr~=val]相似，但更进一步，定位具有属性attr且属性值任意位置包含val的元素E，val可以是一个完整的单词，也可以是一个单词中的一部分： 1a[title*=link] &#123;text-decoration:underline;&#125; //定位所有title里具有link字符串的a链接 伪类 :link：未访问的链接； :visited：已访问的链接，不建议使用； :hover：鼠标移动到容器，不仅限于链接，可用于页面中的任何元素； :active：被激活时的状态，不仅限于链接，可用于任何具有tabindex属性的元素； :focus：获得焦点时状态，不仅限于链接，可用于任何具有tabindex属性的无线： 1input:focus &#123;border:1px solid #333;&#125; //输入框获得焦点时的样式 :enabled：已启用的界面元素： 1input:enabled &#123;border:1px solid #899;&#125; :disabled：已禁用的界面元素： 1input:disabled &#123;background:#eee;&#125; :target：该选择器定位当前活动页面内定位点的目标元素： 1#info:target &#123;font-size:24px;&#125; //当访问的URL网址为 123.html#info 时，id="info"将加载这个字体样式 :default：应用于一个或多个作为一组类似元素中的默认元素的UI元素； :valid：应用于有效元素： 1input:valid &#123;border:1px solid #6a6;&#125; //当输入框验证为有效时加载这个边框样式，基于type或pattern属性 :invalid：应用于空的必填元素，以及未能与type或pattern属性所定义的需求相匹配的元素： 1input:invalid &#123;border:1px solid #f00;&#125; //当输入框为空且必填时，或已填写但验证无效时，加载此边框样式 :in-range：应用于具有范围限制的元素，其中该值位于限制内；比如具有min和max属性的number和range输入框； :out-of-range：与:in-range选择相反，其中该值在限制范围外； :required：应用于具有必填属性required的表单控件； :optional：应用于没有必填属性required的所有表单控件 :read-only：应用于其内容无法供用户修改的元素； :read-write：应用于其内容可供用户修改的元素，比如输入框； :root：根元素，始终指html元素； E F:nth-child(n)：该选择器定位元素E的第n个子元素的元素F： 1div.class p:nth-child(3) &#123;color:#f00;&#125; //class="class"的div容器里的第3个元素p，如果第3个子元素不是p，此样式将失效 E F:nth-last-child(n)：该选择器定位元素E的倒数第n个子元素的元素F； E:nth-of-type(n)：该选择器定位元素E的第n个指定类型子元素； E:nth-lash-of-type(n)：该选择器定位元素E的导数第n个指定类型子元素： 1.class p:nth-child(2) 与 .class p:nth-of-type(2) 的区别在于，如果.class里的第2个子元素不是P元素时，.class p:nth-child(2) 的样式将无效，而.class p:nth-of-type(2) 将定位在 .class 里的第2个p元素 1nth-child(n)、nth-last-child(n)、nth-of-type(n)、nth-last-of-type(n)，这其中的 n 可以使用数字静态式，比如 .nth-child(2n+1) 将匹配第1、3、5...个元素 E:first-child：父元素的第一个子元素E，与:nth-child(1)相同； E:last-child：父元素的倒数第一个子元素E； E:first-of-type：与:nth-of-type(1)相同； E:last-of-type：与:nth-last-of-type(1)相同； E:only-child：父元素中唯一的子元素E； E:only-of-type：父元素中唯一具有该类型的元素E； E:empty：没有子元素的元素，没有子元素包括文本节点； E:lang(en)：具有使用双字母缩写(en)表示的语言的元素； E:not(exception)：该选择器将选择与括号内的选择器不匹配的元素： 1p:not(.info) &#123;font-size:12px;&#125; //匹配所有class值不为info的p元素 伪元素伪元素可用于定位文档中包含的文本，为与伪类进行区分，伪元素使用双冒号 :: 定义，但单冒号 : 也能被识别。 ::first-line：匹配文本首行； ::first-letter：匹配文本首字母； ::before 与 ::after ：使用 contnet 属性生成额外的内容并插入在标记中： 1a[href^=http]::after &#123;content:"link"&#125; //在页面的a链接的后面插入文字link ::selection：匹配突出显示的文本： 1::selection &#123;background:#444; color:#fff;&#125; //定义选中的文本颜色与背景色 选择器优先级在对一个HTML元素应用CSS样式时，常常有很多种方法可以找到元素，那么如果一个元素被应用了很多同样的样式，最终会显式到哪一个样式呢？CSS对于多个选择器的优先性使用了一个叫做特殊性的方式。 css特殊性排序选择器的特殊性分为4个等级，a b c d，从左到右，越左边的越优先, 如果一个选择器规则有多个相同类型选择器，则+1。 HTML内样式，特殊性最优先，a=1 id选择器的特殊性是b 类选择器、伪类选择器、属性选择器为c 标签选择器、伪元素选择器为d 特殊性示例 选择器 特殊性 以10为基数的特殊性 style=&quot;color: red&quot; 1, 0, 0, 0 1000 #id {} 0, 1, 0, 0 100 #id #aid 0, 2, 0, 0 200 .sty {} 0, 0, 1, 0 10 .sty p[title=&quot;&quot;] {} 0, 0, 2, 0 20 p:hover {} 0, 0, 1, 0 10 p {} 0, 0, 0, 1 1 ul::after {} 0, 0, 0, 1 1 div p {} 0, 0, 0, 2 2 css重要性css中有种东西可以无视特殊性，那就是!important，使用这个标记的css属性总是最优先的。 12#id &#123; color: red &#125; .class &#123; color: yellow !important &#125; 上面例子中，第二个样式会优先于第一个样式，即使id选择器的特殊性高于类选择器。 但是如果两个属性都有 !important 那么由特殊性来决定优先级。 12#id &#123; color: red ！important &#125; .class &#123; color: yellow !important &#125; 结果是第一个样式优先于第二个样式。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Try - Asher Book]]></title>
    <url>%2F2017%2F02%2F16%2FTry-Asher%20Book%2F</url>
    <content type="text"><![CDATA[今晚啥都没干，啥都不想干，又不甘心白白浪费了这时光，写篇博文分享一首歌吧。Asher Book的《Try》，《名扬四海》主题曲。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162If i walk, would you run?若我走向你，你会躲开吗？If i stop, would you come?若我停下来，你会来寻我吗？If i say you&apos;re the one, would you believe me?若我说你就是唯一，你会相信吗？If i ask you to stay, would you show me the way?若我求你留下，你会告诉我怎么做吗？Tell me what to say so you don&apos;t leave me.告诉我，说什么你才不会离开。The world is catching up to you世界都会追随你While you&apos;re running away to chase your dream当你去寻你的梦It&apos;s time for us to make a move cause we are asking one another to change是时机了，我们希望为彼此而改变And maybe i&apos;m not ready我或许还没准备好But I&apos;ll try for your love但我愿为你的爱而尝试I can hide up above我本可以逃避I will try for your love但为你的爱我会努力We&apos;ve been hiding enough我们已错过太久If i sing you a song, would you sing along?若我为你而唱，你会随我一起吗？Or wait till i&apos;m gone, oh how we push and pull或等我灰心离去，这般你追我藏的戏码If i give you my heart would you just play the part若我给你我的心，你会在意吗？Or tell me it&apos;s the start of something beautiful.或告诉我这是个美丽的开始Am i catching up to you?我快要追随上你了吗？While your running away to chase your dreams当你去寻你的梦It&apos;s time for us to face the truth cause we are coming to each other to change是面对现实的时候了，我们希望为彼此而改变And maybe i&apos;m not ready我或许还没准备好But I&apos;ll try for your love但我愿为你的爱而尝试I can hide up above我本可以逃避I will try for your love但为你的爱我会努力We&apos;ve been hiding enough我们已错过太久I will try for your love为你的爱我会努力I can hide up above我本可以逃避If i walk would you run若我走向你，你会躲开吗If i stop would you come若我停下来，你会回来吗If i say you&apos;re the one would you believe me若我说你就是唯一，你相信了吗 第一次听到这首歌的时候就深深被吸引了，头皮发麻那种，果真，没有女生可以拒绝这首歌。 这绝对是目前为止我听过的最温柔的歌。 浅浅的吟唱，淡淡的希望。 一句句的试探，一次次的恳求。 赤裸裸的歌词，赤裸裸的爱恋。 噢~要去补电影了~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JS中的闭包]]></title>
    <url>%2F2017%2F02%2F13%2F%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[前几年刚了解JS的时候看过一点闭包的概念，当时是死活没看明白，后来还被面试官无情地拒绝了（可能心想这么一个简单的概念你都不懂要你有何用/(ㄒoㄒ)/~~） 今天又看了下，竟然奇迹般地没什么困难地看明白了，说明了什么，虽然这几年专业技术没怎么见长，但是一些编程思想还是潜移默化地存在我深深的脑海里了~下面就讲讲什么是闭包吧。 相关概念要理解闭包，还得先顺带着理解一下JS其他几个特性：嵌套函数、作用域、垃圾回收机制等等。 嵌套函数在JS中，函数是可以嵌套在另一个函数里的。嵌套函数的特点之一就是，它们可以访问上一级函数的变量和参数。如： 1234567891011function f1()&#123; n = 1; function f2()&#123; alert(n); // 1 &#125; return f2;&#125; 在这个例子中，f2是f1中的嵌套函数，因此f2可以访问f1中的变量n。嵌套函数有啥作用看下面这一小节就知道啦~ 变量的作用域所谓作用域就是指变量或函数可访问的范围。变量的作用域就两种：全局变量和局部变量。JS的一个特别之处就在于，函数内部可以直接读取全局变量。 12345678var n = 1;function f()&#123; alert(n);&#125;f(); //1 但是一般情况下，在函数外部就没办法读取函数内的局部变量了。 123456function f()&#123; var n = 1;&#125;alert(n); //error，n没有定义 那我们怎样才能用外部读取函数内部的局部变量呢？这时候就能用到嵌套函数了。 123456789function f1()&#123; n = 1; function f2()&#123; alert(n); // 1 &#125;&#125; 根据JS的链式作用域（chain scope），父对象所有的变量对于子对象都是可见的，相反子对象中的变量对父对象是不可见的。因此在上面的例子当中，f2是可以读取f1中的变量的，也就是n，所以我们只要把f2返回，就能在f1外部读取变量n了。 1234567891011121314function f1()&#123; n = 1; function f2()&#123; alert(n); &#125; return f2;&#125;var result = f1();result(); // 1 垃圾回收机制咱都知道，全局变量是一直存在的，但是局部变量只有在函数执行过程中存在。这就意味着，一个函数执行完毕，其内部定义的局部变量的内存空间就会被释放，重新再调用该函数时，又会重新为里面的局部变量分配空间，并不会保留之前执的值。看个例子： 12345678function f()&#123; var n = 1; return ++n;&#125;alert(f()); //2alert(f()); //2 这个例子中，两次执行f函数返回的值都是2，事实上，不管执行多少次，返回的值都会是2，因为每执行一次，n都是重新创建的。 在JS中，如果一个对象不再被引用，那么这个对象就会被GC无情地回收。如果两个对象互相引用，而不被第三者引用，那么这两个对象就会被双杀。所以作用域那个例子中的f1和f2都能存活地好好的，因为有第三者（这个第三者是window对象）在调用f1，本质上是在调用f2。 闭包的概念好，铺垫了这么多，重点终于出场了。 闭包的官方解释： 闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 看明白了吗？我也没明白，说得这么纠结，其实就是能够读取其他函数内部变量的函数。具体怎么读取的，作用域里那个例子已经讲了，通常的做法就是在函数内部再定义一个函数。看一个例子理解一下： 12345678910111213141516171819function f1()&#123; var n = 0; function f2()&#123; n++; return n; &#125; return f2;&#125; alert(f1()); //实际是执行function f2()&#123; n++; return n; &#125; var f3 = f1(); //这句话其实是将f1的执行结果，也就是f2赋给f3alert(f3()); //1alert(f3()); //2 上面这个例子就创建了一个闭包。虽然局部变量在函数执行完就被销毁了，但是两次执行f3()，n的值增加了，说明这个局部变量存在于内存中了，没有被GC回收。这是因为有个全局变量f3，它会一直存在于内存中，而f3又引用了f2，所以JS会认为f2是有用的，而f2又引用了f1中的n，所以f1也不会被回收。 这就体现出了闭包的一个特性：捕捉到局部变量和参数，并一直保存下来。 闭包的应用场景看了上面的例子，应该很容易就能想到闭包的用处了： 使外部函数可以访问内部函数的变量 让局部变量始终保存在内存中，而不被销毁 私有成员的存在 前面两条应该不用多说了，私有成员的存在的这个用途在啰嗦两句吧。私有成员其实就是指函数内部定义的属性，一般情况下外界是访问不到的，但是正是由于有闭包，才使得私有成员变得更有使用价值。 12345function f(arg)&#123; this.n = arg; //公用属性 var m = 2; //私有属性&#125; 使用闭包的注意事项也许你大概懂了闭包是什么的时候，就恨不得大展身手一下，到处都用一下。但是！这真是万万使不得的！因为滥用闭包是会出现问题的啊！而这种问题又刚好是它的用途引起的~ 内存泄漏创建一个闭包，而后闭包有创建一个循环引用，那么该元素将无法销毁，也就是内存泄漏。例如： 1234567function clickToAdd(element, a, b) &#123; element.onclick = function() &#123; alert(a + b); &#125;;&#125; 这里，即使没有使用element，闭包也保留了element，a和b的引用。由于element也保留了对闭包的引用，这就产生了循环引用，这就不能被GC回收。这种情况下，可将代码重构为： 1234567891011function clickToAdd(element, a, b) &#123; var result = a + b; element.onclick = function() &#123; alert(result); &#125;; result = null; //设置null就能断开保存的引用，释放内存&#125; 我看网上还有种解决方案，如下，不过这个我有点云里雾里，不是特别理解。 123456789101112function clickToAdd(element, a, b) &#123; element.onclick = add(a, b);&#125;function add(a, b) &#123; return function() &#123; alert(a + b); &#125;&#125; this对象改变this 对象是在运行时基于函数的执行环境绑定的（在匿名函数中具有全局性）（this：当前发生事件的元素），但是在一些闭包的情况下你会发现this会不太听话。举个经典的栗子： 123456789101112131415var name = "The Window"; var obj = &#123; name : "The object", getName : function()&#123; return function()&#123; return this.name; &#125; &#125;&#125;var resultName = myobject.getName();alert(resultName()); //The window 可能在没看结果的时候，你会以为是返回”My Object”，恩，我本来也是这么以为的。因为根据我们之前的理解，getName函数中的this应该是指myobject这个对象的。但是，闭包改变了它。 getName这个函数里面返回了一个匿名函数，这匿名函数返回它运行环境中存在的name的值。当执行完var resultName=myobject.getName()这句时，实际上是将它里面的匿名函数的引用给了resultName。当执行resultName()时，它是在全局作用域中执行的，因此this对象就指向了全局环境，全局环境中的name属性的值是”The window”。所以最终结果是”The window”。 那能不能得到我们期望的结果呢？哼哼，当然啊，不然我就不会问了~ 123456789101112131415161718var name="The window";var myobject=&#123; name:"My Object", getName:function()&#123; var that = this; return function()&#123; return that.name; &#125; &#125;&#125;var resultName = myobject.getName();alert(resultName()); //My Object 这里我们将this保存在一个叫that的变量里，这里，that保存的一直是myobject的执行环境。当在执行resultName()时，它返回的是that.name；that在getName中有定义，它是的执行环境是myobject，而在myobject中也有定义name，它的值是”My Object”。所以，最终结果是”My Object”。【这里的解释就是作用域链的知识】 总结好吧，讲完了。其实不懂的还有很多，这些只是高深的JS知识中的冰山一角，不过先大概了解着，慢慢来吧~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
