<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小胡不说八道</title>
  
  <subtitle>Go easy on the soul.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hu33.tech/"/>
  <updated>2019-01-20T13:24:21.598Z</updated>
  <id>http://hu33.tech/</id>
  
  <author>
    <name>不说八道的小胡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>飞羽作品集（下）</title>
    <link href="http://hu33.tech/2019/01/19/%E9%A3%9E%E7%BE%BD%E4%BD%9C%E5%93%81%E9%9B%86%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://hu33.tech/2019/01/19/飞羽作品集（下）/</id>
    <published>2019-01-19T08:56:52.816Z</published>
    <updated>2019-01-20T13:24:21.598Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本作品集为飞羽原创，18岁生日时飞羽将其作为礼物赠与本人，现将该作品摘抄并记录在该博客中。</p></blockquote><h2 id="（四十）《卖火柴的小女孩》"><a href="#（四十）《卖火柴的小女孩》" class="headerlink" title="（四十）《卖火柴的小女孩》"></a>（四十）《卖火柴的小女孩》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（四十）.jpg" alt="《卖火柴的小女孩》"></p><a id="more"></a><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>从前有个可怜的小女孩，父母很早就去世了，只留下她与年迈的奶奶相依为命，她每天只能靠卖火柴来维持生计。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>日子一天天过去，有一天，出现了一个小男孩，手里拿着很多烟火，他是来放烟花的，恰巧，他没有火柴。</p><p>小男孩在小女孩附近绕了很久，小女孩似乎看出了小男孩的心思，就问他：“你是要买火柴吗？”小男孩不好意思地说：“嗯，不过我没带钱。”小女孩大方地说：“我送你一根火柴吧，但是要让看看你放的烟花。”小男孩的脸上绽放着笑容：“当然，你喜欢什么颜色的？”“彩色的。”小女孩毫不犹豫地回答，在她的家里似乎只要黑与白两种颜色，所以她特别渴望彩色。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>小男孩拿了一根火柴跑到一块离小女孩不远的空旷地方，向小女孩挥了挥手示意要放烟花了，小女孩睁着大眼睛屏住呼吸等待着。</p><p>火柴点亮了，天空绽放出一朵彩色的云，“真是漂亮的烟花”，小女孩说着。她完全沉醉进去了–她感觉自己的手能触摸到那一片彩色的云了，好柔软，好温暖，还有一种轻飘飘的感觉。她甚至觉得自己都要跟云一起飘起来了，飘到天堂去跟她的爸爸妈妈打个招呼……</p><p><img src="https://hu33.github.io/images/飞羽作品集/（四十）2.jpg" alt="《卖火柴的小女孩》"></p><p>当小女孩睁开眼睛时，烟花早就消失了，她的嘴角还挂着一抹甜甜的微笑。</p><p>小男孩跑过来问她：“漂亮吗？我刚刚怎么见你闭上眼睛没看啊？”</p><p>小女孩笑着说：“我看到了啦，用心看到了，非常漂亮。”</p><p>顿了顿又说：“你明天还会来吗？”</p><p>小男孩想了想：“嗯，只要你想要我来我就来，不过是免费的火柴哦！”</p><p>“那当然。”</p><p>“那就一言为定了。”</p><p>约定明天再见面后，小男孩蹦蹦跳跳地回家了，小女孩目送着他离开，然后继续卖她的火柴……</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>冬天的序幕在不知不觉中揭开了，小女孩依旧穿着她那单薄的外套，打着赤脚，蜷成一团叫卖着火柴。每天最快乐的时光，便是等小男孩来了，看他放那灿烂的烟花。所以，即使生意再好，小女孩也总会留下一根火柴，这是只属于小男孩的非卖品。</p><p>小男孩今天来得很早，她怕女孩在雪里等得太久冻着了，他很同情小女孩的生活境遇，想着，等有一天自己赚钱了，一定要让这个女孩过上和自己一样好的日子。</p><p><img src="https://hu33.github.io/images/飞羽作品集/（四十）3.jpg" alt="《卖火柴的小女孩》"></p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>小女孩的奶奶病了，这让小女孩面对更大的困境。她几乎已经没有办法支撑起这个家了，她也想过向小男孩家里求助，后来想了想，还是放弃了。</p><p>小男孩从小女孩的眼里看到了哀伤，哪怕她表面装得再快乐，也掩饰不了绚丽的烟花印在她眼中的黯淡。小男孩想每天陪她一起卖火柴，可是连跟她一起放烟花都是好不容易才求得父母的同意，一起卖火柴怎么可能让父母批准呢？</p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>小男孩想出了另外一个办法，把他每天带出来要放的烟花全都卖掉，把卖了的钱给小女孩。</p><p>小女孩的经济压力得到了减轻，可是，要想治好奶奶的病，这些钱是远远不够的。而且，她开始怀念从前看的烟花了，她的世界，仿佛回到了黑与白。此时的小男孩，也是一筹莫展。</p><p><img src="https://hu33.github.io/images/飞羽作品集/（四十）4.jpg" alt="《卖火柴的小女孩》"></p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>奶奶还是在一个风雪交加的夜晚去世了，小女孩趴在床边孤零零地哭着，没有小男孩的陪伴。</p><p>又过了一段更加艰难的日子，有一天，小女孩要小男孩别卖烟花了，她说她想看一次。</p><p>这一次，小女孩的眼里又重新出现了彩色。她努力不让自己去想自己还能看几次这样的烟花，小男孩也努力不让自己去想还能给小女孩几次这样的快乐。因为，现在的她实在太虚弱了。</p><p>现实的残酷让他们无法反抗。</p><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>终于有一天，小男孩跑去小女孩卖火柴的地方，发现小女孩不在了。他等了很久，等到的只是父母把他带回家去吃饭。</p><p>一连几天，小男孩去的时候都没有看到小女孩。他开始用寻找代替等待，他总想着，她只是换地方了，也许马上就能找得到呢！</p><p>日子一天天过去，小男孩从来没有放弃过寻找，生活给他的结果是–蓦然回首，灯火阑珊处，空无一人。</p><p>……</p><p><img src="https://hu33.github.io/images/飞羽作品集/（四十）5.jpg" alt="《卖火柴的小女孩》"></p><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>象征着冬天的雪消融了，小男孩像往常一样走到小女孩卖火柴的地方。</p><p><strong>结局一：</strong></p><p>小男孩惊讶地发现地上有很多已经烧过了的火柴，仔细数了数，发现正好是和小女孩看过烟花的次数。原来，每次看完烟花后，小女孩都没扔掉点燃过的火柴，而是把它们埋在这雪里。</p><p>小男孩把这些燃过的火柴紧紧地攥在手里：“这是我们永不逝去的友情，不管你在哪儿，我都会想着你的。”</p><p>烟火绽放在夜幕之中，小男孩仿佛在天上看到了小女孩无暇的笑脸。</p><p><strong>结局二：</strong></p><p>一辆马车缓缓地停在小男孩的旁边，卖火柴的小女孩从上面走了下来。原来，是小女孩的一个亲戚找到了小女孩，把她带去养病了，小女孩那时还没来得及跟小男孩道别。</p><p>夜幕下，小男孩和小女孩微笑地坐在一起，看那永不逝去的烟花。</p><p><code>----------本篇完----------</code></p><h2 id="（四十一）《荼蘼》"><a href="#（四十一）《荼蘼》" class="headerlink" title="（四十一）《荼蘼》"></a>（四十一）《荼蘼》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（四十一）.jpg" alt="《荼蘼》"></p><p>第一声蝉鸣揭开了夏天的序幕，夏雨依旧毫不吝啬地浇灌着每一株在春天盛开的花，在一个不起眼的角落里，一株荼蘼依旧紧闭着，完全不像要开花的样子。</p><p>它问地上的小草：“小草小草，你说我怎么还不开花呢？”小草说：“快了吧，你别急，这不是还有一些花没开吗？”“也是”，荼蘼安慰着自己。</p><p>不知不觉夏天已经过去一半了，好多开过的花都已经谢了，荼蘼更加着急了，问不远处的昙花：“昙花姐姐，为什么我还不开花呢？”昙花想了想说：“也许你已经开了但是你不知道呢？像我就是在夜晚开花，你今晚别睡觉了，看看自己是不是在夜晚开的花。”垂头丧气的荼蘼一下子振奋起来了，盼望着夜幕的降临，心想着：“没错，我一定是在夜晚开花的，咯咯咯咯~~”</p><p><img src="https://hu33.github.io/images/飞羽作品集/（四十一）2.jpg" alt="《荼蘼》"></p><p>漫漫长夜随着天际的破晓而宣布离去，荼蘼熬了一夜，硬是没有看到自己开花。此时的荼蘼已经心灰意冷了，旁边的梅花树安慰她：“没事啦，荼蘼啊，你看我这梅花都要冬天才开呢！现在还是夏天，早得很哪，开花这事儿，急不得的。”</p><p>荼蘼想了想：“也是，我就不去想这事儿了，能开花就行。”不过其实它也很在意，它想要的是在这热情奔放的夏天盛开，而不是寒冷刺骨的冬天。</p><p>夏天马上就要过去了，荼蘼在夏天盛开的可能性也越来越小，它努力让自己不再去想这件事了……</p><p>夏的最后一天，荼蘼惊艳地绽放了。</p><p><code>----------本篇完----------</code></p><h2 id="（四十二）《白云和风》"><a href="#（四十二）《白云和风》" class="headerlink" title="（四十二）《白云和风》"></a>（四十二）《白云和风》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（四十二）.jpg" alt="《白云和风》"></p><p>湛蓝的天空下有一对很好的朋友，一个是白云，一个是风。除了白云，谁也不知道风在哪里。</p><p>可是有一天，白云变成了乌云，这下子风可不认识它了，到处找啊找啊，就是不见白云的踪影。</p><p>乌云只有靠风才能动，没有风，它就只能干巴巴地浮在空中等着。好不容易风飘到了它的面前，它大声喊着自己就是白云可是风完全不相信。风不屑地说：“我的朋友白云全身都是雪白的，看你这脏的样子，怎么可能是它呢？”</p><p>乌云发现自己的身体正在一点点地变湿润，它知道自己马上就要死了，要化成透明的雨到地上去了。一想到连道别都不能跟风说，它伤心地哭了起来。</p><p>风见乌云哭得那么伤心，觉得是有些不对劲，就去确认了一下乌云到底是不是就是白云。乌云边哭边诉说着它们过去一件件开心的事情，这会儿风真的相信乌云就是白云了。可还没来得及多说一句话，乌云已经全部化成了雨落了下去。</p><p><img src="https://hu33.github.io/images/飞羽作品集/（四十二）2.jpg" alt="《白云和风》"></p><p>风后悔死了，心想怎么没早点问清楚，不然也不会出现这种状况了。</p><p>没有了云的风，带着颓废的心情以及看不见的躯体，像幽灵般漂浮在天上，想着：“白云以前在这里待过……”</p><p>又是一阵子过去了，突然有一天，天边出现了一朵白云……</p><p><code>----------本篇完----------</code></p><h2 id="（四十三）《心房》"><a href="#（四十三）《心房》" class="headerlink" title="（四十三）《心房》"></a>（四十三）《心房》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（四十三）.jpg" alt="《心房》"></p><p>我希望有这么一座房</p><p>透明的窗</p><p>享受阳光</p><p>我希望有这么一座房</p><p>充满想象</p><p>朝着梦想的方向</p><p>我希望有这么一座房</p><p>纯澈明亮</p><p>周围散发着花香</p><p>我希望有这么一座房</p><p>爬山虎在上面缠绕</p><p>与铁轨遥遥相望</p><p>我希望</p><p>某人有这样的心房</p><p><code>----------本篇完----------</code></p><h2 id="（四十四）《如果可以》"><a href="#（四十四）《如果可以》" class="headerlink" title="（四十四）《如果可以》"></a>（四十四）《如果可以》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（四十四）.jpg" alt="《如果可以》"></p><p>如果可以</p><p>我想做一阵风</p><p>自由地无形</p><p>直到遇见</p><p>让我有形的你</p><p>如果可以</p><p>我想做一片云</p><p>把所有的累都含在心里</p><p>等某一刻</p><p>肆意地洒落</p><p>如果可以</p><p>我想做一只蜗牛</p><p>与生活的节奏背道而驰</p><p>漫观世界的永无休止</p><p>如果可以</p><p>我想做一片树叶</p><p>在生命的最后一刻</p><p>舞动隐藏的翅膀</p><p>如蝶般纷飞而落</p><p>如果可以</p><p>我想做一株小草</p><p>违抗被践踏的命运</p><p>在坚硬的大地之上</p><p>生息不断</p><p>如果</p><p>我不是我</p><p>你亦菲你</p><p>命运</p><p>又会开一个</p><p>什么样的玩笑</p><p>让彼此聚散无常？</p><p><code>----------本篇完----------</code></p><h2 id="（四十五）《小老鼠吱吱》"><a href="#（四十五）《小老鼠吱吱》" class="headerlink" title="（四十五）《小老鼠吱吱》"></a>（四十五）《小老鼠吱吱》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（四十五）.jpg" alt="《小老鼠吱吱》"></p><p>在所有与老鼠有关的童话里，都有一只叫吱吱的老鼠，这只也不例外。</p><p>小老鼠吱吱天生就是大家讨厌的对象，可不是因为它有多讨厌，而是大家形成了一种固定思维–老鼠都是坏的。</p><p>可是小老鼠吱吱并不在意被大家讨厌，还是会在人家需要帮助的时候帮别人一把。</p><p>这一天，兔子家门口的锁坏了，怎么打也打不开。小老鼠吱吱就马上跑过去，用牙齿不停地磨门上的锁，把口里都磨出血了终于才磨开了锁。本以为兔子再也不会讨厌他了，结果兔子说的第一句话竟然是：“哎呀，这锁还不够结实，看样子得换把好一点的锁来防着点。”</p><p>又有一天，小狗在玩一个跳跳球，一不小心把球给掉到蛇洞里去了。在谁都没辙的时候，吱吱冒着生命危险去蛇洞里面把球推了出来，小狗没说一句谢谢，还怪球被弄脏了，又自个儿玩去了。</p><p><img src="https://hu33.github.io/images/飞羽作品集/（四十五）2.jpg" alt="《小老鼠吱吱》"></p><p>不久后，小鸡妈妈发现窝里的蛋少了一个，便在吱吱门前大吵大嚷地喊着：“偷蛋贼！”吱吱在家里那叫一个委屈啊：“虽说老鼠爱偷鸡蛋，可我从来没有做过这样的事啊。”为了澄清自己，吱吱整日整夜地去找那只丢了的蛋，终于在一个草丛里发现了它。于是吱吱高兴地把鸡蛋带回去给鸡妈妈。鸡妈妈捧着宝贝蛋说：“乖乖，还好你没事，不然妈妈可怎么活啊。”顿了顿又瞟了一眼吱吱：“算你还有良心，把蛋还回来了。”此时吱吱已经累得不行了，也不想再解释什么，拖着疲惫的身子回洞里去了。</p><p>……</p><p>就这样，在大伙的偏见与误解中，吱吱实在受不了了。开始和自己的同类一起做坏事，学会去偷别人的吃的，咬坏别人家的东西……</p><p>又过了一段时间，一次吱吱和几个同伴聚会，喝酒喝多了便开始抱怨起来：“那些个动物算什么，我原本对它们那么好，它们凭什么那样对我，哼，现在算是把仇都报了。”</p><p>另外一只老鼠笑嘻嘻地说：“当初要不是我们暗中使坏把你拉到我们这边来，你的日子也不会像现在这么潇洒啊。”</p><p>“暗中使坏？”吱吱好气地问了句。</p><p>“对啊，锁是我们弄坏的，洞是我们挖的，蛋也是我们偷的……我们可都是为了你好，不然你怎么会到我们这边来呢？”</p><p>吱吱一下子清醒了，酒也没喝，走了。</p><p>第二天清早，吱吱就收拾好行李，独自离开了。他要去找一个地方，没有偏见，也没有陷害，只有纯澈的真诚。</p><p><code>----------本篇完----------</code></p><h2 id="（四十六）《飞蛾与螳螂》"><a href="#（四十六）《飞蛾与螳螂》" class="headerlink" title="（四十六）《飞蛾与螳螂》"></a>（四十六）《飞蛾与螳螂》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（四十六）.jpg" alt="《飞蛾与螳螂》"></p><p>###1</p><p>在一个不起眼的角落里，一只飞蛾刚刚睡醒，不过还没来得及清醒它就被吓呆了，因为就在前面不远处一只螳螂正盯着它看。正巧的是，螳螂正一步一步向它走来飞蛾的恐惧已经完全占据了它的理智，它知道自己马上就要死于螳螂的刀下了。</p><p>“唰！”一眨眼的工夫，刀起刀落，地上多了一具黄蜂的尸体，原来刚才黄蜂正在飞蛾后面，这才是螳螂想要捕食的对象。</p><h3 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h3><p>飞蛾悬着的心还没来得及放下来，看螳螂吃黄蜂的样子又害怕得一动也不敢动了。</p><p>螳螂吃饱后瞟了它一眼：“放心，我现在对你还没兴趣。”</p><p>飞蛾刚叹了口气，螳螂又说：“等你长大一点再吃也不迟。”</p><p>飞蛾真的几乎崩溃了，不过又马上镇定了下来：“等我长大了我就去扑火，到时候你就吃不到我了。”飞蛾这话的时候连自己都觉得奇怪，这不是摆明让螳螂吃掉自己吗？</p><p>可这时螳螂突然来了兴趣：“对了，你们为什么要去扑火啊？那不是自取灭亡吗？”</p><p><img src="https://hu33.github.io/images/飞羽作品集/（四十六）2.jpg" alt="《飞蛾与螳螂》"></p><p>飞蛾清了清嗓子，摆出一副教授的样子说道：“这你们就不懂了，其实除了凤凰可以涅槃，我们飞蛾也可以，但这个概率很小，只有九万九千九百九十九分之一，所以一般的飞蛾都死了，不过如果涅槃成功了的，我就会变成一种比蝴蝶还漂亮的动物，而且还会使法术。”</p><p>螳螂瞪大了眼睛，这种事还是头一回听说，真想见识见识。</p><h3 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h3><p>为了能见识飞蛾的涅槃，螳螂开始和飞蛾在一起了，不过这可不是飞蛾想要的，有个杀手在身边可是一件很毛骨悚然的事。飞蛾也想过逃跑，不过一旦被发现的话，它也会像最开始那只黄蜂那样被整个吃掉的。于是，它不再想逃跑的事了。</p><p>“小羽，我出去觅食了，你就呆在这好好练习一下你的翅膀吧。”螳螂开始称呼飞蛾的名字了，因为至少它现在没把这只飞蛾当猎物看待。</p><p>“好的，刀刀。”小羽也直呼螳螂的名字，连它自己也觉得很不可思议，它居然会跟一只螳螂混在一起。</p><h3 id="4-1"><a href="#4-1" class="headerlink" title="4"></a>4</h3><p>日子一天天过去了，小羽也慢慢长大了，这天螳螂刀刀又开始问：“小羽，还要多久你才能涅槃啊？”小羽一时不知怎么回答了，因为和它差不多大的飞蛾都已经去尝试这项伟大的事业了，当然，结果只是死亡。</p><p><img src="https://hu33.github.io/images/飞羽作品集/（四十六）3.jpg" alt="《飞蛾与螳螂》"></p><p>小羽知道，现在它只有两个选择，要么扑火，要么被刀刀吃掉。终于，它下定决心了：“就今晚吧！”</p><p>刀刀一脸的喜悦，虽然不一定能看到小羽涅槃成功，但一想到那个情景就觉得异常兴奋。</p><h3 id="5-1"><a href="#5-1" class="headerlink" title="5"></a>5</h3><p>夜无声地降临了，在一盏油灯面前，小羽和刀刀正呆呆地站着，火苗不停地窜动，两个生命在它的面前显得太渺小了。</p><p>“开始吧。”刀刀的声音打破了夜的寂静。</p><p>小羽擦了擦汗，鼓起勇气向火苗扑去，头用力地往下低着，紧闭着眼睛，凭感觉去不断撞击火焰。一下，两下，三下……连一旁的刀刀都看得非常紧张。</p><p>火苗还在窜动着，小羽不知疲惫地不停扑着火，它知道哪怕有一秒钟的停顿，它的身体就会被无情的火焰吞食，它只有用完最后一丝体力，才有希望得意涅槃。</p><p><img src="https://hu33.github.io/images/飞羽作品集/（四十六）4.jpg" alt="《飞蛾与螳螂》"></p><h3 id="6-1"><a href="#6-1" class="headerlink" title="6"></a>6</h3><p>小羽马上就要支撑不住了，它使出了最后力气扑向火焰，希望能在碰到火焰的那一瞬间能有奇迹发生。可以，在它身体穿过火焰的那一瞬，它知道奇迹没有发生，它再也没有力气去扑火了，倒在了地上，等待着死亡的降临。</p><p>当然，刀刀并没有杀它，其实刀刀早就把小羽当成了朋友，它是真的希望小羽能够涅槃成功，尽管现在失败了，它也要带着小羽回去。</p><p>正当刀刀走近小羽时，奇迹发生了，刚刚被小羽不断扑打的火焰熄灭了，小羽的背上长出了一双蓝色的翅膀，此时的刀刀兴奋极了，大声喊着：”小羽，你成功了，你成功了，快醒醒啊！“</p><p>小羽用力睁开了眼睛，看了看自己，满足地笑了，又睡了过去。</p><h3 id="7-1"><a href="#7-1" class="headerlink" title="7"></a>7</h3><p>第二天一大早，小羽就醒来了，它躺在原来和刀刀一起居住的房子里，不过它还不知道怎么使用法术呢，只是呆呆地看着自己那一对美丽的翅膀。</p><p>它隐隐约约听到一个声音对自己说：“来吧，飞越过高山，又飞羽过海洋，来到我们这个梦的世界吧！你的翅膀会带你飞到这里来的。”</p><p><img src="https://hu33.github.io/images/飞羽作品集/（四十六）5.jpg" alt="《飞蛾与螳螂》"></p><p>小羽兴奋地跟刀刀说听见声音呼唤它到梦的世界去了，刀刀听了也替它高兴，不过一想到还没见到小羽使的法术就要离开了又觉得很不舍。</p><p>小羽看出了刀刀的心思，对它说：“我们一起去吧，反正你也会飞。”</p><p>刀刀灿烂的笑了。</p><h3 id="8-1"><a href="#8-1" class="headerlink" title="8"></a>8</h3><p>小羽和刀刀就这样出发了，在那双奇妙的翅膀的带领下，不久，它们就飞越过了高山，可是在飞越海洋的途中，刀刀显得体力不支了，而小羽，因为那双翅膀的作用还毫无感觉。</p><p>刀刀对小羽说：“小羽，我好像不行了，不能陪你到海洋那边梦的世界去了，你去了之后多学点法术，还有，别忘了有我这么一个朋友哦。”</p><p>小羽说：“这怎么行呢，你到我背上来，我背你一起去。”话刚说完，小羽就背起了刀刀继续向前飞去。</p><h3 id="9-1"><a href="#9-1" class="headerlink" title="9"></a>9</h3><p>翅膀的力量只足够让小羽一个人飞到梦的世界去，背上刀刀后，小羽很快也没力气了，眼看着它们都要掉到海面上去了，刀刀从小羽背上一跃，掉了下去，只留给小羽一个微笑。</p><p><img src="https://hu33.github.io/images/飞羽作品集/（四十六）6.jpg" alt="《飞蛾与螳螂》"></p><p>小羽愣了一下，飞快地朝刀刀掉落的地方冲去，用比当初扑火时更大的力气，冲进了海里，它压根就没想过结果会是怎样，它只要找到刀刀。</p><p>被小羽冲起浪花的那一层海面，很快就平静了下来，刀刀和小羽都失去了知觉，沉到了海底。</p><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><p>当小羽醒来时，它已经到梦的世界了，此时刀刀正在它的旁边，还熟睡着呢。这是又出现当初呼唤小羽来的那个声音，告诉它现在它真的涅槃了。</p><p>原来，飞蛾的涅槃不仅需要火的炼造，还需要水的洗礼，而现在，小羽成了真正意义上一只涅槃过的飞蛾了。</p><p>从此，小羽和刀刀就生活在了这个梦的世界，开始学习法术的生活。也许不久之后，它们就会通过法术回到原来的世界，做出一些奇妙的事情呢。</p><p><code>----------本篇完----------</code></p><h2 id="（四十七）《卖梦的商店》"><a href="#（四十七）《卖梦的商店》" class="headerlink" title="（四十七）《卖梦的商店》"></a>（四十七）《卖梦的商店》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（四十七）.jpg" alt="《卖梦的商店》"></p><p>“天使”经营了一家商店，专门卖梦给需要的顾客。</p><p>第一个来买梦的是小狗，它要的梦很简单，只是能在梦里有骨头吃。因为是刚开张，所以“天使”免费送给它一个梦，其实也就是一颗丸子，夜晚睡前吃掉就可以做许下愿望的梦了。</p><p>第二个来的顾客是一只蝴蝶，它的梦也很简单，只想梦里能有一片无尽的花丛任它飞舞，自然，它也拿到了一颗丸子。</p><p>第三个顾客是一只乌鸦，它想要在梦里拥有一身洁白的羽毛，在付了钱之后，它也得到了一颗丸子，高高兴兴地走了。</p><p>夕阳散尽了最后一丝余晖，夜与梦同时降临。</p><p>在小狗的梦里，它的前脚只剩下白色的骨头，惨不忍睹，小狗看着自己的骨头，吓了醒来。</p><p><img src="https://hu33.github.io/images/飞羽作品集/（四十七）2.jpg" alt="《卖梦的商店》"></p><p>蝴蝶在梦里看到了一片无穷无尽的花，准确地说，是食人花，蝴蝶只能用力地挥着翅膀在花的上方挣扎，无穷无尽，永远飞不出去。</p><p>乌鸦更惨，本以为洁白的羽毛会令同类羡慕不已，结果同伴都视其为异类，飞到哪儿都遭受驱赶……</p><p>第二天一大早，买了梦的动物们纷纷到卖梦天使店找“天使”理论，结果昨天那个天使模样的店主已经不见了，取而代之的是面目狰狞的魔鬼。动物们这才恍然大悟，原来买的是魔鬼的梦，只能愤然离去。</p><p>其实动物们不知道，天使与魔鬼经营着同一家店，你若内心澄澈，不带一丝贪恋，梦自然是美好的。否则，噩梦则永远不会消失。</p><p><code>----------本篇完----------</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本作品集为飞羽原创，18岁生日时飞羽将其作为礼物赠与本人，现将该作品摘抄并记录在该博客中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;（四十）《卖火柴的小女孩》&quot;&gt;&lt;a href=&quot;#（四十）《卖火柴的小女孩》&quot; class=&quot;headerlink&quot; title=&quot;（四十）《卖火柴的小女孩》&quot;&gt;&lt;/a&gt;（四十）《卖火柴的小女孩》&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://hu33.github.io/images/飞羽作品集/（四十）.jpg&quot; alt=&quot;《卖火柴的小女孩》&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://hu33.tech/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="作品集" scheme="http://hu33.tech/tags/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
      <category term="礼物" scheme="http://hu33.tech/tags/%E7%A4%BC%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>飞羽作品集（中）</title>
    <link href="http://hu33.tech/2019/01/18/%E9%A3%9E%E7%BE%BD%E4%BD%9C%E5%93%81%E9%9B%86%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
    <id>http://hu33.tech/2019/01/18/飞羽作品集（中）/</id>
    <published>2019-01-18T05:00:16.558Z</published>
    <updated>2019-01-20T13:22:40.404Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本作品集为飞羽原创，18岁生日时飞羽将其作为礼物赠与本人，现将该作品摘抄并记录在该博客中。</p></blockquote><h2 id="（二十一）《世界末日》"><a href="#（二十一）《世界末日》" class="headerlink" title="（二十一）《世界末日》"></a>（二十一）《世界末日》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（二十一）.jpg" alt="《世界末日》"></p><a id="more"></a><p>世界末日真的到来了，幸运的是，仁慈的上帝派了诺亚方舟拯救世界上所有的生灵。</p><p>诺亚方舟一到，大家就争相往上面挤。人类就开始维持秩序，分配大家上去的顺序。当然，人类理所当然是最先上去的，凭其所谓的智商，然后人类开始控制入口，觉得可以上的，就放行。</p><p>狮子马上挤上前：“我是万兽之王，必须得带我走吧！”人类想想，确实啊，狮子是代表性的动物，不带上不行。于是，狮子顺利进入了诺亚方舟。既然万兽之王能上诺亚方舟，那森林之王–老虎也没有不上诺亚方舟的理由吧！因此老虎也紧跟着上去了。</p><p>再然后，聪明的猴子，狡猾的狐狸等动物也一一上了诺亚方舟，等人类的朋友海豚挤上诺亚方舟时已经再也挤不上了，和平鸽一声下令：“出发！”诺亚方舟便开始向前方驶去，这次的目的地是月球，必须等地球平静后才能开回来。</p><p><img src="https://hu33.github.io/images/飞羽作品集/（二十一）2.jpg" alt="《世界末日》"></p><p>开着开着，动物们开始望着这颗还湛蓝的地球，带着一丝的不舍。不过想到过一阵子又能回来，他们便也舒缓了。然而，接下来发生的事大家都始料未及的。由于离开了大气层，空气越发地稀薄，氧气已经很少了，大家都有点喘不过气来，这时有动物才意识到忘记带一样最重要的东西了–植物。其他什么动物都可以不带，唯独不能不带植物。</p><p>大家都争相往诺亚方舟挤，说着自己的重要性，而真正最重要的植物却一言不发。这下大家才真正清醒–看似最渺小的才是最伟大的。这下子，该是真正的世界末日了。</p><p>（能意识到所失去事物的重要性，这是种万幸，也是种不幸。）</p><p><code>----------本篇完----------</code></p><p>##（二十二）《秋》</p><p><img src="https://hu33.github.io/images/飞羽作品集/（二十二）.jpg" alt="《秋》"></p><p>残叶卷风起</p><p>飞花飘雨零</p><p>古月依然照</p><p>今人难想惜</p><p><code>----------本篇完----------</code></p><h2 id="（二十三）《沙漠里的树》"><a href="#（二十三）《沙漠里的树》" class="headerlink" title="（二十三）《沙漠里的树》"></a>（二十三）《沙漠里的树》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（二十三）.jpg" alt="《沙漠里的树》"></p><p>干涸的沙漠中心突然出现了一棵巨大的树，这件事可不寻常啊，要知道沙漠中心极热无比，寸草不生呢！</p><p>这棵大树吸引了许多沙漠动物的围观，大树被围得里三层外三层，什么稀奇古怪的动物，只要能来就都来了。然后大家开始研究为什么这棵大树会突然出现在沙漠中心，动物们用尽了所有它们会的语言来问大树，可大树总是沉默着，一言不发。动物们也束手无策，尽管无法获知大树到来的原因，但大家依旧对这棵大树有着很浓厚的兴趣，把它视作神物供奉。</p><p>又是很突然的一刻，大树消失得无影无踪，沙漠里的动物再次被惊动–一棵如此巨大的树怎么说消失就消失了呢，没有哪个动物知道这是海市蜃楼……</p><p><code>----------本篇完----------</code></p><h2 id="（二十四）《梦的枕头》"><a href="#（二十四）《梦的枕头》" class="headerlink" title="（二十四）《梦的枕头》"></a>（二十四）《梦的枕头》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（二十四）.jpg" alt="《梦的枕头》"></p><p>上帝的枕头一不小心遗落到了人间，被一个不知该说是幸运还是不幸的人捡到了。</p><p>枕头想：“既然他捡到了我，那也算是一种缘分吧！我就让他在梦里过得舒服点吧！”</p><p>太阳被约了赶下了山，捡到枕头的人也开始进入梦乡。枕头对他的大脑施了魔法，让他的愿望显示出来然后让他在梦里实现这个愿望。不过，枕头没想到这个人的愿望居然如此简单–有很多的糖可以吃。枕头当然欣然去梦里让他好好享受吃糖的快乐。一晚下来，捡到枕头的人做的梦里是五颜六色的糖，他吃得可开心了，一辈子都没吃过这么多的好吃的糖呢！</p><p>不过，他的口水全流在枕头身上，这可让枕头很不乐意–作为上帝的枕头，怎么能让人类的口水都流在自己身上呢？尽管很不乐意，但看到这个人做梦时笑得那么甜，它还是决定忍了。然而，接连很多天这个人都流口水，而且一次比一次多，枕头终于忍无可忍了，决定让他在梦里失去幸福，体会一下不幸的哀愁。</p><p><img src="https://hu33.github.io/images/飞羽作品集/（二十四）2.jpg" alt="《梦的枕头》"></p><p>果然，这一天梦里，他的生活变得非常不幸，生活没有一件如意的事，他哭得很凄惨，半夜就哭醒来了，依然湿了枕头。这下枕头更纳闷了，这幸福不幸，不幸更不行呀！口水好歹是甜的，这眼泪也太咸了。如此过了几夜，梦枕更受不了了，它决定再想想别的办法。</p><p>上帝的枕头不愧是上帝的，一下子又想到了，它决定让他既不做幸福的梦也不做不幸的梦，而是做噩梦。然而，枕头还是失算了，捡枕头的人是个十足的胆小鬼，在梦里被吓个半死，额头上全都是汗了，枕头被他的汗浸湿了。这回枕头可是苦不堪言了，口水是甜的还不算惨，泪水是闲的也罢了，这汗水可是苦的呀，这苦枕头可怎么受得了……</p><p><img src="https://hu33.github.io/images/飞羽作品集/（二十四）3.jpg" alt="《梦的枕头》"></p><p>纠结了几天，枕头喝了几天苦汗水后实在没办法了，决定什么梦也不能让他做了，干脆让他失眠算了。这下子枕头不苦了，可苦了这个捡枕头的人了，连续的失眠怎么受得了呢？他似乎觉察到枕头的不对劲了，最终决定扔掉这个奇怪的枕头。</p><p>于是，枕头在第二天躺在了垃圾堆里。当然，它没躺多久，上帝就找到它了，把它弄干净带了回去。回去之后上帝问枕头感觉怎么样，枕头满口怨言呀！这人间还真不适合枕头这样的神物待着。</p><p>没办法，一般人都会有喜怒哀乐，不像上帝可以安心地枕着它入睡。不过这样也好，这就是天堂和人间的区别，有喜有怒有哀有乐，这才是人间的魅力所在。</p><p><code>----------本篇完----------</code></p><h2 id="（二十五）《飞羽》"><a href="#（二十五）《飞羽》" class="headerlink" title="（二十五）《飞羽》"></a>（二十五）《飞羽》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（二十五）.jpg" alt="《飞羽》"></p><p>飞羽飞，</p><p>霏雨雨，</p><p>飞雨雨飞羽。</p><p>蜚语飞，</p><p>语飞羽，</p><p>予非飞羽。</p><p><code>----------本篇完----------</code></p><h2 id="（二十六）《单翅天使》"><a href="#（二十六）《单翅天使》" class="headerlink" title="（二十六）《单翅天使》"></a>（二十六）《单翅天使》</h2><p> <img src="https://hu33.github.io/images/飞羽作品集/（二十六）.jpg" alt="《单翅天使》"></p><p>天使做了一个梦，梦见自己只有一只翅膀，于是感到很好奇，就去问上帝：“上帝啊，我昨晚做梦梦见自己只剩一只翅膀了，这是为什么呀？”</p><p>上帝说：“如果你知道了为什么，你就可能真的只剩一只翅膀了，你还想知道吗？”</p><p>天使想了想，实在想知道为什么，就坚决问上帝为什么。上帝告诉他：“所有的天使原本都只有一只翅膀，为了好看，许多天使偷偷地偷了人家的翅膀，偷到翅膀的天使便用一双翅膀飞到了天堂，那些翅膀被偷了的天使就变成了人类，生活中天空下那一片土地上。”</p><p>天使一下子惊住了：“那我的翅膀岂不是偷来的？可是我没有去偷过啊！”</p><p>上帝无奈一笑：“在你出生时，你的父母就偷了一只翅膀，所以你现在就有了一双翅膀。那个和你同时出声的被偷了翅膀的小孩就生活在你脚底下那片土地。”</p><p> <img src="https://hu33.github.io/images/飞羽作品集/（二十六）2.jpg" alt="《单翅天使》"></p><p>天使一下子惊呆了，他没想到自己是这样变成天使的，嚷嚷着要上帝取了他的那只偷来的翅膀。上帝平静地问天使：“翅膀取了你就不能飞翔了，你还愿意取吗？”</p><p>天使没有丝毫的迟疑，坚决要取下那只翅膀。于是，上帝取下了那只被偷来的翅膀，天使以为自己马上会因不能飞翔而坠落下去，离开这上帝居住的天堂。可没想到自己反而在往上升，那一只原本属于他的翅膀在带着他飞翔，他好奇地大声呼喊：“上帝，我这是要去哪啊？”</p><p>上帝笑了，乐呵呵地说：“去天堂啊，顺便告诉你，其实我不是上帝，只是看管这片区域的守卫罢了。”这下天使大彻大悟了，原来自己一直不在天堂啊，因为一只翅膀要带他去天堂，可另一只偷来的翅膀要去人间寻找它的助人而阻碍了他去天堂，取下那只翅膀之后，原来属于他的翅膀便带他去到了真正的天堂。</p><p>话说另一只被守卫取下的翅膀，自然是去人间寻找他的主人呗。历经千辛万苦之后，翅膀终于找到它那个从小就与它分离的主人，兴奋地对主人说：“主人啊，我是你的翅膀，带你去天堂的，你快戴上我吧，等你死后我们就可以去往天堂了。”</p><p> <img src="https://hu33.github.io/images/飞羽作品集/（二十六）3.jpg" alt="《单翅天使》"></p><p>那主人大笑：“一只翅膀吗？没有一双翅膀可怎么带我去天堂呢？”翅膀就跟你他解释原因，可这主人就是不听，心想有一双翅膀的才是天使，才能居住在天堂，只有一只翅膀的岂不是怪物？便对翅膀摆了摆手，说还是等到有一双翅膀了再来接他去天堂吧。</p><p>这下翅膀也没有办法了，只能游走人间，寻找一个愿意戴着它去天堂的人，可是遗憾的是世人都认为天使有一双翅膀，没人愿意让这一只翅膀带着去天堂，因此这只翅膀就流量至今，仍在人间寻寻觅觅……</p><p>你梦到过一只带你去天堂的翅膀吗？如果还没梦到，请不要错过了，那些长着一双翅膀的可不是天使呢，别被骗了哦！</p><p><code>----------本篇完----------</code></p><h2 id="（二十七）《小傻》"><a href="#（二十七）《小傻》" class="headerlink" title="（二十七）《小傻》"></a>（二十七）《小傻》</h2><p> <img src="https://hu33.github.io/images/飞羽作品集/（二十七）.jpg" alt="《小傻》"></p><p>我做了一个很美，</p><p>很美的梦。</p><p>你从土里发了芽，</p><p>一点一点地长大。</p><p>直到，</p><p>花繁叶茂，</p><p>像这幅图一样。</p><p>我的小傻，</p><p>快点长高吧。</p><p><code>----------本篇完----------</code></p><h2 id="（二十八）《虫与鸟》"><a href="#（二十八）《虫与鸟》" class="headerlink" title="（二十八）《虫与鸟》"></a>（二十八）《虫与鸟》</h2><p> <img src="https://hu33.github.io/images/飞羽作品集/（二十八）.jpg" alt="《虫与鸟》"></p><p>从小鸟妈妈就教育小鸟：“小乖乖，要记住一个生存的道理–早起的鸟儿有虫吃，起晚了就会挨饿的。”</p><p>同样，从小毛毛虫妈妈就教育毛毛虫：“小乖乖，要记住一个生存的道理–早起的虫虫被鸟吃，起早了就会被吃掉的，所以我们要学会做懒虫哦。”</p><p>可是，事与愿违，乖乖鸟和毛毛虫偏偏就没听自己妈妈的话，乖乖鸟每天太阳晒屁股了才起来（按照这鸟巢的设计，晒屁股应该已经是中午了）。而毛毛虫每天还没亮就起来了，在草丛里玩耍，顺便吃点东西。</p><p>然而有一天，毛毛虫生病了，躺在床上没有起来，而乖乖鸟呢，因为每天起得晚没吃到虫虫，便决定早起一回，结果很遗憾，乖乖鸟还是没有遇到毛毛虫。从此它下定决心：“早起晚起都没虫，不如睡个好觉。”</p><p> <img src="https://hu33.github.io/images/飞羽作品集/（二十八）2.jpg" alt="《虫与鸟》"></p><p>而毛毛虫这边呢，因为每天早起都没被鸟儿吃，所以决定不当懒虫，每天起来看日出。</p><p>日复一日，年复一年。乖乖鸟和毛毛虫都长大了，它们同样有了自己的后代，乖乖鸟对小乖乖说：“早起的鸟儿没虫吃，起晚点儿没事。”毛毛虫也对小毛毛虫说：“早起的虫虫没被鸟吃，别当懒虫。”</p><p>可是，经验告诉我们小乖乖鸟和小毛毛虫可不会这么听话，它们自然也都是反其道而行之，同样永不见面。</p><p>还是可是，这么多中，总有些听话的乖宝宝听了话，如果是鸟宝宝听话的话，自然能吃到虫宝宝，如果是虫宝宝听话的话，那结果可就惨了。</p><p>所以，听话之前，先判断一下你是什么~</p><p><code>----------本篇完----------</code></p><p>##（二十九）《花·叶》</p><p> <img src="https://hu33.github.io/images/飞羽作品集/（二十九）.jpg" alt="《花·叶》"></p><p>瓜瓜在花盆里种下了一颗种子，正好是早春，瓜瓜一心一意地照顾这颗种子，每天幻想着不久后这颗种子会开出什么样的花朵。</p><p>过了好久好久，种子才刚刚发芽出来，一点点的嫩绿，却也让瓜瓜兴奋了好一阵子。不过秋天都到了，花盆里的植物也才长高了一点点，瓜瓜心想：“今年是看不到花了，看样子只有等明年才知道花会是什么样的，不过这样也好，能多点期待，多点想象。”</p><p>一眨眼又是一年了，原本种在花盆里的种子已经枝繁叶茂了，可偏偏就是不开花。瓜瓜有点失望了，可仍然很耐心地照顾着花盆里的植物，心里总是想着它会开出什么样的花，会是什么颜色的，什么形状的……</p><p>日复一日，年复一年，当年的小瓜瓜都已经长大了，可植物仍然没有开花。此时的花花已经成为了画家，专门画花的，他笔下的花各式各样，争奇斗艳，而原型都是这棵不开花的植物。</p><p> <img src="https://hu33.github.io/images/飞羽作品集/（二十九）2.jpg" alt="《花·叶》"></p><p>后来的后来，瓜瓜知道了原来他当年种下的种子是不会开花的，不过开不开花对他来说已经不重要了，因为种子早已在他的心中开了花，无数无数朵，都是那么美丽。瓜瓜庆幸当年没有刻意去查一下种子为什么不开花，不然怎么会在他心里开出这么多的花呢。</p><p>很多事情，都像这种子一样，也许本来就只有叶却没有花，我们不必刻意去找寻那朵花，只需静下心来想象，心里开出的花永远是最美、最灿烂的，即使现实的花已经不在了，心中的花却依旧盛开着，陪伴着我们，永远，永远……</p><p><code>----------本篇完----------</code></p><h2 id="三十-《井底之蛙》（一）"><a href="#三十-《井底之蛙》（一）" class="headerlink" title="(三十)《井底之蛙》（一）"></a>(三十)《井底之蛙》（一）</h2><p> <img src="https://hu33.github.io/images/飞羽作品集/（三十）.jpg" alt="《井底之蛙》（一）"></p><p>当年的井底之蛙，在听从建议后跳到井外，欣赏到了大自然辽阔的美。</p><p>若干年后，它的后代又回到了当年的那个井底，一只野鹿经过这口井，看到了呆在井底的青蛙，不禁嘲笑起来–哈哈，又是一只井底之蛙，难道你的祖先没告诉过你外面世界的辽阔与美丽吗？大自然是如此的美好，你怎么能只呆在那口枯燥乏味的井里呢？</p><p>小青蛙无奈地笑了笑，叹了口气：“大自然确认是美丽的，不过那是当年我祖先所在的那个时代，现在还能是如此吗？外面到处都是危险，那么多的农药，还有那么的捕蛙人，我还敢在外面吗？现在啊，只有这枯燥的井底才是我的栖身之地了。”</p><p>野鹿嘲笑青蛙胆小，不屑地说：“不就是一点小危险吗？比起大自然的美算什么，只要稍微注意一点就不会有事了嘛。”</p><p>话还没说完，只听见一声枪响，野鹿倒在猎人的子弹下，小青蛙坚信住在井底的信念了……</p><p><code>----------本篇完----------</code></p><h2 id="（三十一）《井底之蛙》（二）"><a href="#（三十一）《井底之蛙》（二）" class="headerlink" title="（三十一）《井底之蛙》（二）"></a>（三十一）《井底之蛙》（二）</h2><p> <img src="https://hu33.github.io/images/飞羽作品集/（三十一）.jpg" alt="《井底之蛙》（二）"></p><p>躲在井底的青蛙也一天一天长大了，有了自己的后代。两只小青蛙从小就被教育外面很危险，这个井底才是最安全的。</p><p>青蛙姐姐听了妈妈的话，乖乖地呆在井底，把井底当成她的整个世界，生活得倒也挺自在的。青蛙弟弟可就不听话了，一心想着去外面闯荡一回。</p><p>一天晚上，青蛙弟弟看着皎洁的月光，越发想到外面去玩了，正好青蛙妈妈已经睡熟了。弟弟就轻轻摇醒姐姐：“姐姐，姐姐，快起来啦，我们偷偷去外面玩几天好不好啊？”青蛙姐姐马上拒绝：“不行，不行，妈妈都说了不准了，外面很危险的，你出去会死的。”</p><p>青蛙弟弟苦苦央求，缠着青蛙姐姐陪他出去玩，可青蛙姐姐就是不愿意。青蛙弟弟没办法了：“你不去就算了，我一个人去了，哼！”说完，青蛙弟弟就朝井外跳去，姐姐喊了两声，弟弟理也不理。这时青蛙妈妈也醒了，看着调皮的儿子离开了井底，伤心地喊了两声，也实在不敢追去，小青蛙的背景渐渐远去……</p><p><code>----------本篇完----------</code></p><h2 id="（三十二）《井底之蛙》（三）"><a href="#（三十二）《井底之蛙》（三）" class="headerlink" title="（三十二）《井底之蛙》（三）"></a>（三十二）《井底之蛙》（三）</h2><p> <img src="https://hu33.github.io/images/飞羽作品集/（三十二）.jpg" alt="《井底之蛙》（三）"></p><p>小青蛙一出来，就感觉到了世界的辽阔，兴奋地叫了一阵。感觉到有点饿了，便跳进一片鸣叫声不断的田里，开始寻找自己的猎物。</p><p>田里的食物比井里的就是多些，小青蛙只一小阵子就吃饱了，躺在一片草地上悠闲地睡觉了。</p><p>一觉醒来，小青蛙感觉肚子疼痛，知道吃的东西不干净了，正想着该怎么办，已经被一双手抓住扔到一片漆黑的袋子里去了，还传来一句笑声：“今天收获不错诶，捡了这么多只被毒到的青蛙。”这下子小青蛙后悔死了，还怀念着看过的风景，遗憾地叹了口气。</p><p>小青蛙和其它的青蛙被拿出去准备卖了，小青蛙和其它青蛙都在谈论自己的经历，小青蛙听得入迷了，好像自己就经历了那些事，尽管被抓了，可经历的那些事确实都很精彩，尽管被抓了倒也值得了。</p><p>不久之后，小青蛙和另外一些青蛙都被卖了出去，因为小青蛙太小了，主人把它给自己的儿子拿去玩了……</p><p><code>----------本篇完----------</code></p><h2 id="（三十三）《井底之蛙》（四）"><a href="#（三十三）《井底之蛙》（四）" class="headerlink" title="（三十三）《井底之蛙》（四）"></a>（三十三）《井底之蛙》（四）</h2><p> <img src="https://hu33.github.io/images/飞羽作品集/（三十三）.jpg" alt="《井底之蛙》（四）"></p><p>小孩拿到小青蛙后对它可好了，带它去草地上玩，跟着它一起蹦蹦跳跳，还给它好多零食。小青蛙感觉小孩真好，自己真是太幸运了，便也和小孩玩得很好。</p><p>不过没多久，小青蛙还是想念自己的妈妈和姐姐了。小孩似乎懂得了小青蛙的想法，几天之后，他就把小青蛙放了，要它去寻找自己的家。</p><p>小青蛙对小孩感激涕零，一蹦一跳地走了，路上，小青蛙又遇到了很多危险，不过小青蛙最终还是回到了井边。小青蛙看了一眼外面的世界，闭上眼睛美美地回忆了一番，跳回井里了。</p><p>看着儿子回来了，青蛙妈妈兴奋地哭了，抱着小青蛙就不放，青蛙姐姐看着回来的弟弟说：“外面是很危险吧，不过回来了就好。”小青蛙笑了笑：“危险是危险，不过更精彩啊！为了这些精彩，出去还是值得的。”</p><p>青蛙姐姐看了看外面的天空，若有所思，她似乎也在等待某一个夜晚了……</p><p><code>----------本篇完----------</code></p><h2 id="（三十四）《铅笔和橡皮》"><a href="#（三十四）《铅笔和橡皮》" class="headerlink" title="（三十四）《铅笔和橡皮》"></a>（三十四）《铅笔和橡皮》</h2><p> <img src="https://hu33.github.io/images/飞羽作品集/（三十四）.jpg" alt="《铅笔和橡皮》"></p><p>瘦铅笔和胖橡皮从小就是敌人，不爱在一起玩，可偏偏主人把他们放在了一起。</p><p>铅笔盒橡皮整天都会在文具盒里吵架，有得争的，没得争的他们都能争得天翻地覆。终于有一天，他们彻底爆发了，铅笔不停地画，橡皮使劲地擦，不知不觉铅笔已经短到快没了，橡皮也用得差不多了。</p><p>就在他们的生命要因为这场战争而消失的时候，他们似乎醒悟过来了。铅笔先开的口：“诶，橡皮，我不想画了，你也别擦了。”橡皮想了想：“现在的我们已经没什么用了，不如快点离开吧，主人不会要我们的了。”</p><p>片刻的沉默，铅笔用最后的生命写下了大大的三个字–对不起。橡皮看了看，微微笑了一下，这次是他第一次没有擦去铅笔写的字，然后默默地把这三个字的周围擦得干干净净的。</p><p>白纸上，除了这三个字，什么也没留下……</p><p><code>----------本篇完----------</code></p><h2 id="（三十五）"><a href="#（三十五）" class="headerlink" title="（三十五）"></a>（三十五）</h2><p> <img src="https://hu33.github.io/images/飞羽作品集/（三十五）.jpg" alt=""></p><p>我寻找着光明</p><p>在无尽的黑夜</p><p>繁星闪烁</p><p>留下一夜的梦</p><p>纵使爬上</p><p>那高百尺的危楼</p><p>也摘不到</p><p>最近的那颗星</p><p>我迷茫地望着</p><p>等一颗流星划过</p><p>就一刻</p><p>便已足够</p><p>也许</p><p>你只是夜空的流萤</p><p>却成了</p><p>我梦里的流星</p><p>带着我的愿望划过</p><p>留给了我满眼的闪烁</p><p>那是一片</p><p>满是萤火虫飞舞的夜空</p><p>闪着</p><p>闪着</p><p>。。。。。。</p><p><code>----------本篇完----------</code></p><h2 id="（三十六）《月亮》"><a href="#（三十六）《月亮》" class="headerlink" title="（三十六）《月亮》"></a>（三十六）《月亮》</h2><p> <img src="https://hu33.github.io/images/飞羽作品集/（三十六）.jpg" alt="《月亮》"></p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>地球人都以为月亮从古代一直存在，陪伴大家至今。其实才不是呢，大家都被骗了。</p><p>月亮的生命很短暂，一般都只有一个月左右，月亮在死去的那天夜里会生出一个月亮来，新的月亮会代替她妈妈的工作，慢慢长大、长大，然后再老去，又生出一个月亮。</p><p>其实月亮长大是很明显的事嘛，最开始那么小，然后慢慢变圆。可人类就是傻，偏偏以为月亮会魔术，自己变大又变小。</p><p>可是，意外总是在不经意间就发生了。三十日晚，月亮妈妈生出的不是女儿，而是一对双胞胎，准确的说法应该是龙凤胎。这下可麻烦了，一个天空可容不得两个月亮啊，不然肯定会打架的，即将死去的月亮妈妈灵机一动，要他们俩一人在天空呆几个小时，没有出现的那个就躲进云里。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>不过这当弟弟的可没这么听话（刚刚忘说了，他们是姐弟俩），这天夜晚本该姐姐值班的，可弟弟偏偏要出来玩，这姐姐就不高兴了，值班是我的事，你来瞎搅和干啥呀，就要弟弟躲到云里去。</p><p>弟弟可没那么听话，你越说他越不听，在天空到处转悠，划出了好多漂亮的尾巴。这一划不要紧，可是让地上的人看见了，你想啊，这么美的东西谁不想要啊，于是各自想办法来套住这个调皮的月亮。</p><p> <img src="https://hu33.github.io/images/飞羽作品集/（三十六）2.jpg" alt="《月亮》"></p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>人的智商往往是偏低的，这话一点不假。最主要的是，这月亮出来的时代正是草原智商第一高天才狼灰太狼的时代。灰太狼倒不要紧，他只对羊感兴趣。遗憾的是，他有一个爱美的红太狼老婆。</p><p>红太狼第一次看到这月亮的时候就深深地被迷住了，马上用平底锅对着灰太狼：“灰太狼你给我听着，要是你不能帮我把那个带尾巴的月亮弄给我，你就永远别回来了！”</p><p>于是，灰太狼踏上了收月之旅。</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>作为草原物理竞赛、化学竞赛及数学竞赛的冠军，灰太狼在半小时内就发明出了七七四十九项抓月亮的东西。</p><p>实践证明，灰太狼的发明是多余的，有尾巴的月亮因为飞得太快一不小心就撞在狼堡上，晕了。</p><p>红太狼见月亮来了，一个劲地兴奋。可才高兴了一下就犯难了：“这么大一个月亮，怎么才能做自己的装饰品呢？”</p><p>不一会儿灰太狼也回来了，正想说有尾巴的月亮不见了就发现月亮到自己家了，于是钻进实验室开始分析解剖此月亮的方法。</p><p> <img src="https://hu33.github.io/images/飞羽作品集/（三十六）3.jpg" alt="《月亮》"></p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>红太狼和灰太狼还在想着办法，小灰灰就凑到了月亮旁边，轻轻闻了一下：“哇！好香啊！”于是忍不住一口咬下去，结果越吃越有味，月亮被咬出了很多的缺口，终于给疼醒来了。月亮见自己一身残缺的模样，哭着飞走了。</p><p>但是因为被咬的缺口实在太多了，又飞得太快，尾巴月亮就这样解体了。很多碎片就变成了星星，剩下的成了流星，散布在了夜空。</p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>从此，天上又只有了一个月亮，继续以月为周期繁衍下去。</p><p><code>----------本篇完----------</code></p><h2 id="（三十七）《青蛙王子和青蛙公主》"><a href="#（三十七）《青蛙王子和青蛙公主》" class="headerlink" title="（三十七）《青蛙王子和青蛙公主》"></a>（三十七）《青蛙王子和青蛙公主》</h2><p> <img src="https://hu33.github.io/images/飞羽作品集/（三十七）.jpg" alt="《青蛙王子和青蛙公主》"></p><p>很久很久以前，小月从田里捉到了两只蝌蚪，因为她听外婆说过，蝌蚪长大了可以变成青蛙王子，那样她就可以和王子生活在一起了。</p><p>日子一天天地过去，小月心里想着，王子会是什么样呢，一定很帅气吧。不过，她可没想过这两只蝌蚪是公是母，还想着有两个王子让她选呢。</p><p>蝌蚪不知不觉地长成了青蛙，这会儿小月只需等待某个早晨醒来会看到她的王子。</p><p> <img src="https://hu33.github.io/images/飞羽作品集/（三十七）2.jpg" alt="《青蛙王子和青蛙公主》"></p><p>那一天果然来了，清晨，小月睁开眼睛便看到了变成王子的青蛙，可是王子旁边还有一个公主。这下小月不知该怎么办了，她可没想过会出现一个王子和一个公主啊。</p><p>这时王子说话了：“主人你好，感谢你对我们的照顾，不过这会儿我们该离开了。再见。”</p><p>小月正想说着什么，可这会儿她觉得王子和公主才是一对的，自己怎么好意思留下王子呢，下次一定只能抓一只青蛙作王子了。</p><p> <img src="https://hu33.github.io/images/飞羽作品集/（三十七）3.jpg" alt="《青蛙王子和青蛙公主》"></p><p>又过了不久，小月已经从失去王子的悲伤中恢复过来了，毅然决然地再去田里捉蝌蚪。这次正好看见一只蝌蚪，小月兴奋地把它抓回了家里，等待着它长成王子，这一次，她依然以为肯定是王子而没考虑过公主。</p><p>不过小月还没来得及高兴，以前的青蛙王子和青蛙公主就来了，很不好意思地说：“不好意思，主人，这是我们的儿子，他已经在出生时就和另一只青蛙订婚了，所以……”小月没办法啊，只有把养成王子的青蛙还给青蛙夫妇。</p><p>这之后，小月再也没有去捉蝌蚪当王子，因为她知道，那是一个不属于自己的世界，她要找的是人类世界的王子。</p><p>又是很久很久之后，青蛙王子一家搬到小月家来住了，因为外面太危险了，这儿更适合他们。</p><p><code>----------本篇完----------</code></p><h2 id="（三十八）《蜡烛和灯》"><a href="#（三十八）《蜡烛和灯》" class="headerlink" title="（三十八）《蜡烛和灯》"></a>（三十八）《蜡烛和灯》</h2><p> <img src="https://hu33.github.io/images/飞羽作品集/（三十八）.jpg" alt="《蜡烛和灯》"></p><p>从前的从前，这个世界上还没有灯，蜡烛是全世界所有人最崇敬的东西，因为它能在黑夜带来光明。不管是诗人学者还是商人，都说蜡烛是样不可多得的好东西。</p><p>从前的后来，有个让所有蜡烛都讨厌的人出现了，叫爱迪生。因为他发明的灯让蜡烛失去了对光的主宰地位。</p><p>可是蜡烛并不服输，坚持认为自己比灯伟大，于是蜡烛王国就派人和灯王国谈判，输的一方将永远退出光的世界。</p><p>蜡烛方说得头头是道，紧紧围绕它们牺牲自我的伟大奉献精神谈论，希望以自己的精神来打败灯。而灯则围绕自己的光有多亮，又不会像蜡烛一样燃一会儿就没了……</p><p><img src="https://hu33.github.io/images/飞羽作品集/（三十八）2.jpg" alt="《蜡烛和灯》"></p><p>最终，电灯王国辩论得更有说服力，蜡烛王国决定从这个世界上消失。就在此时世界忽然停电了，正当电灯们没辙时，蜡烛们燃烧发出了光，一切又是那么的安详了。</p><p>蜡烛和电灯终于懂了，这个世界上，它们都是不可或缺的。其实他们都是发光为了照亮世界，只是生命长短不一罢了，又何苦非要比较出一个胜负来呢？</p><p><code>----------本篇完----------</code></p><h2 id="（三十九）《萤火虫的灯》"><a href="#（三十九）《萤火虫的灯》" class="headerlink" title="（三十九）《萤火虫的灯》"></a>（三十九）《萤火虫的灯》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（三十九）.jpg" alt="《萤火虫的灯》"></p><p>黑夜降临了，森林的草丛里，飞舞着几只萤火虫，他们拥有上天赐予的礼物–灯，但他们并不知道。</p><p>一只蚂蚁此时还没有回家，很遗憾，他确信自己迷路了，萤火虫火火正好从蚂蚁上方飞过。虽然只是微弱的光，但蚂蚁就是凭借那一丁点儿光认出了回家的路，蚂蚁朝火火大喊了一声：“谢谢你了萤火虫。”</p><p>火火像丈二的和尚摸不着头脑–刚才那只蚂蚁谢我干什么啊，我没做什么事。</p><p><img src="https://hu33.github.io/images/飞羽作品集/（三十九）2.jpg" alt="《萤火虫的灯》"></p><p>不一会儿，萤火虫飞到了田边，青蛙妈妈正借着月色给小蝌蚪织衣服，等衣服织好让小蝌蚪穿上，它们就会变成青蛙了。可是月色太微弱，青蛙妈妈一不小心织错了，也不知从何改起，无奈地叹了口气：“唉，小蝌蚪们又得晚几天变青蛙了。”</p><p>萤火虫火火正飞累了，停在了青蛙妈妈的旁边，这不，青蛙妈妈不一会儿就改过来织错的衣服了，想着小蝌蚪马上就能变成青蛙，别提多高兴了，“呱呱”地向萤火虫道了谢。萤火虫又奇怪了，我刚刚是没做什么事啊，为什么青蛙妈妈要向我道谢呢？</p><p>……</p><p><img src="https://hu33.github.io/images/飞羽作品集/（三十九）3.jpg" alt="《萤火虫的灯》"></p><p>萤火虫这一晚飞过了很多地方，无论他飞到哪儿，总会听到道谢的声音。火火不知道大家为什么向他道谢，不过想到反正自己能帮助大家，那飞再久也无所谓了。</p><p>从此以后，每天夜晚萤火虫都会不停地在夜空下飞舞，知道日出才闭上眼休息。他们不知道，自己的身上有种叫“灯”的东西。</p><p>我想，我们每个人都是一只萤火虫，有着一盏只属于自己的独特的灯，那么，我们把这盏灯发出的萤火，分享给别人了吗？</p><p><code>----------本篇完----------</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本作品集为飞羽原创，18岁生日时飞羽将其作为礼物赠与本人，现将该作品摘抄并记录在该博客中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;（二十一）《世界末日》&quot;&gt;&lt;a href=&quot;#（二十一）《世界末日》&quot; class=&quot;headerlink&quot; title=&quot;（二十一）《世界末日》&quot;&gt;&lt;/a&gt;（二十一）《世界末日》&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://hu33.github.io/images/飞羽作品集/（二十一）.jpg&quot; alt=&quot;《世界末日》&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://hu33.tech/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="作品集" scheme="http://hu33.tech/tags/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
      <category term="礼物" scheme="http://hu33.tech/tags/%E7%A4%BC%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>飞羽作品集（上）</title>
    <link href="http://hu33.tech/2019/01/13/%E9%A3%9E%E7%BE%BD%E4%BD%9C%E5%93%81%E9%9B%86%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://hu33.tech/2019/01/13/飞羽作品集（上）/</id>
    <published>2019-01-13T13:55:22.206Z</published>
    <updated>2019-01-20T13:19:09.142Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本作品集为飞羽原创，18岁生日时飞羽将其作为礼物赠与本人，现将该作品摘抄并记录在该博客中。</p></blockquote><h2 id="（一）《淡淡》"><a href="#（一）《淡淡》" class="headerlink" title="（一）《淡淡》"></a>（一）《淡淡》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（一）.jpg" alt="《淡淡》"></p><a id="more"></a><p>人生是一本最短也最长的书，</p><p>真实中夹杂着虚幻与飘无。</p><p>我们不停地写着，头脑麻木，</p><p>突然发现，</p><p>无数的喜悦与哀愁，都在不停地重复。</p><p>也许我们早该醒悟，</p><p>去寻找人生真正的归宿。</p><p>你的欢笑是我的翅膀，</p><p>带我飞离书中的荒芜。</p><p><code>----------本篇完----------</code></p><h2 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a>（二）</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（二）.jpg" alt=""></p><p>两滴雨住在云里，整日悠闲，四处闲逛。</p><p>一天，一滴雨被吹过的风带走了，还没来得及和自己的朋友道别就落到了一片池塘里。原本它以为云中的生活才是最舒适安逸，没想到这池塘是如此迷人–鱼儿们自由嬉戏，一两只蜻蜓在池面飞过，……雨滴喜欢上了这里的生活。</p><p>然而，池塘中的雨滴还想着云中的雨滴，它不能让它的朋友孤单地生活在云里，不过一旦回去，就不知道什么时候才能再落到这片池塘。纠结了一番后，池塘的雨滴还是觉得朋友更重要，便努力地吸收阳光，希望将自己蒸发回云里。</p><p>云中的雨滴同样在想着它的朋友，它在担心朋友落下后生活会不会很困苦，它不能独自在云中过着安逸的生活，让自己的朋友受苦。于是，它努力地挣扎着，一心想落下去寻找自己的朋友，毕竟，两个一起受苦比一个单独受苦要好过些。</p><p>终于有一天，池塘中的雨滴吸收了足够多的阳光，兴奋地飞上天去寻找自己的朋友，也就在那一刻，云中的雨滴挣脱了束缚向下落去。他们相遇在半空，它笑了，它也笑了，因为尽管彼此依旧分离，但心中那一份友谊已在半空相遇的那一瞬定格。</p><p>（这是童话，亦菲童话）</p><p><code>----------本篇完----------</code></p><h2 id="（三）《风筝与风》"><a href="#（三）《风筝与风》" class="headerlink" title="（三）《风筝与风》"></a>（三）《风筝与风》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（三）.jpg" alt="《风筝与风》"></p><p>角落里有一只风筝，身上布满了灰尘。</p><p>一天，风筝实在受不了这无聊的生活，偷偷跑出去寻找能带给风筝天堂般快乐的风。</p><p>风筝先飞到大树的枝头，期盼地问大树：“大树爷爷，您知道风在哪儿吗？”大树看了看摇曳着的树叶：“看，这不就是吗？”风筝挠了挠头：“哪有啊？除了树叶什么都没有嘛，大树爷爷肯定是看我太小，在逗我玩呢，我还是去别处寻找吧！”</p><p>风筝飞啊，飞啊，飞到了云朵旁边，风筝急切地问云朵：“云朵姐姐，你知道风在哪儿吗？”云朵惊讶地看着风筝：“哈哈，你傻呀，风不就在这儿吗？”风筝又纳闷了：“明明就没有嘛，你们怎么都逗我玩呢！”风筝想找云朵问清楚，可云朵已经捂着嘴偷笑着飘走了。</p><p>不知不觉，风筝已经飘到了天堂，这儿一片欢声笑语，只有风筝闷闷不乐，因为它还是没有看到风，它在想风不是能带给他天堂般的快乐吗？可是自己已经到天堂了，怎么还是一点都不快乐啊！风筝受不了了，大喊了一声：“风啊，你到底在哪啊！”只听四周传来声音：“呵呵，傻孩子，你以为是谁带你到这天堂上来的啊？”</p><p>风筝突然明白了，原来风一直就在它身边，只是自己看不到罢了。</p><p>我们每个人都是风筝，总有那么一些人是我们的风，我们只顾着寻找他们，却不知道其实他们一直在我们身边，默默地帮助着我们，不离，不弃……</p><p><code>----------本篇完----------</code></p><h2 id="（四）《逆流的溪水》"><a href="#（四）《逆流的溪水》" class="headerlink" title="（四）《逆流的溪水》"></a>（四）《逆流的溪水》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（四）.jpg" alt="《逆流的溪水》"></p><p>一条小溪哗啦啦地流着，带着欢声与笑语。</p><p>突然有一天，溪水在想自己会去哪，便问周围的大树自己会去哪儿。</p><p>大树说：“流到河里啊！”</p><p>溪水又问：“然后呢？”</p><p>“流去江里。”</p><p>“再然后呢？”</p><p>“流到大海里。”</p><p>“再然后呢？”</p><p>“到大海里就是你们最终的归宿，你们可以尽情地咆哮，也可以平静地生活。总之，你们是最伟大的。”</p><p>溪水有些兴奋：“最伟大的？那我们该做些什么事呢？”</p><p>大树笑呵呵的，“你们流入大海后就什么都不用做了，没有什么能再阻拦你们，连太阳也蒸发不了你们。”</p><p>溪水倒是有点失落了，它就是想着能多做些什么才不断前行，如果前方是没有意义的伟大，它又何苦盲目前行呢？于是，溪水毅然决然往回流，不顾一切阻挠。</p><p>溪水艰苦地逆流着，前方的路越来越窄了，溪水看到前方的路快到尽头了，源头的后方是一片荒凉。溪水勇敢地冲了过去，冲破了源头，冲向它不曾见过的一片荒凉–它以前只看到溪水流过的地方有花有草，从未知道源头后面是日此干涸。</p><p>终于，溪水放弃了大海的伟大，成就了源头背后的绿意盎然。</p><p><code>----------本篇完----------</code></p><h2 id="（五）《遥夜》"><a href="#（五）《遥夜》" class="headerlink" title="（五）《遥夜》"></a>（五）《遥夜》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（五）.jpg" alt="《遥夜》"></p><p>漫步于无边的原野，</p><p>望见天空繁星点点。</p><p>我擦亮憧憬的双眼，</p><p>等待着流星的出现。</p><p>抬头那一瞬间，</p><p>浮现的是你微笑的脸。</p><p><code>----------本篇完----------</code></p><h2 id="（六）《猫·狗·鼠》"><a href="#（六）《猫·狗·鼠》" class="headerlink" title="（六）《猫·狗·鼠》"></a>（六）《猫·狗·鼠》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（六）.jpg" alt="《猫·鼠·狗》"></p><p>很久很久以前，猫和鼠是朋友，漂泊在外，狗则住在安逸的屋子里。</p><p>寒冬到了，猫和鼠觉得在外面过不下去了，边去投靠住在温暖屋子里的狗。狗见它们可怜，便瞒着助人偷偷把猫和老鼠带回家里。</p><p>猫和鼠在狗的家里住下后生活非常闲适，因为屋里暖暖的，而且狗每次都会分一些吃的给它们，有时狗甚至只吃骨头，把肉都给猫和鼠吃。然而，猫和鼠越发地贪心了，猫有时就趁狗不在时偷吃助人家的鱼，老鼠更过分，不仅偷吃，还打了很多个洞，把自己吃不下的都藏了起来。忠诚的狗怎么会想到自己如此真心对待的两个朋友会这样对待它的主人呢，所以依然对猫和狗很好，还教他们很多本领，希望它们以后可以像它一样看家。</p><p><img src="https://hu33.github.io/images/飞羽作品集/（六）2.jpg" alt="《猫·鼠·狗》"></p><p>终于有一天，鼠将“魔爪”伸向了鱼，这让猫有些生气了，便对鼠说：“你有那么多吃的了，为什么还要把我的鱼也搬到你洞里去？”老鼠十分不屑：“鱼又不是你一个人的，凭什么我不能吃！”这下猫火了，干脆一拍两散，向狗告发了老鼠的恶行，并说证据都在洞里面。这下老鼠自知没办法了，躲进洞里去不敢出来。从此以后狗一见老鼠就非常仇恨地扑过去抓它，当然，几乎没抓到过，所以才说狗拿耗子–多管闲事。其实这不是闲事，是狗要报仇哩。</p><p>鼠躲进洞之后，一心想着要报猫的告发之仇。可它又打不过猫，便在猫偷吃鱼的时候钻出洞出现在狗的面前，待狗追它时把狗带到猫吃鱼的地方再钻进洞里。狗见猫在偷吃鱼，气不打一处来–我对你不薄啊，你却这样对我。便猛地扑上去要咬猫，猫幸好有爬树这一招才侥幸逃脱。它知道是鼠害它被狗发现偷吃鱼的，所以，整日想着要吃掉老鼠报仇。</p><p>从此以后，狗一见猫就疯狂地扑上去捉，猫一见老鼠就疯狂地扑上去捉。猫一见狗就马上爬上树，鼠一见狗和猫就钻到洞里去。</p><p><code>----------本篇完----------</code></p><h2 id="（七）《蝶与蚕》"><a href="#（七）《蝶与蚕》" class="headerlink" title="（七）《蝶与蚕》"></a>（七）《蝶与蚕》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（七）.jpg" alt="《蝶与蚕》"></p><p>在众多的故事里，都是碟笑蚕丑陋，而结果是蝶由蚕破茧而来。很可惜，在这个故事里，角色转换了一下，由蚕来笑蝶了。this is why？因为这是个现实的童话，于人类而言，能吐丝的蚕才是有用的，整日在花丛中打转的蝴蝶简直一文不值。</p><p>蚕便笑话蝶：“你看你有什么用，整日虚度光阴，在那些花丛中飞舞着有什么用呢？最后不得落地为土，还得落花怨蝶？”蝶一想，蚕说得确实有道理，自己的人生似乎就在花丛飞舞中虚度了，蝴蝶越想越惭愧，便飞进了一棵树洞，整日练着吐丝，然而终未吐出一根丝来。</p><p>终于有一天，蝴蝶受不了吐不出丝的生活，飞去问蚕如何吐丝，此时的蚕已吐出丝变茧，裹住了自己。蝴蝶就一直在外面等着蚕出来好问它要怎么吐丝，结果自然是–蝴蝶看见另一只蝴蝶破茧而出，它这才明白了，自己就由蚕变来的。</p><p><img src="https://hu33.github.io/images/飞羽作品集/（七）2.jpg" alt="《蝶与蚕》"></p><p>既然丝已吐尽，何苦再为难自己呢？吐丝的意义只在于对人类有用， 做蚕做蝴蝶，于自己本身有何区别？于是蝴蝶选择做回自己本身，不再想吐丝的事，尽情飞舞在花丛中。</p><p>其实，于蚕于蝶，它们的生活都是有意义的，其区别只在于对人是否有益。活出自己，便已足矣。呆在家中看书是一种美，旅游在外也是一种美。无数种美的交织，成就了认识的幸福。</p><p><code>----------本篇完----------</code></p><h2 id="（八）《幻·非幻》"><a href="#（八）《幻·非幻》" class="headerlink" title="（八）《幻·非幻》"></a>（八）《幻·非幻》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（八）.jpg" alt="《幻·非幻》"></p><p>晴天下雨，</p><p>雨天天晴。</p><p>这不是天气，</p><p>而是–心情。</p><p>白天天黑，</p><p>黑夜天亮。</p><p>这不是时间，</p><p>而是–生活。</p><p><code>----------本篇完----------</code></p><h2 id="（九）"><a href="#（九）" class="headerlink" title="（九）"></a>（九）</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（九）.jpg" alt=""></p><p>迷路，</p><p>有时也是一种艺术，</p><p>可惜，</p><p>一般人永远无法理解，</p><p>幸运的是，</p><p>我邂逅了这种艺术，</p><p>日复一日年复一年。</p><p><code>----------本篇完----------</code></p><h2 id="（十）"><a href="#（十）" class="headerlink" title="（十）"></a>（十）</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（十）.jpg" alt=""></p><p>我梦见自己在做梦……</p><p>梦中的梦中的我在梦游。</p><p>如鬼如魂，无人理会。</p><p>当我醒时，我亦梦游。</p><p>当我梦游，我仍醒着。</p><p>（梦中的我于梦游中写下之，不知应从左往右念，还是从右往左念）</p><p><code>----------本篇完----------</code></p><h2 id="（十一）"><a href="#（十一）" class="headerlink" title="（十一）"></a>（十一）</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（十一）.jpg" alt=""></p><p>我是一个球，很复杂的球。</p><p>从我出生的那一刻起，我就会跑了，我看着前方是一片光明，便不停向前追逐着，然而有时前方会闪过一个影子拦住我的视线，在我靠近它的时候它又消失了。</p><p>我跑着跑着就累了，在路上挥洒汗水，无论我如何跑，都只能看到那片光明，始终无法抵达。</p><p>终于，我不再刻意去追寻那片光明，静静地享受生活，享受同时存在的白天与黑夜。</p><p>我是地球，轨迹是圆……</p><p><code>----------本篇完----------</code></p><h2 id="十二-《不要和陌生人说话》"><a href="#十二-《不要和陌生人说话》" class="headerlink" title="(十二)《不要和陌生人说话》"></a>(十二)《不要和陌生人说话》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（十二）.jpg" alt="《不要和陌生人说话》"></p><p>小猪要去上学了，小猪妈妈提醒它：“猪儿，千万别和陌生人说话，免得被骗走卖了。”</p><p>小猪听从了猪妈的叮嘱，在路上，它遇到了同是去上学的刺猬，刺猬主动上前去打招呼：“嘿，小猪，去上学吗？咱一起去吧！”小猪吓得躲到一边：“不行不行，我妈妈说了不能和陌生人说话，更别说一起去上学了。”说完匆匆走了。</p><p>跑着跑着，兔子从草丛跳了出来：“小猪小猪，上个学干嘛这么急匆匆的，又不会迟到。”小猪丢下一句：“不能和陌生人说话。”又向前跑去。</p><p>小猪就这样一直跑到了学校， 教室里面它一言不发，心里就是猪妈说的那句“不要和陌生人说话。”</p><p>渐渐地，教室里的同学们都反感起来了，班长小猴就对班主任山羊大伯说小猪不和它们说话。山羊大伯去问小猪：“你怎么都不和新同学们说话呢？才开学第一天你们不会就闹矛盾了吧？”</p><p>小猪很委屈：“我没和它们闹矛盾，但是我妈说了不要和陌生人说话呢！”</p><p>山羊大伯哈哈大笑：“你出生的那时候你认识你妈妈吗？”</p><p><img src="https://hu33.github.io/images/飞羽作品集/（十二）2.jpg" alt="《不要和陌生人说话》"></p><p>小猪想了想，摇摇头说：“不认识。”</p><p>“那不就是了，你出生时所有的人都是陌生人，但你还是慢慢熟悉了它们，你的亲人们渐渐不再是陌生人了，不是吗？”</p><p>小猪点了点头：“嗯。”</p><p>“所以嘛，你要和同学们多讲话，所有熟悉的人都是从陌生人开始的。”小猪若有所思，在接下来的时间里慢慢和所有的同学都成了朋友。</p><p>（若干年前，我们彼此都是陌生人。幸运的是，我们勇敢地敞开了心扉。从此，希望我们能是一辈子的朋友。因为能从陌生人变成朋友，是一种缘分。）</p><p><code>----------本篇完----------</code></p><h2 id="（十三）"><a href="#（十三）" class="headerlink" title="（十三）"></a>（十三）</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（十三）.jpg" alt=""></p><p>我看过这么一个故事，一头老牛正在吃草，背上的一个蚊子对它说：“老牛啊，我要走了了。”老牛看都没看，继续吃草。蚊子又耐着性子说：“老牛啊，我要走了啊！”老牛依然不理会蚊子。蚊子有点生气：“喂，老牛，我要飞走了！”老牛终于发话了：“你要走就走吧！你来时我没注意到，你走了我又何须理会。”</p><p>也许我们在许多人心中只是无足轻重的过客，既然要走，何须让每个人都知道呢。然而，有时不经意间就会有对我们很重要的人出现在我们身旁，仅因为我们没注意到他们的到来而任由他们离开，不予理会吗？生命中总有那么多重要的人来到又离去，要想不后悔失去，现在赶紧珍惜吧！可怕的不是没注意到他们的到来，而是在他们离开之后仍无动于衷或茫然未醒。</p><p><code>----------本篇完----------</code></p><h2 id="（十四）《爱轨》"><a href="#（十四）《爱轨》" class="headerlink" title="（十四）《爱轨》"></a>（十四）《爱轨》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（十四）.jpg" alt="《爱轨》"></p><p>两根永世不相亲近的铁轨</p><p>让人们一直误以为</p><p>它们彼此充满仇恨</p><p>一样的冰冷</p><p>一样的固执</p><p>一样的从不理会</p><p>其实</p><p>火车驶过之时</p><p>它们都借着枕木</p><p>感受彼此咣咣铛铛的</p><p>心跳的速度</p><p>即使延伸至千里</p><p>也从未停止</p><p>而且</p><p>两根铁轨都不偷懒</p><p>谁也不肯</p><p>偷偷缩回自己的肩头</p><p>不让对方</p><p>承受多一丝的沉重</p><p>（许多人总奇怪我为何爱看铁轨，我只是为它们的从未交汇却不离不弃而沉醉。人们总为它们可望而不可及心碎，却不知它们心灵早已依偎。）</p><p><code>----------本篇完----------</code></p><h2 id="（十五）《阳光照不到的角落》"><a href="#（十五）《阳光照不到的角落》" class="headerlink" title="（十五）《阳光照不到的角落》"></a>（十五）《阳光照不到的角落》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（十五）.jpg" alt="《阳光照不到的角落》"></p><p>在一处偏僻又荒凉的地方，有一个阴暗的角落，太阳每天东升西落，却总是照不到这个角落。</p><p>这个角落就很伤心，因为它对温暖的阳光总是可望而不可及。它就对蚂蚁感叹它的伤心，蚂蚁听了对角落很是同情，便喊了一大群同伴去搬阳光，可阳光一搬到靠近角落的地方就消失了。</p><p>蚂蚁又去找老鼠帮忙，老鼠就说：“我在墙上开个洞，阳光就能从后方射进角落了。”角落忙说不可：“这不是要凿穿我的身体吗？怎么能行呢？”</p><p>老鼠又去找聪明的小猴帮忙，小猴就说要风帮忙把阳光吹进来吧！大家一听立马去找风，可是无论风用多大的劲，阳光还是吹不进角落，风说别急，它去求太阳照一下角落。</p><p>大家怀着期待等着风去说服太阳，可是尽管太阳很为大家的友情感动，但却不能改变运行的轨迹，不然地球很多地方都会遭殃的。动物们有些失望，但角落安慰它们：“没事的，你们已经尽力了，也许我和阳光这辈子没缘吧！”</p><p><img src="https://hu33.github.io/images/飞羽作品集/（十五）2.jpg" alt="《阳光照不到的角落》"></p><p>第二天一早醒来，角落就感觉阳光暖暖地照在身上，这可不是太阳变轨哩，而是动物们用反光镜把阳光照过来的，友谊的力量总是那么伟大，总是不能改变太阳的轨迹，也能改变阳光的方向。</p><p>角落开心地笑了，不仅因为身上暖暖的，更因为心里暖暖的，能有这样一群好朋友，即使身体感觉不到阳光也绝不会寒冷的，因为心里依旧洒满了阳光。</p><p><code>----------本篇完----------</code></p><h2 id="（十六）"><a href="#（十六）" class="headerlink" title="（十六）"></a>（十六）</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（十六）.jpg" alt=""></p><!-- more --><p>“是时光</p><p>将我凝固；</p><p>还是我</p><p>将时间停住。“</p><p>当树的年轮不再重复</p><p>我惟愿漫步</p><p>于记忆中那片</p><p>若影若现的荒芜</p><p><code>----------本篇完----------</code></p><h2 id="（十七）"><a href="#（十七）" class="headerlink" title="（十七）"></a>（十七）</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（十七）.jpg" alt=""></p><p>我们都是人生路上的过客，</p><p>路经彼此生命中的沼泽。</p><p>有些沼泽我们轻轻踏过，</p><p>有些沼泽我们越陷越深。</p><p>我陷在谁的沼泽里，</p><p>谁又为我的沼泽所困。</p><p>如梦若然，</p><p>待醒已晚。</p><p><code>----------本篇完----------</code></p><h2 id="（十八）《蜗牛》"><a href="#（十八）《蜗牛》" class="headerlink" title="（十八）《蜗牛》"></a>（十八）《蜗牛》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（十八）.jpg" alt="《蜗牛》"></p><p>有些动物天生就是官二代，像老虎；有些动物天生就是富二代，像蜗牛–一出生就有房子。</p><p>蜗牛的房子以前是很大的，不像现在只可以住它自己一个。这责任要归咎于蜗牛的祖先。</p><p>那是很久很久以前，所有的动物都住在原始森林里，动物里有四大天王，它们分别是狮子、老虎、大象和蜗牛（别惊讶，那时的蜗牛真的很大）。狮子和老虎爱欺负甚至杀死其他的动物，而大象和蜗牛则选择吃素不爱杀生。</p><p>这一天，狮子和老虎心血来潮，决定来一次大杀戮，吃一顿好的。小动物们可着急了，四处逃窜，但很难摆脱强大的狮子和老虎，便纷纷向蜗牛求救，钻进蜗牛巨大的房子里。虽说蜗牛不杀生，可是它很讨厌有其他的动物到它的房子里，便要赶它们出去。动物们可怎么敢出去啊，外面便是狮子和老虎，出去不等于送死吗？可是蜗牛可管不了这么多，态度非常强硬地赶动物们出去。</p><p><img src="https://hu33.github.io/images/飞羽作品集/（十八）2.jpg" alt="《蜗牛》"></p><p>小兔子第一个妥协了，委屈地走了出去，刚出去一下就被吃掉了，随着小兔从拥挤的房里走出去，房子变小了一点。动物们见小兔的悲惨遭遇更加不敢出去了，可蜗牛态度非常蛮横，说再不出去就让老虎狮子进来了。动物们失望了，一个一个走出蜗牛的房子，随着它们的走出，蜗牛的房子越变越小，最后只能容纳它自己了。</p><p>走出去的动物中属老鼠最聪明，马上去求救大象，钻进了大象的长鼻子里，没想到大象却因此死了，这也让大家发现了大象的弱点。</p><p>从此，四大天王就只有狮子和老虎可以称王了，一个森林之王，一个万兽之王。大象看到老鼠就非常惊恐，至于蜗牛，失去了大大的房子，开始受其他动物的欺凌，只能经常把头缩进壳里。也许这就是报应吧，谁让它不救那些小动物呢。</p><p>就这么一次杀戮，让四大天王只剩两个。也许若干年之后，狮子和老虎也会变得弱小或暴露出自己的弱点。到时候森林就会是一片和平了，也许蚂蚁还能坐在狮子头上玩哩！</p><p><code>----------本篇完----------</code></p><h2 id="（十九）《渴望飞翔的企鹅》"><a href="#（十九）《渴望飞翔的企鹅》" class="headerlink" title="（十九）《渴望飞翔的企鹅》"></a>（十九）《渴望飞翔的企鹅》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（十九）.jpg" alt="《渴望飞翔的企鹅》"></p><p>企鹅群里出现了一直不寻常的企鹅，当然，从外表肯定看不出来，但它又一颗渴望飞翔的心。其实这个想打来得很巧合，是在它出生的那个夜晚，它做了一个美梦，梦见自己飞翔在天空，那个梦醒来后，它就开始寻找飞翔。</p><p>当它向同伴说出这个想法时，所有的同伴都嘲笑着它，它只能孤独地面对现实，默默地坐着飞翔的梦。</p><p>于是，它开始付诸实践。首先就是强化已经退化了的翅膀，加强对翅膀的训练，让翅膀有足够的力量维持它飞翔的身体。然后它又开始减肥，它很清楚目前肥胖的身体很难飞起来，尽管很可爱。再接下来，它开始爬到一处不高的冰山上往下跳，感受短暂的飞翔的感觉。尽管它已经很用力地扑腾翅膀，但每次还是很沉重地摔在了冰上。冰很冷，但它的心依然滚烫着。</p><p><img src="https://hu33.github.io/images/飞羽作品集/（十九）2.jpg" alt="《渴望飞翔的企鹅》"></p><p>终于，那一天到来了。它再次从冰山跃下，它–依旧没有飞起来，而是摔在冰上并滑进水里。在滑进水里的那一刻，它突然醒悟了，奋力向前游着，留下一串欢快的笑声在游动的轨迹后面。</p><p>其实我们从天上往下看那片企鹅游过的海洋，不也是反射的蓝天吗？远远看去，它就是飞翔在自己渴望的那片蓝天，丝毫没有改变，也许更加轻快呢！我们每个人都有自己的一片蓝天，任我们飞翔，可是我们找到了自己的那片蓝天了吗？</p><p><code>----------本篇完----------</code></p><h2 id="（二十）《灯》"><a href="#（二十）《灯》" class="headerlink" title="（二十）《灯》"></a>（二十）《灯》</h2><p><img src="https://hu33.github.io/images/飞羽作品集/（二十）.jpg" alt="《灯》"></p><p>电线两端连着两盏灯</p><p>一盏灯亮着</p><p>另一盏，也亮着</p><p>夜正不紧不慢地前行</p><p>不知不觉</p><p>它们都已累了</p><p>一盏灯说：“晚安。”</p><p>另一盏也通过电线</p><p>回应“晚安。“</p><p>夜仍不紧不慢地前行</p><p>一盏灯亮着</p><p>另一盏，依旧亮着</p><p>只是 为了</p><p>照亮彼此</p><p>夜–已亮</p><p><code>----------本篇完----------</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本作品集为飞羽原创，18岁生日时飞羽将其作为礼物赠与本人，现将该作品摘抄并记录在该博客中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;（一）《淡淡》&quot;&gt;&lt;a href=&quot;#（一）《淡淡》&quot; class=&quot;headerlink&quot; title=&quot;（一）《淡淡》&quot;&gt;&lt;/a&gt;（一）《淡淡》&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://hu33.github.io/images/飞羽作品集/（一）.jpg&quot; alt=&quot;《淡淡》&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://hu33.tech/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="作品集" scheme="http://hu33.tech/tags/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
      <category term="礼物" scheme="http://hu33.tech/tags/%E7%A4%BC%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>《你的名字》影评</title>
    <link href="http://hu33.tech/2019/01/11/%E3%80%8A%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E3%80%8B%E5%BD%B1%E8%AF%84/"/>
    <id>http://hu33.tech/2019/01/11/《你的名字》影评/</id>
    <published>2019-01-11T10:45:11.082Z</published>
    <updated>2019-01-12T11:15:15.728Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://hu33.github.io/images/影评/你的名字.jpeg" alt="《你的名字》剧照"></p><a id="more"></a><blockquote><p>导演：<a href="https://movie.douban.com/celebrity/1005177/" target="_blank" rel="external">新海诚</a></p><p>编剧：<a href="https://movie.douban.com/celebrity/1005177/" target="_blank" rel="external">新海诚</a>、<a href="https://movie.douban.com/celebrity/1330986/" target="_blank" rel="external">Waris Dirie</a>、<a href="https://movie.douban.com/celebrity/1286916/" target="_blank" rel="external">Sherry Hormann</a></p><p>演员：<a href="https://movie.douban.com/celebrity/1185637/" target="_blank" rel="external">神木隆之介</a>、<a href="https://movie.douban.com/celebrity/1316660/" target="_blank" rel="external">上白石萌音</a></p></blockquote><p>一句话评价：超好看超好看超好看！</p><p>这是唯一一部电脑上看过后还想去电影院看的电影，没有失望，满满的满足感，从整体的剧情到唯美的画面再到人物塑造我都特别喜欢。</p><p>其实看电影这种事，除了电影本身的质量外，自己的状态也特别能影响整个观影心情。最近因为一些事情导致心里老是空落落又七上八下的，就是那种惦记着某个东西却得不到的感觉。这不正与电影中他俩一直在寻找着神秘却找不到（准确说是并不知道在找什么）一样嘛。</p><p>还好，还好最后他俩相遇了，还好泷鼓足了勇气叫住了三叶，还好在那之前他俩都还单着，还好还好。</p><p>如果一辈子都想不起来心里那个东西是什么该如何生活？因为想不起，所以何来忘记。</p><p>回到电影中来，其实整个电影中伏笔都设置非常好，包括后面勅使炸发电站，泷喝口嚼酒来产生联系。电影中每一幕都是有意图的，都是能在后面找到对应的情节的，每一个画面，每一句台词都是有意义的。这就是我特别喜欢这部电影的原因，饱满而不做作，多看几遍也还是能看出新东西来。</p><p>关键是！！每一帧都可以当做壁纸，真的是美翻天！！！</p><p><code>本影评写于16年12月</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://hu33.github.io/images/影评/你的名字.jpeg&quot; alt=&quot;《你的名字》剧照&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://hu33.tech/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="影评" scheme="http://hu33.tech/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>《沙漠之花》影评</title>
    <link href="http://hu33.tech/2019/01/11/%E3%80%8A%E6%B2%99%E6%BC%A0%E4%B9%8B%E8%8A%B1%E3%80%8B%E5%BD%B1%E8%AF%84/"/>
    <id>http://hu33.tech/2019/01/11/《沙漠之花》影评/</id>
    <published>2019-01-11T10:00:35.514Z</published>
    <updated>2019-01-11T10:44:14.605Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://hu33.github.io/images/影评/沙漠之花.jpg" alt="《沙漠之花》剧照"></p><a id="more"></a><blockquote><p>导演：<a href="https://movie.douban.com/celebrity/1286916/" target="_blank" rel="external">Sherry Hormann</a></p><p>编剧：<a href="https://movie.douban.com/celebrity/1305350/" target="_blank" rel="external">Smita Bhide</a>、<a href="https://movie.douban.com/celebrity/1330986/" target="_blank" rel="external">Waris Dirie</a>、<a href="https://movie.douban.com/celebrity/1286916/" target="_blank" rel="external">Sherry Hormann</a></p><p>演员：<a href="https://movie.douban.com/celebrity/1014172/" target="_blank" rel="external">Liya Kebede</a>、<a href="https://movie.douban.com/celebrity/1044915/" target="_blank" rel="external">Sally Hawkins</a>、</p></blockquote><p>这部电影讲的是一个受割礼的索马里女孩从非洲逃到英国，被唐纳森发掘而成为一代超模，而后勇敢站出来向全世界反映割礼的残忍与对女性的不尊重。</p><p>整部电影的基调比较平淡，却不时地透露出让人心塞的情景，尤其当女主角会议割礼的过程，让人无比揪心，悲恸却有种哭不出来的压抑。</p><p>看完电影后便查了很多关于割礼的资料，这种残害人身心的习俗真是太可怕了，千千万万的妇女死于这种惨无人道的习俗，千千万万的妇女因这种毫无因全弊无利的事情而无法享受很多美好的体验。好在总有人站出来，顶着巨大压力和危险与信仰做斗争，为女权奋斗，为更多人的幸福与正常生活而奋斗。</p><p>很庆幸自己一直活得没什么障碍，那些自以为很大的事很大的问题在这面前根本不值一提。任何困难都可以被解决，可能不一定恢复，但是能愈合。</p><p><code>本影评写自16年8月</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://hu33.github.io/images/影评/沙漠之花.jpg&quot; alt=&quot;《沙漠之花》剧照&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://hu33.tech/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="影评" scheme="http://hu33.tech/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>《爆裂鼓手》影评</title>
    <link href="http://hu33.tech/2019/01/11/%E3%80%8A%E7%88%86%E8%A3%82%E9%BC%93%E6%89%8B%E3%80%8B%E5%BD%B1%E8%AF%84/"/>
    <id>http://hu33.tech/2019/01/11/《爆裂鼓手》影评/</id>
    <published>2019-01-11T05:38:00.229Z</published>
    <updated>2019-01-11T10:36:36.564Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://hu33.github.io/images/影评/爆裂鼓手.jpg" alt="《爆裂鼓手》剧照"></p><a id="more"></a><blockquote><p>导演：<a href="https://movie.douban.com/celebrity/1014996/" target="_blank" rel="external">Damien Chazelle</a></p><p>编剧：<a href="https://movie.douban.com/celebrity/1014996/" target="_blank" rel="external">Damien Chazelle</a></p><p>主演：<a href="https://movie.douban.com/celebrity/1313408/" target="_blank" rel="external">Miles Teller</a>、<a href="https://movie.douban.com/celebrity/1147911/" target="_blank" rel="external">J.K. Simmons</a></p></blockquote><p>与其说Andrew是在追求自己的梦想，还不如说他是对击鼓有着强烈的偏激的疯狂的热爱。当然这种热爱与Fletcher的魔鬼式训练与咄咄逼人是分不开的。有人把《爆裂鼓手》当做励志来看，寓意一切伟大背后必历经辛酸磨难，但我在观看的过程中却感受到了压迫的气息，不仅仅是Fletcher对学生们的压迫，还有Andrew对自己的逼迫，逼迫自己不断练习不断加速，到最后哪怕是出车祸了都不愿暂时放弃一次机会。</p><p>最终的Andrew应该是成功的，但是成功是需要代价的，也是需要突破的机遇。如此偏执的热爱若未完全突破很容易出问题的，从Andrew跟女朋友说分手及家庭聚餐上说的话就能感觉出来。</p><p>不管怎样，本宝宝还是偏向于快乐学习健康成长，娃哈哈！</p><p><code>本影评写自16年8月</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://hu33.github.io/images/影评/爆裂鼓手.jpg&quot; alt=&quot;《爆裂鼓手》剧照&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://hu33.tech/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="影评" scheme="http://hu33.tech/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>Chrome显示小于12px的字体</title>
    <link href="http://hu33.tech/2019/01/10/Chrome%E6%9C%80%E5%B0%8F%E6%98%BE%E7%A4%BA12px%E5%AD%97%E4%BD%93/"/>
    <id>http://hu33.tech/2019/01/10/Chrome最小显示12px字体/</id>
    <published>2019-01-10T13:52:44.437Z</published>
    <updated>2019-01-10T14:00:51.647Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><code>Chrome</code>上默认最小字体是<code>12px</code>，这就意味着你想设置某个元素(可能是个上标或下标)的<code>font-size</code>为<code>9px</code>，结果显示出来的是<code>12px</code>，有那么一点恼火是吧？</p><a id="more"></a><p>曾经是可以使用<code>-webkit-text-size-adjust: none</code>来禁止网页调整字体大小，但是<code>Chrome27</code>之后就将该属性禁用了（该属性<a href="https://trac.webkit.org/changeset/145168/webkit" target="_blank" rel="external">具体变更集</a>）。这个禁用是有道理的，因为该属性很容易被滥用：很多开发者会直接将该属性设置为全局属性，然后当用户放大或缩小页面时（按住Ctrl滚动鼠标滚轮可缩放网页），文字却维持定义的大小而不放缩，给用户带来的不太友好的体验。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>现在一般是使用<code>transform: scale(0.82)</code>来实现小于<code>12px</code>的字体显示。比如要显示<code>8px</code>的字体，那么可以将该元素加上以下属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">font-size</span>: 12<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.667</span>);</div><div class="line"><span class="selector-tag">-moz-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.667</span>);</div><div class="line"><span class="selector-tag">-ms-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.667</span>);</div><div class="line"><span class="selector-tag">-o-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.667</span>);</div><div class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.667</span>);</div></pre></td></tr></table></figure><p>只要缩小到需要尺寸的比例即好。需要注意的是，这个方案需要该元素表现为<code>inline-block</code>。</p><p>具体效果<a href="http://jsbin.com/wiroweh/1/edit?html,css,output" target="_blank" rel="external">戳这儿</a>~</p><p>上述代码可以使用<code>sass</code>的<code>@mixin</code>抽象一下（<code>@mixin</code>相关内容可以看<a href="https://github.com/hu33/project-problem-notes/blob/master/sass%20-%20%E4%BD%BF%E7%94%A8mixin%E6%88%96%E5%8D%A0%E4%BD%8D%E7%AC%A6%E5%A4%8D%E7%94%A8CSS%E4%BB%A3%E7%A0%81.md" target="_blank" rel="external">这里</a>），通过传参数来得到想要的字体。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@mixin webkit-font-size($size: 10) &#123;</div><div class="line">    font-size: 12px;</div><div class="line">    -webkit-transform: scale($size / 12);</div><div class="line">    -moz-transform: scale($size / 12);</div><div class="line">    -ms-transform: scale($size / 12);</div><div class="line">    -o-transform: scale($size / 12);</div><div class="line">    transform: scale($size / 12);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Chrome&lt;/code&gt;上默认最小字体是&lt;code&gt;12px&lt;/code&gt;，这就意味着你想设置某个元素(可能是个上标或下标)的&lt;code&gt;font-size&lt;/code&gt;为&lt;code&gt;9px&lt;/code&gt;，结果显示出来的是&lt;code&gt;12px&lt;/code&gt;，有那么一点恼火是吧？&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="问题记录" scheme="http://hu33.tech/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>《高性能JavaScript》- DOM编程</title>
    <link href="http://hu33.tech/2017/09/15/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDJavaScript%E3%80%8B-%20DOM%E7%BC%96%E7%A8%8B/"/>
    <id>http://hu33.tech/2017/09/15/《高性能JavaScript》- DOM编程/</id>
    <published>2017-09-15T12:26:58.482Z</published>
    <updated>2019-01-13T08:30:01.737Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，用JS进行<code>DOM</code>操作那是灰常的昂贵，毕竟人家web应用的性能瓶颈之一啊，但也是有不少优化的法子的~~本章大致从三个方向阐述了<code>DOM</code>编程的优化方法。</p><h3 id="尽量减少访问和修改DOM次数"><a href="#尽量减少访问和修改DOM次数" class="headerlink" title="尽量减少访问和修改DOM次数"></a>尽量减少访问和修改DOM次数</h3><p>浏览器中通常是独立实现<code>DOM</code>和<code>JavaScript</code>的，这样可以允许其他技术和语言也能共享使用<code>DOM</code>和渲染函数，但这也意味着JS想去访问<code>DOM</code>，是要花费一定代价的，访问和修改的次数越高，代价就越高，代码运行速度就越慢。</p><a id="more"></a><h4 id="优化点1-使用DOM更新页面内容时，克隆已有元素，而不是创建新元素"><a href="#优化点1-使用DOM更新页面内容时，克隆已有元素，而不是创建新元素" class="headerlink" title="优化点1  使用DOM更新页面内容时，克隆已有元素，而不是创建新元素"></a>优化点1  使用DOM更新页面内容时，克隆已有元素，而不是创建新元素</h4><p>在大多数浏览器中，节点克隆都更有效率，虽然效果不是特别明显~~所以对于一些需要多次重复创建的元素，可以先创建第一个，然后重复拷贝操作。也就是用<code>element.cloneNode()</code>代替<code>document.createElement()</code>。</p><h4 id="优化点2-遍历HTML集合时，把集合存在局部变量中，并把length缓存在循环外部，用局部变量代替这些需要多次读取的元素"><a href="#优化点2-遍历HTML集合时，把集合存在局部变量中，并把length缓存在循环外部，用局部变量代替这些需要多次读取的元素" class="headerlink" title="优化点2  遍历HTML集合时，把集合存在局部变量中，并把length缓存在循环外部，用局部变量代替这些需要多次读取的元素"></a>优化点2  遍历HTML集合时，把集合存在局部变量中，并把length缓存在循环外部，用局部变量代替这些需要多次读取的元素</h4><p>看个例子就造了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//最慢</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectionGlobal</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> coll = <span class="built_in">document</span>.getElementByTagName(<span class="string">'div'</span>),</div><div class="line">    len = coll.length,</div><div class="line">    name = <span class="string">''</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; len; count++) &#123;</div><div class="line">        name = <span class="built_in">document</span>.getElementByTagName(<span class="string">'div'</span>)[count].nodeName;</div><div class="line">        name = <span class="built_in">document</span>.getElementByTagName(<span class="string">'div'</span>)[count].nodeType;</div><div class="line">        name = <span class="built_in">document</span>.getElementByTagName(<span class="string">'div'</span>)[count].tagName;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//较快</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectionGlobal</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> coll = <span class="built_in">document</span>.getElementByTagName(<span class="string">'div'</span>),</div><div class="line">    len = coll.length,</div><div class="line">    name = <span class="string">''</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; len; count++) &#123;</div><div class="line">        name = coll[count].nodeName;</div><div class="line">        name = coll(<span class="string">'div'</span>)[count].nodeType;</div><div class="line">        name = coll(<span class="string">'div'</span>)[count].tagName;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最快</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectionGlobal</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> coll = <span class="built_in">document</span>.getElementByTagName(<span class="string">'div'</span>),</div><div class="line">    len = coll.length,</div><div class="line">    name = <span class="string">''</span>,</div><div class="line">    ele = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; len; count++) &#123;</div><div class="line">        ele = coll[count]; </div><div class="line">        name = ele.nodeName;</div><div class="line">        name = ele.nodeType;</div><div class="line">        name = ele.tagName;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="优化点3-访问元素节点时，推荐使用只返回元素节点的API，因为它们的执行效率比自己在JS代码中实现过滤的效率要高"><a href="#优化点3-访问元素节点时，推荐使用只返回元素节点的API，因为它们的执行效率比自己在JS代码中实现过滤的效率要高" class="headerlink" title="优化点3  访问元素节点时，推荐使用只返回元素节点的API，因为它们的执行效率比自己在JS代码中实现过滤的效率要高"></a>优化点3  访问元素节点时，推荐使用只返回元素节点的API，因为它们的执行效率比自己在JS代码中实现过滤的效率要高</h4><p>这些API如下：</p><ul><li><code>children</code> – <code>childNodes</code></li><li><code>childElementCount</code> – <code>childNodes.length</code></li><li><code>firstElementChild</code> – <code>firstChild</code></li><li><code>lastElementChild</code> – <code>lastChild</code></li><li><code>nextElementSibling</code> – <code>nextSibing</code></li><li><code>previousElementSibling</code> – <code>previousSibing</code></li></ul><h4 id="优化点4-使用querySelectorAll-查询DOM"><a href="#优化点4-使用querySelectorAll-查询DOM" class="headerlink" title="优化点4  使用querySelectorAll()查询DOM"></a>优化点4  使用<code>querySelectorAll()</code>查询DOM</h4><p>当咱需要得到特定的DOM元素列表时，需要使用<code>getElementById()</code>和<code>getElementByTagName()</code>进行组合调用，而且还得手动遍历筛选，好不麻烦且效率低下~~</p><p>后来~~<code>querySelectorAll()</code>就横空出世了，只要传入相应的CSS选择器字符串，就能得到咱需要的元素了，而且还是浏览器原生API，比起用JS和DOM操作来遍历查找元素不要快太多啊~~</p><p>而且，<code>querySelectorAll()</code>返回的是一个<code>NodeList</code>，是一个快照而不是动态集合，所以还避免了HTML集合会导致的性能问题。</p><h3 id="尽量避免重绘和重排"><a href="#尽量避免重绘和重排" class="headerlink" title="尽量避免重绘和重排"></a>尽量避免重绘和重排</h3><p>浏览器下载完页面中所有的组件后会解析并生成两个内部数据结构–<code>DOM</code>树和<code>Render</code>树，<code>DOM</code>树都知道是表示页面结果，<code>Render</code>树则是表示<code>DOM</code>节点如何显示。<code>Render</code>树中的节点就是一个“盒”，一旦<code>DOM</code>树和<code>Render</code>树构建完成，浏览器就开始绘制元素了。</p><p>当<code>DOM</code>的变化影响了元素的几何属性（宽和高），浏览器就需要重新计算元素的几何属性，其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的元素的部分失效，并重新构建<code>Render</code>树，这就是传说中的重排。重排之后，浏览器会重新绘制受影响的部分，这就是重绘。</p><p>易得：重绘和重排都是代价很昂贵的操作，所以要尽量避免避免啊~</p><h4 id="优化点5-合并多次对DOM和样式的修改，然后一次处理"><a href="#优化点5-合并多次对DOM和样式的修改，然后一次处理" class="headerlink" title="优化点5  合并多次对DOM和样式的修改，然后一次处理"></a>优化点5  合并多次对DOM和样式的修改，然后一次处理</h4><ul><li>改变样式：可以用<code>CSSText</code>属性做批量修改</li><li>批量修改<code>DOM</code>：可以让<code>DOM</code>脱离文档流，修改完再带回文档中，具体有三种方式：<ol><li>隐藏元素（<code>display：none</code>），修改后再重新显示</li><li>使用文档片段在当前<code>DOM</code>之外构建一个子树，再把它拷贝回文档</li><li>将原始元素拷贝到一个脱离文档流的节点中，修改该副本节点，完成后再替换原始元素</li></ol></li></ul><h4 id="优化点6-缓存布局信息"><a href="#优化点6-缓存布局信息" class="headerlink" title="优化点6  缓存布局信息"></a>优化点6  缓存布局信息</h4><p>现在大多数浏览器对重排进行了优化，通过队列化修改并批量修改执行来实现，但是有种操作会强制刷新队列并要求计划任务立即执行！它！就！是！获取元素的布局信息！因为查询布局信息时，浏览器会为了返回最新值而会刷新队列并应用所有变更。</p><p>这个时候，局部变量又派上用场了，我们可以通过获取布局信息，把它赋值给局部变量，然后操作局部变量，尽可能地减少布局信息的获取次数。</p><h4 id="优化点7-让元素脱离动画流"><a href="#优化点7-让元素脱离动画流" class="headerlink" title="优化点7  让元素脱离动画流"></a>优化点7  让元素脱离动画流</h4><p>假设有个元素处在页面顶部，然后它可以展开/折叠，那岂不是对它之后所有的元素位置都会产生影响？那岂不是要进行大规模重排？？那岂不是很消耗性能？？？</p><p>咱可以让它脱离文档流啊~先给它设置绝对定位，然后它想咋动就咋动吧，反正就导致一小区域的重绘，等动画结束再恢复它本来的定位。</p><h3 id="优化点8-使用事件委托"><a href="#优化点8-使用事件委托" class="headerlink" title="优化点8  使用事件委托"></a>优化点8  使用事件委托</h3><p>元素绑定事件处理器是有代价的，会占用处理时间，而且浏览器还要跟踪这些处理器，又会占更多的内存。要是页面上一大堆元素都需要绑定一个或多个事件处理器，那还不堵死啊。。。</p><p>不过呢，大部分事件是能够冒泡的，咱就可以给外层元素绑定一个处理器，用来处理在其子元素上触发的事件。除了性能上有很大的优化，事件委托其实还有个好处，就是如果一个元素的子元素是动态的，它也可以进行处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，用JS进行&lt;code&gt;DOM&lt;/code&gt;操作那是灰常的昂贵，毕竟人家web应用的性能瓶颈之一啊，但也是有不少优化的法子的~~本章大致从三个方向阐述了&lt;code&gt;DOM&lt;/code&gt;编程的优化方法。&lt;/p&gt;
&lt;h3 id=&quot;尽量减少访问和修改DOM次数&quot;&gt;&lt;a href=&quot;#尽量减少访问和修改DOM次数&quot; class=&quot;headerlink&quot; title=&quot;尽量减少访问和修改DOM次数&quot;&gt;&lt;/a&gt;尽量减少访问和修改DOM次数&lt;/h3&gt;&lt;p&gt;浏览器中通常是独立实现&lt;code&gt;DOM&lt;/code&gt;和&lt;code&gt;JavaScript&lt;/code&gt;的，这样可以允许其他技术和语言也能共享使用&lt;code&gt;DOM&lt;/code&gt;和渲染函数，但这也意味着JS想去访问&lt;code&gt;DOM&lt;/code&gt;，是要花费一定代价的，访问和修改的次数越高，代价就越高，代码运行速度就越慢。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="笔记" scheme="http://hu33.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
      <category term="性能" scheme="http://hu33.tech/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>《高性能JavaScript》- 数据存取</title>
    <link href="http://hu33.tech/2017/09/14/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDJavaScript%E3%80%8B-%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96/"/>
    <id>http://hu33.tech/2017/09/14/《高性能JavaScript》- 数据存取/</id>
    <published>2017-09-14T11:06:39.958Z</published>
    <updated>2019-01-10T14:34:51.662Z</updated>
    
    <content type="html"><![CDATA[<p>数据的存储位置会很大程度影响其读取速度，so本章就是从这个方向来讨论的优化点~</p><h3 id="优化点1-将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量"><a href="#优化点1-将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量" class="headerlink" title="优化点1  将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量"></a>优化点1  将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量</h3><p>函数在执行过程中，每遇到一个变量，都会经历一次标识符解析的过程，来决定从哪里获取或存储数据。这个过程就是在搜索执行环境的作用域链，从作用域头部（当前函数运行的活动对象）开始搜索，直到找到标识符。</p><a id="more"></a><p>然鹅，标识符的解析也是要产生性能开销的好不啦，<strong>标识符的位置越深，它的读写速度肯定会越慢啊~</strong>也就是说，函数中读写局部变量是最快的，因为它们是在作用域链最前线嘛，读取全局变量是最慢的，毕竟是在作用域链最末端位置嘛（emmm…优化了<code>JavaScript</code>引擎的先不管哈）。</p><p>所以啊，如果我们在一个函数中要多次引用全局变量或者是跨作用域的变量，最好是先用一个局部变量存起来，通过这个局部变量去访问就好啦。</p><h3 id="优化点2-避免使用with语句，谨慎使用try-catch语句"><a href="#优化点2-避免使用with语句，谨慎使用try-catch语句" class="headerlink" title="优化点2  避免使用with语句，谨慎使用try-catch语句"></a>优化点2  避免使用<code>with</code>语句，谨慎使用<code>try-catch</code>语句</h3><p><code>with</code>语句和<code>try-catch</code>中的<code>catch</code>语句在执行时是有临时改变作用域链的能力的！这么强大的技能怎么能随便用呢？</p><ul><li><p><code>with</code>语句用来给对象的所有属性都创建一个变量，它会将指定的对象添加到作用域链中，看下这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> qs = <span class="string">"?debug=true"</span>;</div><div class="line">  <span class="keyword">with</span>(location) &#123;</div><div class="line">      <span class="keyword">var</span> url = href + qs;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> url;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当代码执行到<code>with</code>语句时，一个新的变量对象被创建，它包含了参数指定的对象的所有属性，这个对象会被推入到作用域链首位，也就是说，函数的所有局部变量就被挤到第二个作用域对象中了，访问的代价也就高了啊~~</p></li><li><p><code>try-catch</code>语句中的<code>catch</code>子句也有同样的效果。当<code>try</code>代码块中发生错误时，执行过程会自动跳到<code>catch</code>子句，然后把异常对象推入一个变量对象并置于作用域链首位。</p><p>咱可以尽量简化代码来是的<code>catch</code>子句对性能的影响最小化，推荐将错误委托给一个函数来处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapArr</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        result = arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> item*<span class="number">2</span>;</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span>(ex) &#123;</div><div class="line">        handleError(ex);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleError</span>(<span class="params">ex</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ex: '</span>, ex);</div><div class="line">&#125;</div><div class="line"></div><div class="line">mapArr(&#123;&#125;);</div></pre></td></tr></table></figure><p>其中<code>catch</code>子句的作用域链如下：</p><p><img src="http://ow7p6xhhi.bkt.clouddn.com/2-1.png" alt=""></p><p>书中给出这种推荐的理由是：只执行一条语句，且没有局部变量的访问，作用域链的临时改变不会影响代码性能。<strong>但是！有点想不通的是，如果要访问局部变量，<code>handleError()</code>怎么访问得到嘛，难道是通过传参？那在<code>catch</code>子句中调用<code>handleError()</code>并传参的话也就意味着还是要在<code>catch</code>里访问局部变量嘛。。。如果<code>handleError()</code>不用访问局部变量，表示<code>catch</code>子句里也不用访问局部变量呀，那用不用这个委托函数岂不是没差？？？</strong></p></li></ul><h3 id="优化点3-确实必要时才使用动态作用域"><a href="#优化点3-确实必要时才使用动态作用域" class="headerlink" title="优化点3  确实必要时才使用动态作用域"></a>优化点3  确实必要时才使用动态作用域</h3><p>像<code>with</code>语句、<code>try-catch</code>语句中的<code>catch</code>子句、或者包含<code>eval()</code>的函数，都算是动态作用域。动态作用域只存在于代码运行时，也就是说不能通过静态分析（查看代码结构）检测出来。</p><p>有些经过优化的<code>JavaScript</code>引擎，会尝试通过分析代码来确定哪些变量可以在特定时候被访问，它们会试图避开传统作用域链的查找，当涉及动态作用域时，这种优化方式就失效了。</p><h3 id="优化点4-只在必要时使用对象成员"><a href="#优化点4-只在必要时使用对象成员" class="headerlink" title="优化点4  只在必要时使用对象成员"></a>优化点4  只在必要时使用对象成员</h3><p>理由如下：</p><ul><li>属性或方法在原型链中的位置越深，访问它的速度就越慢</li><li>嵌套的对象成员越深，其读取速度就越慢</li></ul><p>比如说，在同一个函数中没有必要多次读取同一个对象成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasEitherClass</span>(<span class="params">element, className1, className2</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> element.className == className1 || element.className == className2;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个代码中读取了两次<code>element.className</code>，也就是说执行了两次对象查找，咱可以将值保存在局部变量中减少一次查找。改成下面这样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasEitherClass</span>(<span class="params">element, className1, className2</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> currentClassName = element.className;</div><div class="line">  <span class="keyword">return</span> currentClassName == className1 || currentClassName == className2;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>反正这一章最重要的优化点就在于<strong>善用局部变量做缓存</strong>~把那些需多次使用的对象成员、数组元素、跨域变量都保存在局部变量就对了，谁叫它访问速度快呢~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据的存储位置会很大程度影响其读取速度，so本章就是从这个方向来讨论的优化点~&lt;/p&gt;
&lt;h3 id=&quot;优化点1-将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量&quot;&gt;&lt;a href=&quot;#优化点1-将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量&quot; class=&quot;headerlink&quot; title=&quot;优化点1  将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量&quot;&gt;&lt;/a&gt;优化点1  将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量&lt;/h3&gt;&lt;p&gt;函数在执行过程中，每遇到一个变量，都会经历一次标识符解析的过程，来决定从哪里获取或存储数据。这个过程就是在搜索执行环境的作用域链，从作用域头部（当前函数运行的活动对象）开始搜索，直到找到标识符。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="笔记" scheme="http://hu33.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
      <category term="性能" scheme="http://hu33.tech/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>《高性能JavaScript》- 加载并执行</title>
    <link href="http://hu33.tech/2017/09/13/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDJavaScript%E3%80%8B-%20%E5%8A%A0%E8%BD%BD%E5%B9%B6%E6%89%A7%E8%A1%8C/"/>
    <id>http://hu33.tech/2017/09/13/《高性能JavaScript》- 加载并执行/</id>
    <published>2017-09-13T11:22:56.869Z</published>
    <updated>2019-01-13T08:22:34.996Z</updated>
    
    <content type="html"><![CDATA[<p>这一章主要从管理浏览器中的js代码来进行阐述优化点。</p><h3 id="优化点1：将脚本放在底部"><a href="#优化点1：将脚本放在底部" class="headerlink" title="优化点1：将脚本放在底部"></a>优化点1：将脚本放在底部</h3><p>讲道理，按我们的理解，将js文件和css文件一起放在head中好像没什么毛病，先加载它们，有助于页面渲染和正确交互呀。</p><p>可是！可是坑爹的是，脚本是会阻塞页面渲染的啊，浏览器需要等到它们全部下载并执行完成后，才继续页面渲染。所以把脚本放页面头部会导致明显的延迟，表现为显示空白页面，用户无法浏览页面，也无法与页面进行交互。</p><a id="more"></a><p>更坑爹的是，有些浏览器下载js文件是串行的，也就是说每个文件必须等到前一个文件下载并执行完成后才会开始下载，在这些个文件逐个下载过程中，浏览器上的页面就是一片白茫茫啊~~现在很多浏览器都允许并行下载js文件了，但是仍然会阻塞其他资源的下载，比如图片。尽管脚本的下载过程不会相互影响了，但是页面还是得等所有的js代码下载并执行完才能继续。所以呀，新的浏览器只是治标不治本啊。</p><p>恩，综上所述，咱要把所有的<code>&lt;script&gt;</code>标签放到<code>&lt;body&gt;</code>标签的底部，来尽量减少对整个页面下载的影响。</p><h3 id="优化点2：合并脚本"><a href="#优化点2：合并脚本" class="headerlink" title="优化点2：合并脚本"></a>优化点2：合并脚本</h3><p>这个当然是为了减少http请求带来的性能开销咯。下载1个100k的文件会比下载4个25k的文件要快的呀。</p><p>可以使用离线的打包工具或者类似Yahoo! combo handler的实时在线服务实现。</p><h3 id="优化点3：无阻塞脚本"><a href="#优化点3：无阻塞脚本" class="headerlink" title="优化点3：无阻塞脚本"></a>优化点3：无阻塞脚本</h3><p>上回讲到，合并脚本可以减少http请求数，提高性能。可是问题来了，合并完的脚本可能很大啊，那我浏览器得等这么大一个脚本下载并执行完再进行后面的操作嘛？</p><p>当然，我们也是有办法解决的。咱实现无阻塞脚本不就好了？咱可以等页面加载完再加载js代码呀，专业点讲，就是在<code>window</code>对象的<code>load</code>事件触发后再下载脚本。实现方法有如下几种：</p><h4 id="延迟的脚本"><a href="#延迟的脚本" class="headerlink" title="延迟的脚本"></a>延迟的脚本</h4><p>主角：<code>defer</code></p><p>技能：允许并行下载（包括其他资源哦），但不会执行，直到DOM加载完成（<code>onload</code>事件被触发前）</p><p>可以看个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Script Defer Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    alert(<span class="string">'defer'</span>);</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    alert(<span class="string">'script'</span>);</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     alert(<span class="string">'load'</span>); </div><div class="line">    &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>猜猜弹出顺序是啥？恩，<code>script</code>、<code>defer</code>、<code>load</code>。</p><p><em>注：h5规范里讲了，<code>defer</code>属性仅当<code>src</code>属性声明时才生效~~</em></p><p>BTW，<code>async</code>也是允许并行下载的，但是它跟<code>defer</code>不同的在于它是下载完了就直接执行了，没有<code>defer</code>那么好的耐心，还等<code>dom</code>完成加载后才执行。</p><p><img src="https://hu33.github.io/images/高性能JavaScript/1-1.jpg" alt=""></p><h4 id="动态脚本元素"><a href="#动态脚本元素" class="headerlink" title="动态脚本元素"></a>动态脚本元素</h4><p>原理：使用DOM操作创建一个<code>&lt;script&gt;</code>元素，这个元素中加载某个js文件，然后将该<code>&lt;scirpt&gt;</code>元素添加到页面中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">script.type = <span class="string">"text/javascript"</span>;</div><div class="line">script.src = <span class="string">"file.js"</span>;</div><div class="line"><span class="built_in">document</span>.head.append(script);</div></pre></td></tr></table></figure><p>技能：无论何时启动下载，文件的下载和执行都不回阻塞页面其他进程。</p><p>这种方式还有个特点：返回的代码一般会立即执行（是不是想到了JSONP，哈哈哈）。但是我可能需要它下载完成且准备就绪的时候才执行啊，这个时候，<code>&lt;script&gt;</code>的<code>onload</code>事件就派上用场了~~封装一个<code>loadScript</code>方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url, callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">    script.type = <span class="string">"text/javascript"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (script.readyState) &#123; <span class="comment">//还不是为了兼容IE</span></div><div class="line">        <span class="keyword">if</span> (script.onreadystatechange) &#123;</div><div class="line">            <span class="keyword">if</span> (script.readyState === <span class="string">'loaded'</span> || script.readyState === <span class="string">'completed'</span>) &#123;</div><div class="line">                script.onreadystatechange = <span class="literal">null</span>;</div><div class="line">                callback();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            callback();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    script.src = url;</div><div class="line">    <span class="built_in">document</span>.getElementByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果需要按顺序下载执行代码的话，可以进行嵌套使用<code>loadScript()</code>方法。当然如果多个文件的下载顺序很重要，更好的做法还是把它们按正确的顺序合并成一个文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">loadScript(<span class="string">'file1.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  loadScript(<span class="string">'file2.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    loadScript(<span class="string">'file3.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      alert(<span class="string">'all files are loaded~~'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="XMLHttpRequest脚本注入"><a href="#XMLHttpRequest脚本注入" class="headerlink" title="XMLHttpRequest脚本注入"></a>XMLHttpRequest脚本注入</h4><p>原理：创建一个<code>xhr</code>对象，用它下载js文件，然后通过创建动态<code>&lt;script&gt;</code>元素将代码注入页面中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'file1.js'</span>, <span class="literal">true</span>);  <span class="comment">//第三个参数表是否异步</span></div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (xhr.readystate === <span class="number">4</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status === <span class="number">304</span>) &#123;</div><div class="line">            <span class="keyword">var</span> script = <span class="built_in">document</span>.craeteElement(<span class="string">'script'</span>);</div><div class="line">            script.type = <span class="string">"text/javascript"</span>;</div><div class="line">            script.text = xhr.responseText;</div><div class="line">            <span class="built_in">document</span>.body.appendChild(script);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">xhr.send(<span class="literal">null</span>);</div></pre></td></tr></table></figure><p>优点：js代码下载后不会自动执行，你可以把脚本的执行推迟到准备好的时候。<em>（为什么啊？？？书上说代码返回在script标签外，所以不自动执行…没看懂啊…）</em></p><p>局限：不能跨域请求js文件，也就不能从CDN下载咯。</p><h4 id="推荐的无阻塞模式"><a href="#推荐的无阻塞模式" class="headerlink" title="推荐的无阻塞模式"></a>推荐的无阻塞模式</h4><p>先添加动态加载所需的代码，然后加载初始化页面所需的剩下的代码。</p><p>有几个延迟加载工具：</p><ul><li><code>LazyLoad</code>类库，其实就是<code>loadScript()</code>的增强版</li><li><code>LABjs</code>，它的优点是管理依赖关系的能力</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一章主要从管理浏览器中的js代码来进行阐述优化点。&lt;/p&gt;
&lt;h3 id=&quot;优化点1：将脚本放在底部&quot;&gt;&lt;a href=&quot;#优化点1：将脚本放在底部&quot; class=&quot;headerlink&quot; title=&quot;优化点1：将脚本放在底部&quot;&gt;&lt;/a&gt;优化点1：将脚本放在底部&lt;/h3&gt;&lt;p&gt;讲道理，按我们的理解，将js文件和css文件一起放在head中好像没什么毛病，先加载它们，有助于页面渲染和正确交互呀。&lt;/p&gt;
&lt;p&gt;可是！可是坑爹的是，脚本是会阻塞页面渲染的啊，浏览器需要等到它们全部下载并执行完成后，才继续页面渲染。所以把脚本放页面头部会导致明显的延迟，表现为显示空白页面，用户无法浏览页面，也无法与页面进行交互。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="笔记" scheme="http://hu33.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
      <category term="性能" scheme="http://hu33.tech/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>网易秋招面试</title>
    <link href="http://hu33.tech/2017/08/31/%E7%BD%91%E6%98%93%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    <id>http://hu33.tech/2017/08/31/网易秋招面试/</id>
    <published>2017-08-31T14:13:25.359Z</published>
    <updated>2019-01-10T14:12:01.471Z</updated>
    
    <content type="html"><![CDATA[<p>2017年网易公共技术秋招-前端开发工程师。</p><p>记录一下噢。</p><a id="more"></a><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol><li>自我介绍一下</li><li>jQuery有哪些优势</li><li>jQuery插件怎么写</li><li>怎么学习前端的，看过哪些书</li><li>JS、CSS、HTML哪个比较熟</li><li>js的基本数据类型</li><li>js中比较经典的引用类型</li><li>基本数据类型和引用类型的区别</li><li>Function对象是干嘛用的</li><li>写一个构造函数继承（因为上面讲到了可以实现继承…）</li><li>Array对象的slice方法（因为写继承的时候有用到…）</li><li>怎么处理浏览器兼容，比如添加事件这个方法（DOM0级事件添加我竟然忘了…IE的attachEvent也没想起来…）</li><li>事件委托的原理，举例，优点</li><li>哪些事件不能冒泡</li><li>写一个经典的闭包（刚好前两天在项目里实现了个函数防抖，就写了这个哈哈哈）</li><li>讲一下CSS的盒模型</li><li>position有哪几种值，分别表示什么</li><li>CSS选择器有哪些</li><li>兄弟选择器是用什么表示，举个用到了兄弟选择器的例子</li><li>CSS如果有重复，怎么判断哪些生效（计算权重）</li><li>伪类和伪元素是一样的吗？</li><li>cookie、sessionStorage、localStorage区别</li><li>chrome开发者工具有哪些部分很好用？</li><li>最近在学什么？接下来半年准备学什么？</li></ol><p>总的来说一面还是蛮顺利的，二面就开始被吊打了。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ol><li>介绍一下项目（介绍了公司实习的项目，然而介绍完之后面试官并不问我项目啊啊，直接甩后面的问题了）</li><li>如何学习前端知识的</li><li>JS、CSS、HTML熟悉程度排序（我的回答是JS&gt;CSS&gt;HTML，他默默抬头看了我一眼…然后我有点虚，说这样排序并不是表示我真的对JS最熟悉，而是因为JS内容太多了，我在它上面花的时间最多…）</li><li>要你用原生JS实现一个模块预加载器的话，你会怎么做？（懵逼啊，题目都没搞明白，搞明白后就是懵逼啊…完全没思路…不过面试官看我很迷茫就说了句，没关系的，总有人知道有人不知道的）</li><li>要判断一个元素是否在数组中，你会怎么做？（我当时第一反应是indexOf啊，但是我想着这个问题不会这么简单，就说把数组遍历一遍，用forEach，后来又改成some。面试官竟然笑了…瘆得我呀…他说不用考虑我想考察你什么，你就平常怎么用的就怎么说好了。然后我就说那就用indexOf，要是不存在就返回-1咯。）</li><li>那一个数组中某个元素可能不止一个，你怎么判断？（这次直接就说了用lastIndexOf跟indexOf比较，相等就表示只有一个）</li><li>平常怎么给数组排序的？（我说如果不考虑性能的话就用Array自带的sort()，他问我那要是考虑性能呢？我弱弱地说了句，那就看情况吧…）</li><li>平常编码的时候有考虑代码层面的性能优化吗？（…表示除了eslint上的规范，其他没怎么考虑了…）</li><li>H5和CSS3用了些什么？（这里又给自己挖了个坑，说用CSS3实现字符串长度过长就截取并用省略号代替，然后面试官让我写一下，我竟然把white-space属性名给忘了…）</li><li>SEO有了解吗？（还真没去了解过…）</li><li>实现一个ajax</li><li>跨域知道哪些？（jsonp的安全攻防问题，cors怎么实现？）</li><li>要你实现一个UI和数据的双向绑定，你怎么做？（我问能用框架吗…他表示当然是用原生js实现啦，框架都帮你实现了…）</li><li>双向绑定和单向数据流的优缺点（表示只用过单向数据流的React，大致讲了一下，感觉他并不满意…）</li></ol><p>能想起来的问题基本是这些了，最后他说那我这边基本上没问题了，你有什么问题要问的吗？我感觉才面了很短的时间啊，怎么这么快就面完了，然后就表示很惊讶，“恩？这么快？我感觉我比较熟的方向您都没有问诶。。。”他问我对什么比较熟，我说react，然后他回了一句，因为我们不用react，我们有自己实现的一套框架。我：……</p><p>唉，然后我感觉没戏血崩炮灰，问的问题要么不会要么没答好。尤其是js基础方面太差，很多东西大概了解，但是没有去深入理解，所以问到一些实现思路的时候只能一脸懵逼了。所以后来问了下，面试下来您觉得我哪些方面需要加强，我感觉自己js基础比较差应该再深入学习一下。然后面试官停下敲键盘的手，以一个过来人的身份语重心长地跟我讲，其实基础才是最重要的。很多人会觉得会很多框架很炫酷，但其实不管怎么样你都只是在用别人的东西，只是一个不断找坑填坑的过程。但是真正牛逼的人都是基础很牢固，他们能在开发中发现一些底层的问题，然后考虑自己的业务场景和实际需求，自己实现，其实这个过程也就是框架的诞生过程。我们不能只看到市面上的各类框架，我们得知道为啥这些框架为什么会出现，为了解决什么问题，又是如何去实现解决的。</p><p>上面的话并不是原话…反正大概是这个意思吧，之前美团面试官也跟我讲过类似的话。不管怎么样，想成为一名合格的工程师，除了会用API，还要对底层原理很熟悉呀，不然就真的只是程序猿了…</p><h3 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h3><p>我也觉得很神奇啊，二面答成那样还能有HR面。</p><p>HR面其实没啥好讲了，基本是闲聊。比如学习路径，实习的公司能留下来为啥还会参加秋招，投了哪些公司，职业规划，为啥投网易，薪资要求，还有就是一些调查式的问题了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>啊呀，虽然走完了流程，但是表示心里很方啊。不过也好，又深刻地认识到了一个不足之处，只有被吊打之后才有强劲动力去弥补啊。好的吧，自我安慰到此结束，还是继续学习吧…毕竟前路茫茫~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年网易公共技术秋招-前端开发工程师。&lt;/p&gt;
&lt;p&gt;记录一下噢。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面经" scheme="http://hu33.tech/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript常见编程题（下）</title>
    <link href="http://hu33.tech/2017/08/28/JavaScript%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://hu33.tech/2017/08/28/JavaScript常见编程题（下）/</id>
    <published>2017-08-28T15:10:07.346Z</published>
    <updated>2019-01-13T13:21:34.782Z</updated>
    
    <content type="html"><![CDATA[<ol><li>用两个栈实现队列 </li><li>实现对象的深克隆  <code>deepClone</code></li><li>实现函数防抖和节流  <code>debounce</code>, <code>thottle</code></li><li>模拟ES5 bind实现 <code>Function.prototype.bind</code></li><li>用函数表达<code>new</code>实例化的过程  <code>createObject</code></li><li>实现懒加载 <code>lazyLoad</code></li><li>实现一个LazyMan  <code>LazyMan</code></li></ol><a id="more"></a><h4 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h4><p>用两个栈来实现一个队列，完成队列的enqueue和dequeue操作。 队列中的元素为int类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueue</span>(<span class="params">inputStack, item</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> inputStack.push(item);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span>(<span class="params">inputStack, outputStack</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (outputStack.length &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">while</span> (inputStack.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            outputStack.push(inputStack.pop());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> outputStack.pop();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="实现对象的深克隆"><a href="#实现对象的深克隆" class="headerlink" title="实现对象的深克隆"></a>实现对象的深克隆</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'return'</span> + obj.toString());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</div><div class="line">        <span class="keyword">if</span> (obj[key] === obj) &#123;</div><div class="line">            <span class="keyword">continue</span> ;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj[key]) || <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</div><div class="line">            target[key] = deepClone(obj[key]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            target[key] = obj[key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="实现函数防抖和节流"><a href="#实现函数防抖和节流" class="headerlink" title="实现函数防抖和节流"></a>实现函数防抖和节流</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//防抖：等待事件触发后等一段时间再执行，如果触发频率高于设定的延迟时间，就一直等下去</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, interval</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> timer, firstTime = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        clearTimeout(timer);  <span class="comment">//每次触发前都清空定时器，重新计时</span></div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</div><div class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">if</span>(firstTime) &#123;</div><div class="line">            firstTime = <span class="literal">false</span>;</div><div class="line">            fn.apply(self, args);</div><div class="line">        &#125;</div><div class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            fn.apply(self, args);</div><div class="line">        &#125;, interval || <span class="number">500</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//节流：不论触发频率，单位时间内指定函数就只被调用一次</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, interval</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> timer, firstTime = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</div><div class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">if</span> (firstTime) &#123;  <span class="comment">//第一次立即执行</span></div><div class="line">            firstTime = <span class="literal">false</span>;</div><div class="line">            fn.apply(<span class="keyword">this</span>, args);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (timer) &#123;    <span class="comment">//上次的延迟还没执行</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   <span class="comment">//延迟执行</span></div><div class="line">            clearTimeout(timer);</div><div class="line">            timer = <span class="literal">null</span>;</div><div class="line">            fn.apply(<span class="keyword">this</span>, args);</div><div class="line">        &#125;, interval || <span class="number">500</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>####模拟ES5bind实现Function.prototype.bind</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">        self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="keyword">this</span> : context, args.concat(bindArgs));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</div><div class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</div><div class="line">    <span class="keyword">return</span> fBound;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="external">参考</a></p></blockquote><p>####用函数表达new实例化的过程 createObject</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>;</div><div class="line">  <span class="keyword">var</span> Constructor = <span class="built_in">Array</span>.shift.call(<span class="built_in">arguments</span>);</div><div class="line">  obj.__proto__ = Constructor.prototype;</div><div class="line">  <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret : obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="external">参考</a></p></blockquote><p>####实现一个LazyMan</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_LazyMan</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.tasks = [];   </div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> fn =(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> name = n;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"Hi! This is "</span> + name + <span class="string">"!"</span>);</div><div class="line">            self.next();</div><div class="line">        &#125;</div><div class="line">    &#125;)(name);</div><div class="line">    <span class="keyword">this</span>.tasks.push(fn);</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        self.next();</div><div class="line">    &#125;, <span class="number">0</span>); <span class="comment">// 在下一个事件循环启动任务</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 事件调度函数 */</span></div><div class="line">_LazyMan.prototype.next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span>.tasks.shift();</div><div class="line">    fn &amp;&amp; fn();</div><div class="line">&#125;</div><div class="line"></div><div class="line">_LazyMan.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">var</span> fn =(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"Eat "</span> + name + <span class="string">"~"</span>);</div><div class="line">            self.next()</div><div class="line">        &#125;</div><div class="line">    &#125;)(name);</div><div class="line">    <span class="keyword">this</span>.tasks.push(fn);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 实现链式调用</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">_LazyMan.prototype.sleep = <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span>(<span class="params">time</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"Wake up after "</span> + time + <span class="string">"s!"</span>);</div><div class="line">                self.next();</div><div class="line">            &#125;, time * <span class="number">1000</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;)(time);</div><div class="line">    <span class="keyword">this</span>.tasks.push(fn);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">_LazyMan.prototype.sleepFirst = <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"Wake up after "</span> + time + <span class="string">"s!"</span>);</div><div class="line">                self.next();</div><div class="line">            &#125;, time * <span class="number">1000</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;)(time);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.tasks.unshift(fn);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 封装 */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LazyMan</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _LazyMan(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><a href="https://zhuanlan.zhihu.com/p/22387417" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/22387417</a></p><p><a href="http://www.jianshu.com/p/f1b7cb456d37" target="_blank" rel="external">http://www.jianshu.com/p/f1b7cb456d37</a></p></blockquote><h4 id="实现懒加载"><a href="#实现懒加载" class="headerlink" title="实现懒加载"></a>实现懒加载</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyLoad</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> imgs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>);</div><div class="line">    <span class="keyword">var</span> n = <span class="number">0</span>;  <span class="comment">//提升的变量，避免每次都从第一张图片进行遍历</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> clientHeight = <span class="built_in">document</span>.documentElement.clientHeight;</div><div class="line">        <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</div><div class="line">        </div><div class="line">        <span class="keyword">var</span> i, len;</div><div class="line">        <span class="keyword">for</span> (i = n, len = imgs.length; i &lt; length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (imgs[i].offsetTop &lt; clientHeight + scrollTop) &#123;</div><div class="line">                <span class="keyword">if</span> (imgs[i].getAttribute(<span class="string">'src'</span>) === <span class="string">'images/loading.gif'</span>) &#123;</div><div class="line">                    imgs[i].src = imgs[i].getAttribute(<span class="string">'data-src'</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        n++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.addEventListner(<span class="string">'scroll'</span>, throttle(lazyLoad, <span class="number">200</span>), <span class="literal">false</span>);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;用两个栈实现队列 &lt;/li&gt;
&lt;li&gt;实现对象的深克隆  &lt;code&gt;deepClone&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实现函数防抖和节流  &lt;code&gt;debounce&lt;/code&gt;, &lt;code&gt;thottle&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;模拟ES5 bind实现 &lt;code&gt;Function.prototype.bind&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用函数表达&lt;code&gt;new&lt;/code&gt;实例化的过程  &lt;code&gt;createObject&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实现懒加载 &lt;code&gt;lazyLoad&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实现一个LazyMan  &lt;code&gt;LazyMan&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
      <category term="编程题" scheme="http://hu33.tech/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript常见编程题（中）</title>
    <link href="http://hu33.tech/2017/08/26/JavaScript%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
    <id>http://hu33.tech/2017/08/26/JavaScript常见编程题（中）/</id>
    <published>2017-08-26T14:37:38.596Z</published>
    <updated>2019-01-13T13:19:44.426Z</updated>
    
    <content type="html"><![CDATA[<ol><li>判断字符串是否为回文串  <code>isPalindrom</code></li><li>乱序同字母字符串  <code>isAnagram</code></li><li>统计一个字符串出现最多的字母  <code>findMaxDuplicateChar</code></li><li>计算二进制中1的个数  <code>countBit</code></li><li>随机生成指定长度的字符串  <code>randomString</code></li><li>判断传入值是否为2的乘方  <code>is2power</code></li><li>使用递归实现二进制转换  <code>decimalToBinary</code></li><li>判断大括号是否闭合  <code>isBalanced</code></li><li>生成斐波拉契数列   <code>getFibonacci</code></li></ol><a id="more"></a><h4 id="判断字符串是否为回文串"><a href="#判断字符串是否为回文串" class="headerlink" title="判断字符串是否为回文串"></a>判断字符串是否为回文串</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//循环</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrom</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> i, len;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = str.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (str.charAt(i) !== str.charAt(len-i<span class="number">-1</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//借用数组的reverse()</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrom</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) === str;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="乱序同字母字符串"><a href="#乱序同字母字符串" class="headerlink" title="乱序同字母字符串"></a>乱序同字母字符串</h4><p>给定两个字符串，判断是否颠倒字母而成的字符串，譬如 Mary 和 Army 就是同字母而顺序颠倒。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isAnagram</span>(<span class="params">str1, str2</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sortedStr1 = str1.toLowerCase().split(<span class="string">''</span>).sort().join(<span class="string">''</span>);</div><div class="line">    <span class="keyword">var</span> sortedStr2 = str2.toLowerCase().split(<span class="string">''</span>).sort().join(<span class="string">''</span>);</div><div class="line">    <span class="keyword">return</span> sortedStr1 === sortedStr2;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="统计一个字符串出现最多的字母"><a href="#统计一个字符串出现最多的字母" class="headerlink" title="统计一个字符串出现最多的字母"></a>统计一个字符串出现最多的字母</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxDuplicateChar</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> hashObj = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> i, len;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = str.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">var</span> char = str.charAt(i);</div><div class="line">        <span class="keyword">if</span> (hashObj[char]) &#123;</div><div class="line">            hashObj[char]++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            hashObj[char] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(hashObj);</div><div class="line">    <span class="keyword">var</span> max = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> maxChar = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> hashObj) &#123;</div><div class="line">        <span class="keyword">if</span> (hashObj[item] &gt; max) &#123;</div><div class="line">            max = hashObj[item];</div><div class="line">            maxChar = item;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxChar;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="计算二进制中1的个数"><a href="#计算二进制中1的个数" class="headerlink" title="计算二进制中1的个数"></a>计算二进制中1的个数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用字符的toString方法，对负整数不管用</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countBit</span>(<span class="params">binaryNum</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> binaryStr = binaryNum.toString(<span class="number">2</span>).replace(<span class="regexp">/0/g</span>,<span class="string">''</span>);</div><div class="line">    <span class="keyword">return</span> binaryStr.length;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用1与n进行与运算，再将n进行无符号右移</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countBit</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (n !== <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="number">1</span> &amp; n) &#123;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">        n = n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//n与n-1进行与运算</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countBit</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (n !== <span class="number">0</span>) &#123;</div><div class="line">        count++;</div><div class="line">        n = n &amp; (n - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><a href="http://www.jianshu.com/p/0b881319745f" target="_blank" rel="external">参考</a></p></blockquote><h4 id="随机生成指定长度的字符串"><a href="#随机生成指定长度的字符串" class="headerlink" title="随机生成指定长度的字符串"></a>随机生成指定长度的字符串</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用36进制大数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomString</span>(<span class="params">len</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> randomStr = <span class="string">""</span>;</div><div class="line">    <span class="keyword">while</span> (randomStr.length &lt; len) &#123;</div><div class="line">        randomStr += <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).substr(<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> randomStr.substr(<span class="number">0</span>, len);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//枚举所有字符，有点蠢额...</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomString</span>(<span class="params">len</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> randomStr = <span class="string">""</span>;</div><div class="line">    <span class="keyword">var</span> strArr = [<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>,<span class="string">"g"</span>,<span class="string">"h"</span>,<span class="string">"i"</span>,<span class="string">"j"</span>,<span class="string">"k"</span>,<span class="string">"l"</span>,<span class="string">"m"</span>,<span class="string">"n"</span>,<span class="string">"o"</span>,<span class="string">"p"</span>,<span class="string">"q"</span>,<span class="string">"r"</span>,<span class="string">"s"</span>,<span class="string">"t"</span>,<span class="string">"u"</span>,<span class="string">"v"</span>,<span class="string">"w"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>];</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">var</span> pos = <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * strArr.length);</div><div class="line">        <span class="built_in">console</span>.log(pos);</div><div class="line">        randomStr += strArr[pos];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> randomStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="判断传入值是否为2的乘方"><a href="#判断传入值是否为2的乘方" class="headerlink" title="判断传入值是否为2的乘方"></a>判断传入值是否为2的乘方</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//若num是2的乘方，那么num &amp; num - 1为0</span></div><div class="line"><span class="comment">//如num为8时，其二进制为1000，num-1的二进制为0111，num &amp; (num-1) === 0</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">is2power</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(num &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((num &amp; (num - <span class="number">1</span>)) === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="使用递归实现二进制转换"><a href="#使用递归实现二进制转换" class="headerlink" title="使用递归实现二进制转换"></a>使用递归实现二进制转换</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">decimalToBinary</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> decimalToBinary((n - <span class="number">1</span>) / <span class="number">2</span>) + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> decimalToBinary(n / <span class="number">2</span>) + <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">''</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="判断大括号是否闭合"><a href="#判断大括号是否闭合" class="headerlink" title="判断大括号是否闭合"></a>判断大括号是否闭合</h4><p>创建一个函数来判断给定的表达式中的大括号是否闭合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBalanced</span>(<span class="params">expression</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (expression.length &lt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> stack = [];</div><div class="line">  <span class="keyword">var</span> i, len;</div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, len = expression.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="keyword">var</span> char = expression.charAt(i);</div><div class="line">    <span class="keyword">if</span> (char === <span class="string">'&#123;'</span>) &#123;</div><div class="line">      stack.push(char);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">'&#125;'</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (stack.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        stack.pop();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (stack.pop())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="生成斐波拉契数列"><a href="#生成斐波拉契数列" class="headerlink" title="生成斐波拉契数列"></a>生成斐波拉契数列</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//for循环</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFibonacci</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">var</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (i &lt; <span class="number">2</span>) &#123;</div><div class="line">            arr.push(<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            arr.push(arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用闭包实现一个Fibonacci数的生成器</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">genFibo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> res = a;</div><div class="line">        a = b;</div><div class="line">        b = res + b;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> genFibo;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFibonacci</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">var</span> genFibo = fibo();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">        arr.push(genFibo());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;判断字符串是否为回文串  &lt;code&gt;isPalindrom&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;乱序同字母字符串  &lt;code&gt;isAnagram&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;统计一个字符串出现最多的字母  &lt;code&gt;findMaxDuplicateChar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;计算二进制中1的个数  &lt;code&gt;countBit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;随机生成指定长度的字符串  &lt;code&gt;randomString&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;判断传入值是否为2的乘方  &lt;code&gt;is2power&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用递归实现二进制转换  &lt;code&gt;decimalToBinary&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;判断大括号是否闭合  &lt;code&gt;isBalanced&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;生成斐波拉契数列   &lt;code&gt;getFibonacci&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
      <category term="编程题" scheme="http://hu33.tech/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>js中的深拷贝</title>
    <link href="http://hu33.tech/2017/08/26/js%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://hu33.tech/2017/08/26/js中的深拷贝/</id>
    <published>2017-08-26T10:24:43.680Z</published>
    <updated>2019-01-13T13:19:00.775Z</updated>
    
    <content type="html"><![CDATA[<p>深拷贝这个坑我一定要来填上了，毕竟绊了我好几次。。。</p><p>先交代一下这次填坑的背景，简单说来就是使用<code>Object.assign</code>来拷贝对象，结果这玩意儿有陷阱啊~害得我项目中<code>setState</code>没有被触发，子组件死活不更新，不<code>render</code>，找了半天问题才发现原来坑在这个地方。</p><a id="more"></a><h3 id="Object-assign-的陷阱"><a href="#Object-assign-的陷阱" class="headerlink" title="Object.assign()的陷阱"></a>Object.assign()的陷阱</h3><p>平常我们写React处理<code>state</code>时，希望数据是immutable，这样处理起来更容易更方便。一般我们喜欢用<code>Object.assign()</code>来复制对象，我一直以为<code>Object.assign()</code>是深复制，会连子节点一起复制。今天项目中的bug让我认识到，我真是错看了它啊~</p><p><code>Object.assign()</code>其实是浅层拷贝，只会对非嵌套的对象进行拷贝，但是如果对象中有嵌套的话，它就只会对被嵌套的对象做引用拷贝了。</p><p>可以看一下Polyfill对<code>Object.assign</code>的实现源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.assign != <span class="string">'function'</span>) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">Object</span>.assign = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</div><div class="line"><span class="meta">  'use strict'</span>;</div><div class="line">   <span class="keyword">if</span> (target === <span class="literal">undefined</span> || target === <span class="literal">null</span>) &#123;</div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot convert undefined or null to object'</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">var</span> output = <span class="built_in">Object</span>(target);</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">1</span>; index &lt; <span class="built_in">arguments</span>.length; index++) &#123;</div><div class="line">     <span class="keyword">var</span> source = <span class="built_in">arguments</span>[index];</div><div class="line">     <span class="keyword">if</span> (source !== <span class="literal">undefined</span> &amp;&amp; source !== <span class="literal">null</span>) &#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> nextKey <span class="keyword">in</span> source) &#123;</div><div class="line">         <span class="keyword">if</span> (source.hasOwnProperty(nextKey)) &#123;</div><div class="line">           output[nextKey] = source[nextKey];</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> output;</div><div class="line">  &#125;;</div><div class="line">  &#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>好的吧，其实<code>Object.assign</code>只是这样设计的，并不能说是它的陷阱，当一回标题党。。。</p><h3 id="js中的深拷贝"><a href="#js中的深拷贝" class="headerlink" title="js中的深拷贝"></a>js中的深拷贝</h3><p>虽然有些时候用<code>Object.assign()</code>也够了，但是一旦对象嵌套，用<code>Object.assign()</code>就很可能出现问题，那就要实现深拷贝了。</p><p>js深拷贝有两种方式：</p><ol><li><p>一种是用JSON对象，简单粗暴</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个方法好处就是简单，粗暴，但是存在两个问题：</p><ul><li>一个是会破坏原型链，深拷贝之后，不管这个对象原来的构造函数是什么，深拷贝之后都会变成<code>Object</code></li><li>另一个是它只能处理<code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Array</code>、扁平对象，即能够被json直接表示的数据结构，无法拷贝属性为<code>Function</code>以及<code>RegExp</code>这类的属性</li><li>但是如果只是想单纯拷贝一个嵌套对象，用它还是可以的。</li></ul></li><li><p>另一种实现方式就是递归拷贝：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span> &amp;&amp; !isFunction(obj)) &#123;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (isFunction(obj)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"return"</span> + obj.toString())();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">var</span> name,value;</div><div class="line">    <span class="keyword">var</span> target = isArray(obj) ? [] : &#123;&#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (name <span class="keyword">in</span> obj) &#123;</div><div class="line">      value = obj[name];</div><div class="line">      <span class="comment">//判断有没有循环引用</span></div><div class="line">      <span class="keyword">if</span> (value === obj) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> (isArray(obj) || isObject(value)) &#123;</div><div class="line">        target[name] = deepClone(obj[name]);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        target[name] = value;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个方法考虑了obj是否为数组、函数以及是否有循环引用的问题，算是比较全面了，但是要实现<code>isArray</code>、<code>isFunction</code>、<code>isObject</code>的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $ = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> types = <span class="string">'Array Object String Date RegExp Function Boolean Number Null Undefined'</span>.split(<span class="string">' '</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">this</span>).slice(<span class="number">8</span>, <span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = types.length; i--;) &#123;</div><div class="line">    $[<span class="string">'is'</span> + types[i]] = (<span class="function"><span class="keyword">function</span> (<span class="params">self</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">elem</span>) </span>&#123;</div><div class="line">           <span class="keyword">return</span> type.call(elem) === self;</div><div class="line">        &#125;;</div><div class="line">    &#125;)(types[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> $;</div><div class="line">&#125;)();<span class="comment">//类型判断</span></div></pre></td></tr></table></figure></li><li><p>可以直接使用那些类库的<code>deepClone</code>方法，比如<code>lodash</code>的<code>cloneDeep</code>、<code>jQuery.extend</code>等</p></li></ol><h3 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h3><p>JS中的对象一般是可变的，因为是使用了引用赋值，新的随心简单的引用了原始对象，这样可以节约内存，但是应用复杂后，会造成很大的隐患。要解决这个问题的话一般就是用浅拷贝或深拷贝来避免被修改了，但是这样会造成CPU和内存的浪费，就是很耗性能啦。</p><p>结合React来看，我们经常在对React应用进行性能优化时会用到<code>shouldComponentUpdate</code>，在这个函数中对state或props进行比较来判断要不要render，但是<code>deepClone</code>和<code>deepCompare</code>都非常消耗性能。但是用Immutable只需要使用<code>===</code>和<code>is</code>比较就能知道是否要执行<code>render()</code>了，所以性能提升是很大的。</p><p>不过具体要不要用，当然得看项目中对这个需求大不大了。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深拷贝这个坑我一定要来填上了，毕竟绊了我好几次。。。&lt;/p&gt;
&lt;p&gt;先交代一下这次填坑的背景，简单说来就是使用&lt;code&gt;Object.assign&lt;/code&gt;来拷贝对象，结果这玩意儿有陷阱啊~害得我项目中&lt;code&gt;setState&lt;/code&gt;没有被触发，子组件死活不更新，不&lt;code&gt;render&lt;/code&gt;，找了半天问题才发现原来坑在这个地方。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript常见编程题（上）</title>
    <link href="http://hu33.tech/2017/08/21/JavaScript%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://hu33.tech/2017/08/21/JavaScript常见编程题（上）/</id>
    <published>2017-08-21T12:23:49.268Z</published>
    <updated>2019-01-13T13:21:10.746Z</updated>
    
    <content type="html"><![CDATA[<ol><li>单个数组去重  <code>unique</code></li><li>两个数组并集、交集、差集  <code>union</code>、<code>intersection</code>、<code>difference</code></li><li>计算数组中元素乘积  <code>productOfArrayExceptSelf</code></li><li>找出数组中最大差值  <code>getMaxProfit</code></li><li>找出连续数组中的缺失数  <code>findMissingNumber</code></li><li>找出整型数组中乘积最大的三个数</li><li>找出出现奇数次的数  <code>findOddTimesNum</code></li><li>二分搜索递归实现  <code>binarySearch</code></li><li>实现一个洗牌算法  <code>shuffle</code></li></ol><a id="more"></a><h4 id="单个数组去重"><a href="#单个数组去重" class="headerlink" title="单个数组去重"></a>单个数组去重</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//HashObject（会自动对传入的键执行toString()）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> result = [];</div><div class="line">    <span class="keyword">let</span> hashObj = &#123;&#125;;</div><div class="line">    <span class="keyword">let</span> i, len;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!hashObj[arr[i]]) &#123;</div><div class="line">            hashObj[arr[i]] = <span class="literal">true</span>;</div><div class="line">            result.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//遍历数组，使用indexOf看元素是否已在result数组中</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> result = [];</div><div class="line">    <span class="keyword">let</span> i,len;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (result.indexOf(arr[i]) === <span class="number">-1</span>) &#123;</div><div class="line">            result.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用filter过滤出index和lastIndex相等的元素</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> result = arr.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</div><div class="line">       <span class="keyword">return</span> index === arr.lastIndexOf(item); </div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><a href="https://www.toobug.net/article/array_unique_in_javascript.html" target="_blank" rel="external">参考</a></p></blockquote><h4 id="两个数组求并集、交集、差集"><a href="#两个数组求并集、交集、差集" class="headerlink" title="两个数组求并集、交集、差集"></a>两个数组求并集、交集、差集</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">arr1, arr2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> arr1.concat(arr2.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">       <span class="keyword">return</span> arr1.indexOf(item) === <span class="number">-1</span>;</div><div class="line">    &#125;));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params">arr1, arr2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> arr1.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> arr1.indexOf(item) !== <span class="number">-1</span> &amp;&amp; arr2.indexOf(item) !== <span class="number">-1</span>;</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">difference</span>(<span class="params">arr1, arr2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> arr1.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> arr2.indexOf(item) === <span class="number">-1</span>;</div><div class="line">    &#125;).concat(arr2.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> arr1.indexOf(item) === <span class="number">-1</span>;</div><div class="line">    &#125;))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ES6</span></div><div class="line"><span class="keyword">const</span> union = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([...arr1, ...arr2]));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> intersection = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> arr1.filter(<span class="function"><span class="params">item</span>=&gt;</span> <span class="keyword">new</span> <span class="built_in">Set</span>(arr2).has(item));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> difference = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1);</div><div class="line">    <span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2);</div><div class="line">    <span class="keyword">return</span> arr1.concat(arr2).filter(<span class="function"><span class="params">item</span> =&gt;</span> !set2.has(item) || !set1.has(item));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ES7</span></div><div class="line"><span class="keyword">const</span> union = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> arr1.concat(arr2.filter(<span class="function"><span class="params">item</span> =&gt;</span> !arr1.includes(item)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> intersection = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> arr1.filter(<span class="function"><span class="params">item</span> =&gt;</span> arr2.includes(item));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> difference = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> arr1.concat(arr2).filter(<span class="function"><span class="params">item</span> =&gt;</span> !arr1.includes(item) || !arr2.includes(item));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="计算数组中元素乘积"><a href="#计算数组中元素乘积" class="headerlink" title="计算数组中元素乘积"></a>计算数组中元素乘积</h4><p>给定某无序数组，要求返回新数组 output ，其中 output[i] 为原数组中除了下标为 i 的元素之外的元素乘积，要求以 O(n) 复杂度实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">productExceptSelf</span>(<span class="params">numArray</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> product = <span class="number">1</span>;</div><div class="line">  <span class="keyword">var</span> size = numArray.length;</div><div class="line">  <span class="keyword">var</span> output = [];</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; size; x++) &#123;</div><div class="line">      output.push(product);</div><div class="line">      product = product * numArray[x];</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> product = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = size - <span class="number">1</span>; i &gt; <span class="number">-1</span>; i--) &#123;</div><div class="line">      output[i] = output[i] * product;</div><div class="line">      product = product * numArray[i];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> output;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><a href="https://www.nowcoder.com/questionTerminal/94a4d381a68b47b7a8bed86f2975db46" target="_blank" rel="external">参考</a></p></blockquote><h4 id="找出数组中最大差值"><a href="#找出数组中最大差值" class="headerlink" title="找出数组中最大差值"></a>找出数组中最大差值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用Math的max和min方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxProfit</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, arr);</div><div class="line">    <span class="keyword">var</span> min = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, arr);</div><div class="line">    <span class="keyword">return</span> max-min;</div><div class="line"><span class="comment">//  return Math.max(...arr) - Math.min(...arr);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="找出连续数组中的缺失数"><a href="#找出连续数组中的缺失数" class="headerlink" title="找出连续数组中的缺失数"></a>找出连续数组中的缺失数</h4><p>给定某无序数组，其包含了 n 个连续数字中的 n - 1 个，已知上下边界，要求以O(n)的复杂度找出缺失的数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMissingNumber</span>(<span class="params">arr, max, min</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arrSum = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> pre + cur;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">var</span> sum = (max * (max + <span class="number">1</span>) / <span class="number">2</span>) - (min * (min - <span class="number">1</span>) / <span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> sum - arrSum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="找出整型数组中乘积最大的三个数"><a href="#找出整型数组中乘积最大的三个数" class="headerlink" title="找出整型数组中乘积最大的三个数"></a>找出整型数组中乘积最大的三个数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先把数组排序，最大乘积要么是min1*min2*max1，要么是max1*max2*max3</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxProduct</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sortedArr = arr.sort(compare);</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> product1 = arr[len - <span class="number">1</span>] * arr[len - <span class="number">2</span>] * arr[len - <span class="number">3</span>];</div><div class="line">    <span class="keyword">var</span> product2 = arr[<span class="number">0</span>] * arr[<span class="number">1</span>] * arr[len - <span class="number">1</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a - b;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="找出出现奇数次的数"><a href="#找出出现奇数次的数" class="headerlink" title="找出出现奇数次的数"></a>找出出现奇数次的数</h4><p>给你n个数，其中有且仅有一个数出现了奇数次，其余的数都出现了偶数次。用线性时间常数空间找出出现了奇数次的那一个数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用hashObj</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getShowOddTimesNumber</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> obj[item] = !obj[item]);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</div><div class="line">    <span class="keyword">if</span>(obj[key]) &#123;</div><div class="line">      <span class="keyword">return</span> key;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//将所有元素都异或一遍，最后得到的就是那个出现奇数次的元素</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getShowOddTimesNumber</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre,cur</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> pre ^ cur;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="二分搜索递归实现"><a href="#二分搜索递归实现" class="headerlink" title="二分搜索递归实现"></a>二分搜索递归实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">arr, value, left, right</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>);</div><div class="line">    <span class="keyword">if</span> (arr[mid] === value) &#123;</div><div class="line">        <span class="keyword">return</span> mid;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; value) &#123;</div><div class="line">        <span class="keyword">return</span> binarySearch(arr, value, left, mid - <span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> binarySearch(arr, value, mid + <span class="number">1</span>, right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>####实现一个洗牌算法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//随机选取数组中的元素添加到另一个数组中，复杂度为n^2</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="keyword">var</span> random;</div><div class="line">    <span class="keyword">while</span> (arr.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length);</div><div class="line">        result.push(arr[randomIndex]);</div><div class="line">        arr.splice(randomIndex, <span class="number">1</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在原数组上进行交换元素的操作，时间复杂度为n</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> randomIndex, tmp;</div><div class="line">    <span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</div><div class="line">        randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * len);</div><div class="line">        len--;</div><div class="line">        tmp = arr[randomIndex];</div><div class="line">        arr[randomIndex] = arr[len];</div><div class="line">        arr[len] = tmp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;单个数组去重  &lt;code&gt;unique&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;两个数组并集、交集、差集  &lt;code&gt;union&lt;/code&gt;、&lt;code&gt;intersection&lt;/code&gt;、&lt;code&gt;difference&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;计算数组中元素乘积  &lt;code&gt;productOfArrayExceptSelf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;找出数组中最大差值  &lt;code&gt;getMaxProfit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;找出连续数组中的缺失数  &lt;code&gt;findMissingNumber&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;找出整型数组中乘积最大的三个数&lt;/li&gt;
&lt;li&gt;找出出现奇数次的数  &lt;code&gt;findOddTimesNum&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;二分搜索递归实现  &lt;code&gt;binarySearch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实现一个洗牌算法  &lt;code&gt;shuffle&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
      <category term="编程题" scheme="http://hu33.tech/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>DOM知识点--《高程》</title>
    <link href="http://hu33.tech/2017/08/14/DOM%E7%9F%A5%E8%AF%86%E7%82%B9--%E3%80%8A%E9%AB%98%E7%A8%8B%E3%80%8B/"/>
    <id>http://hu33.tech/2017/08/14/DOM知识点--《高程》/</id>
    <published>2017-08-14T15:40:14.842Z</published>
    <updated>2019-01-13T13:18:19.828Z</updated>
    
    <content type="html"><![CDATA[<p><em>《JavaScript高级程序设计》DOM相关知识点复习。</em></p><a id="more"></a><h2 id="DOM层次"><a href="#DOM层次" class="headerlink" title="DOM层次"></a>DOM层次</h2><ul><li>DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的树形结构</li><li>文档节点是每个文档的根节点，每个文档只能有一个文档元素（<code>\&lt;html&gt;</code>）</li></ul><h3 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h3><ul><li>JS中所有节点类型都继承自<code>Node</code>类型，因此所有节点类型都共享相同的基本属性和方法</li><li>可用<code>Node.nodeType</code>确定节点类型</li><li>对于元素节点，<code>nodeName</code>保存了元素的标签名，<code>nodeValue</code>值为<code>null</code></li></ul><h4 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h4><p>所有节点都有的三个属性：</p><ul><li><strong>childNodes：</strong>其中保存着一个<code>NodeList</code>对象<ul><li><code>NodeList</code>是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点</li><li><code>NodeList</code>是“动态的”，是在访问DOM文档时实时运行的查询，所以DOM结构的变化能自动反映在<code>NodeList</code>对象中（<code>NamedNodeMap</code>和<code>HTMLCollection</code>也是）</li></ul></li><li><strong>parentNode：</strong>该属性指向文档树中的父节点<ul><li>使用<code>previousSibling</code>和<code>nextSibling</code>可以分别访问节点的前一个节点和后一个节点</li><li>父节点的<code>firstChild</code>和<code>lastChild</code>分别指向<code>childNodes</code>列表中的第一个和最后一个节点</li><li>如果某父节点只有一个子节点，那么<code>firstChild</code>和<code>lastChild</code>指向同一个节点，该子节点的<code>previousSibling</code>和<code>nextSibling</code>都为<code>null</code></li><li><code>hasChildNodes()</code>返回节点是否包含子节点</li></ul></li><li><strong>ownerDocument：</strong>指向表示整个文档的文档节点<ul><li>任何节点都不能同时存在于两个或更多个文档中</li></ul></li></ul><h4 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h4><ul><li><p><code>appendChild(newNode)</code>：向<code>childNodes</code>列表的末尾添加一个节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将第一个子节点移到最后一个</span></div><div class="line"><span class="keyword">var</span> returnNode = someNode.appendChild(someNode.firstChild);</div></pre></td></tr></table></figure></li><li><p><code>insertBefore(newNode)</code>：将节点插入到某个节点之前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//插入后成为最后一个子节点</span></div><div class="line"><span class="keyword">var</span> returnNode = someNode.insertBefore(newNode, <span class="literal">null</span>);</div><div class="line"></div><div class="line"><span class="comment">//插入后成为第一个子节点</span></div><div class="line"><span class="keyword">var</span> returnNode = someNode.insertBefore(newNode, someNode.firstNode);</div><div class="line"></div><div class="line"><span class="comment">//插入到最后一个子节点之前</span></div><div class="line"><span class="keyword">var</span> returnNode = someNode.insertBefore(newNode, someNode.lastChild);</div><div class="line"></div><div class="line"><span class="comment">//实现insertAfter</span></div><div class="line">someNode.parentNode.insertBefore(newNode, someNode.nextSibling);</div></pre></td></tr></table></figure></li><li><p><code>replaceChild(newNode，node)</code>：替换某个子节点</p></li><li><p><code>removeChild(node)</code>：删除某个子节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//移除某节点</span></div><div class="line">someNode.parentNode.removeChild(someNode);</div></pre></td></tr></table></figure></li><li><p>前面四个方法操作的是某个节点的子节点，要使用这几个方法必须先获取父节点</p></li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>有两个方法所有类型的节点都有： <code>cloneNode()</code>和<code>normalize()</code></p><ul><li><code>cloneNode()</code>：用于复制节点，参数为true时执行深复制（复制节点及整个子节点数）<ul><li><code>cloneNode()</code>返回的节点属于文档所有，但是并没有为它指定父节点，需要使用插入操作将其插入到文档中</li><li><code>cloneNode()</code>方法只复制特性、子节点，不会复制添加到节点上的js属性，如事件处理程序</li></ul></li><li><code>normalize()</code>：</li></ul><h3 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h3><ul><li><code>document</code>对象是<code>HTMLDocument</code>的一个实例，表示整个HTML页面，也是<code>window</code>对象的一个属性，因此可以作为全局对象来访问</li></ul><h4 id="文档的子节点"><a href="#文档的子节点" class="headerlink" title="文档的子节点"></a>文档的子节点</h4><ul><li>可以使用<code>documentElement</code>属性（始终指向HTML页面中的<code>\&lt;html&gt;</code>元素）或<code>childNodes</code>列表访问文档元素</li><li><code>body</code>属性，直接指向<code>\&lt;body&gt;</code>元素</li><li><code>doctype</code>属性，指向<code>&lt;!DOCTYPE&gt;</code>标签</li><li>多数情况下，不需要在<code>document</code>对象上调用<code>appendChild()</code>、<code>removeChild()</code>和<code>replaceChild()</code>方法，因为文档类型是只读的，且只能有一个元素子节点</li></ul><h4 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h4><p><code>document</code>对象包含一些可表现网页信息的属性。</p><ul><li><code>title</code>：包含<title>元素中的文本</title></li><li><code>URL</code>：包含页面的整个URL</li><li><code>domain</code>：包含页面的域名</li><li><code>referrer</code>：保存着链接到当前页面的那个页面的<code>URL</code></li></ul><p>上面三个属性中，只有<code>domain</code>是可以设置的，但是不能将<code>domain</code>设置为<code>URL</code>不包含的域。</p><p>[通过将不同子域页面的<code>document.domain</code>设为相同的值，就能相互访问对方包含的JavaScript对象了]</p><h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><ul><li><code>getElementById(id)</code>：返回文档中第一次出现的元素（若无则返回<code>null</code>）</li><li><code>getElementsByTagName(tagName)</code>：返回包含零或多个元素的<code>NodeList</code>（在HTML文档中，返回一个<code>HTMLCollection</code>对象）</li><li><code>getElementByName()</code>：返回带有给定<code>name</code>特性的所有元素（一般用来取得单选按钮）</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>使用<code>document.implementation.hasFeature(name, version)</code>检测浏览器是否支持某版本的DOM功能</li><li>使用<code>write()</code>和<code>whiteln()</code>动态向页面中添加内容</li><li>使用<code>open()</code>和<code>close()</code>分别用于打开和关闭网页的输出流</li></ul><h3 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h3><ul><li>要访问元素的标签名，可以用<code>codeName</code>或<code>tagName</code>属性</li><li>HTML中，标签名始终全部大写，XML中，标签名始终与源代码中保持一致</li></ul><h4 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h4><p><code>HTMLElement</code>类型直接继承自<code>Element</code>并添加了一些属性（每个HTML元素中都存在）：<code>id</code>、<code>title</code>、<code>lang</code>、<code>dir</code>、<code>className</code></p><h4 id="操作特性"><a href="#操作特性" class="headerlink" title="操作特性"></a>操作特性</h4><ul><li>获取特性：<code>DOM</code>对象的属性（<code>div.id</code>）、<code>div.getAttribute(&quot;id&quot;)</code>。有两类特殊的特性，其属性值与<code>getAttribute()</code>返回的值不同：<ul><li><code>style</code>：通过属性访问返回一个对象，而用<code>getAttribute()</code>访问返回CSS文本</li><li>事件处理程序（如<code>onClick</code>）：通过属性访问返回一个js函数，用<code>getAttribute()</code>返回相应代码的字符串</li><li>一般使用对象属性获取特性，除非需要自定义特性值，才使用<code>getAttribute()</code></li></ul></li><li>设置特性：<code>setAttribute()</code>。既可以操作HTML特性也可以操作自定义特性。</li><li>删除特性：<code>removeAttribute()</code>。用于彻底删除元素的特性。</li></ul><h4 id="attribute属性"><a href="#attribute属性" class="headerlink" title="attribute属性"></a>attribute属性</h4><ul><li><p><code>Element</code>类型是唯一一个使用<code>attributes</code>属性的DOM节点类型</p></li><li><p><code>attribute</code>属性中包含一个<code>NamedNodeMap</code>，元素的每个特性都由一个<code>Attr</code>节点表示，每个结点都保存在<code>NamedNodeMap</code>对象中。</p></li><li><p><code>NamedNodeMap</code>对象有如下方法：</p><ul><li><code>getNamedItem(name)</code>：返回<code>nodeName</code>为<code>name</code>的特性</li><li>removeNamedItem(name)：删除nodeName为<code>name</code>的特性，并返回该特性的<code>Atrr</code>节点</li><li><code>setNameItem(node)</code>：添加节点，以节点的<code>nodeName</code>属性为索引</li><li><code>item(pos)</code>：返回位于数字<code>pos</code>位置处的节点</li></ul></li></ul><p>[一般要遍历元素的特性时，才会使用<code>attributes</code>属性]</p><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><ul><li>创建元素：<code>document.createElement()</code></li><li>子节点：元素的<code>childNodes</code>属性中包含了它所有子节点</li></ul><h3 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h3><p>其他还比较常见的节点类型有：<code>Text</code>类型、<code>Comment</code>类型、<code>DocumentFragment</code>类型</p><h4 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h4><ul><li>文本节点包含的是纯文本内容，其中包含转义后的HTML字符，但不能包含HTML代码</li><li>每个可以包含内容的元素最多只能有一个文本节点，且必须确实有内容存在</li><li>使用<code>document.createTextNode()</code>创建新文本节点</li><li>在一个包含两个或多个文本节点的父元素上调用<code>normalize()</code>方法，会将所有文本节点合并成一个节点（浏览器在解析文档时永远不会创建相邻的文本节点，这种情况只可能出现在DOM操作中）</li><li>使用<code>splitText()</code>可以将一个文本节点分成两个文本节点（从文本节点中提取数据的DOM解析技术）</li></ul><h4 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h4><ul><li>使用<code>document.createComment()</code>创建注释节点</li><li><code>Comment</code>类型与<code>Text</code>类型继承自相同的基类，拥有除了<code>splitText()</code>之外的所有字符串操作方法</li></ul><h4 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h4><ul><li>所有节点类型中，只有<code>DocumentFragment</code>在文档中没有对应的标记，它可以包含和控制节点，但是不会像完整的文档那样占用额外资源</li><li>可以使用一个文档片保存创建的列表项，然后在一次性将他们添加到文档中，这样可以避免重复渲染</li></ul><h2 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h2><p>对DOM的两个主要的扩展是SelectAPI和HTML。</p><h3 id="选择符API"><a href="#选择符API" class="headerlink" title="选择符API"></a>选择符API</h3><p>SelectAPI致力于让浏览器原生支持CSS查询。</p><ul><li><code>querySelector()</code>：接收一个CSS选择符，返回与该模式匹配的第一个元素:</li><li><code>querySelectorAll()</code>：返回一个NodeList的实例（类似于一组元素的快照，而非不断对文档进行搜索的动态查询）</li><li><code>matchesSelector()</code>：若调用元素与选择符匹配，则返回true，否则返回false</li></ul><h3 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h3><p>Element Traversal API为DOM元素添加了以下5个属性（为了弥补浏览器元素间空格处理不同的差异）：</p><ul><li><code>childElementCount</code>：返回子元素（不包括文本节点和注释）的个数</li><li><code>firstElementChild</code>：指向第一个子元素，<code>firstChild</code>的元素版</li><li><code>lastElementChild</code>：指向最后一个子元素，<code>lastChild</code>的元素版</li><li><code>previousElementSibling</code>：指向前一个同辈元素，<code>previousSibling</code>的元素版</li><li><code>nextElementSibling</code>：指向后一个同辈元素，<code>nextSibling</code>的元素版</li></ul><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><h4 id="与类相关的扩充"><a href="#与类相关的扩充" class="headerlink" title="与类相关的扩充"></a>与类相关的扩充</h4><ul><li><code>getElementByClassName()</code>：返回带有指定类的所有元素的<code>NodeList</code></li><li><code>className</code>属性：用于操作类名，如添加、删除和替换类名</li><li><code>classList</code>属性：也用于操作类名，比<code>className</code>使用更方便安全，有如下方法：<ul><li><code>add(value)</code>：添加类名</li><li><code>remove(value)</code>：删除类名</li><li><code>contains(value)</code>：判断列表中是否存在该类名</li><li><code>toggle(value)</code>：若列表中存在该类名则删除，否则就添加</li></ul></li></ul><h4 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h4><ul><li><code>document.activeElement</code>属性：始终引用DOM中当前获得了焦点的元素</li><li>元素获得焦点的方式有页面加载、用户输入以及在代码中调用<code>focus()</code>方法</li><li>默认情况下，文档加载过程中，<code>document.activeElement</code>的值为<code>null</code>，文档刚刚加载完时，其值为<code>document.body</code>元素的引用</li><li><code>document.hasFocus()</code>可以判断文档是否获得了焦点</li></ul><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><ul><li><code>readyState</code>属性：用来实现一个指示文档已经加载完成的指示器，有两个值：<ul><li><code>loading</code>：正在加载文档</li><li><code>complete</code>：已经加载完文档</li></ul></li><li><code>compatMode</code>属性：说明渲染页面的模式是标准的还是混杂的<ul><li><code>CSS1Compat</code>：标准模式（按照W3C的标准解析和渲染页面）</li><li><code>BackCompat</code>：混杂模式（按浏览器自己的标准解析渲染页面）</li></ul></li><li><code>head</code>属性：指向文档的<code>\&lt;head&gt;</code>元素</li><li><code>charset</code>属性：表示文档中实际使用的字符集，也可以用来指定新字符集</li><li><code>dataset</code>属性：用于访问自定义属性的值，为一个<code>DOMStringMap</code>的实例</li><li><code>scrollIntoView()</code>方法：通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中</li></ul><h4 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h4><ul><li><code>innerHTML</code>属性：<ul><li>读模式下，<code>innerHTML</code>返回与所有子节点对应的HTML标记</li><li>写模式下，<code>innerHTML</code>的值会被解析成DOM子树，替换调用元素原来的所有子节点</li><li>可以使用<code>window.toStaticHTML()</code>处理HTML字符串，删除所有脚本节点和事件处理程序属性</li></ul></li><li><code>outerHTML</code>属性：返回调用它的元素及其所有子节点的HTML标签</li><li><code>insertAdjacentHTML()</code>：接受两个参数，插入位置和要插入的HTML文本，第一个参数必须是下列值之一：<ul><li><code>beforeBegin</code>：在当前元素之前插入一个紧邻的同辈元素</li><li><code>afterBegin</code>：在当前元素下插入一个新的子元素或在第一个子元素前插入新的元素</li><li><code>beforeEnd</code>：在当前元素下插入一个新的子元素或在最后一个子元素后再插入新元素</li><li><code>afterEnd</code>：在当前元素之后插入一个紧邻的同辈元素</li></ul></li><li>在使用上面的属性将元素从文档中删除时，元素与事件处理程序之间的绑定关系在内存中并没有一并删除，所以最好手动删除要被替换的元素的所有事件处理程序和JS对象属性</li></ul><h2 id="DOM2和DOM3"><a href="#DOM2和DOM3" class="headerlink" title="DOM2和DOM3"></a>DOM2和DOM3</h2><ul><li><code>importNode()</code>：从一个文档中取得一个节点，然后将其导入另一个文档（跟<code>Element</code>的<code>cloneNode()</code>相似）</li><li><code>isSameNode()</code>：两个节点引用的是同一个对象时返回true</li><li><code>isEqualNode()</code>：两个节点是相同的类型，具有相等的属性，且其<code>attributes</code>和<code>childNodes</code>属性也相等，就返回true</li></ul><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><h4 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h4><ul><li><p>偏移量：包括元素在屏幕上占用高度所有可见空间</p><ul><li><code>offsetHeight</code>：height+padding(top+bottom)+border(top+bottom)</li><li><code>offsetWidth</code>：width+padding(top+bottom)+border(top+bottom)</li><li><code>offsetTop</code>：top+marginTop，表示距离<code>offsetParent</code>的左间距</li><li><code>offsetLeft</code>：left+marginLeft</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//得到某个元素在页面上的偏移量，将该元素的offsetLeft和offsetTop与其offsetParent的相同属性想家，如此循环至根元素</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementLeft</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> actualLeft = element.offsetLeft;</div><div class="line">  <span class="keyword">var</span> current = element.offsetParent;</div><div class="line">  <span class="keyword">while</span>(current != <span class="literal">null</span>) &#123;</div><div class="line">    actualLeft += current.offsetLeft;</div><div class="line">    current = current.offsetElement;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> actualLeft;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>客户区大小（<code>clientWidth</code>，<code>clientHeight</code>）：指元素内容及其内边距所占据的空间大小，通常用于确定浏览器视口大小（<code>document.body.clientWidth</code> || <code>document.documentElementWidth</code>）</p></li><li><p>滚动大小：包含滚动内容的元素的大小</p><ul><li><p><code>scrollHeight</code>：在没有滚动条的情况下，元素内容的总高度</p></li><li><p><code>scrollWidth</code>：在没有滚动条的情况下，元素内容的总宽度</p><p>[<code>scrollHeight</code>和<code>scrollWidth</code>主要用于确定元素内容的实际大小]</p></li></ul></li></ul><ul><li><p><code>scrollLeft</code>：被隐藏在内容区域左侧的像素数</p></li><li><p><code>scrollTop</code>：被隐藏在内容区域上方的像素数</p><p>[元素未被滚动时，<code>scrollLeft</code>和<code>scrollTop</code>的值为0，将这两个值设为0可以重置元素的滚动位置]</p></li></ul><ul><li><code>getBoundingClientRect()</code>：返回一个矩形对象，包含<code>left</code>、<code>top</code>、<code>right</code>和<code>bottom</code>四个属性，给出了元素在页面中相对于视口的位置</li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>DOM2级遍历和范围模块定义了两个类型用于辅助进行DOM结构的遍历：<code>NodeIterator</code>、<code>TreeWalker</code>，这两个类型都是基于给定的起点对DOM结构进行深度优先的遍历操作。</p><h4 id="NodeIterator"><a href="#NodeIterator" class="headerlink" title="NodeIterator"></a>NodeIterator</h4><ul><li>可以使用<code>document.createNodeIterator()</code>创建<code>NodeIterator</code>实例，该方法接收四个参数：<ul><li><code>root</code>：搜索起点节点</li><li><code>whatToShow</code>：表示要访问哪些节点的数字节点</li><li><code>filter</code>：一个<code>NodeFilter</code>对象，或一个表示应该接收还是拒绝某种特定节点的函数</li><li><code>entityReferenceExpansion</code>：表示是否要扩展实体引用</li></ul></li><li><code>nextNode()</code>：在深度优先的DOM子树遍历中，用于向前前进一步，第一次调用会返回根节点</li><li><code>previousNode()</code>：用户向后后退一步</li></ul><h4 id="TreeWalker"><a href="#TreeWalker" class="headerlink" title="TreeWalker"></a>TreeWalker</h4><ul><li><code>TreeWalker</code>是<code>NodeIterator</code>的一个更高级的版本，除了<code>nextNode</code>和<code>previousNode</code>以外，还有几个其他方法：<ul><li><code>parentNode()</code>：遍历到当前节点的父节点</li><li><code>firstChild()</code>：遍历到当前节点的第一个子节点</li><li><code>lastChild()</code>：遍历到当前节点的最后一个子节点</li><li><code>nextSibling()</code>：遍历到当前节点的下一个同辈节点</li><li><code>previousSibling()</code>：遍历到当前节点的上一个同辈节点</li></ul></li><li>使用<code>document.createTreeWalker()</code>创建<code>TreeWalker</code>实例</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;《JavaScript高级程序设计》DOM相关知识点复习。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="笔记" scheme="http://hu33.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
      <category term="DOM" scheme="http://hu33.tech/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>来自M小姐的毒药</title>
    <link href="http://hu33.tech/2017/08/02/%E6%9D%A5%E8%87%AAM%E5%B0%8F%E5%A7%90%E7%9A%84%E6%AF%92%E8%8D%AF/"/>
    <id>http://hu33.tech/2017/08/02/来自M小姐的毒药/</id>
    <published>2017-08-02T15:35:16.084Z</published>
    <updated>2019-01-10T14:17:28.739Z</updated>
    
    <content type="html"><![CDATA[<p>M小姐是我上研究生认识的，是我的硕士同班同学兼实验室伙伴兼项目战友兼寝室室友兼实习同事兼实习室友兼我的亲人。</p><p>在见到她之前，听另一个室友说，她比我还瘦。我感到无比惊讶，比那时候的我还瘦得瘦成什么样。</p><p>第一眼见到她时，是在二舍寝室，她面向着门背对着窗，明明无比逆光，我却清楚地看到了她脸上洋溢的微笑，热情而亲切。而逆光下的她的身形一览无遗，当时我就在想，真是个小巧玲珑的妹子。</p><a id="more"></a><p><strong>M小姐是个特别善良的妹子。</strong></p><p>某个周六我们赖在寝室不想出门吃饭，M回来后看到我们一副懒虫样，提出可以帮我们带饭。我们也不是那么无理的人啊，怎么好意思让人家专门跑一趟给带饭呢，就拒绝了。结果M小姐特别执着地说，没关系的，我刚好想出去走走，就顺便帮你们带吧，不然你们下午会饿的，硬生生地说服了我们接受了她的帮助。回来时可开心了，还怕我们过意不去一个劲儿地给我们洗脑说是她自己想出去走走的，当时我就在想，真是个善良可爱的妹子。</p><p>知乎上有句话我特别同意，一个人最大的善良就是在别人休息时轻手关门轻声讲话。我曾经觉得我就属于这类人，但是认识了M小姐后，我才发现M小姐才是高手啊。在学校时，M小姐早上都醒得很早，还没7点就醒了，而我们寝室的水龙头声音特别大，开关门的声音也特别大，M小姐怕这么早会影响我们休息，就在床上躺到7点半才起床。实际上，M小姐啥时候起床啥时候走的我们也不知道，因为她动作特别轻。M小姐没有准备台灯，但是早上起来既不开灯也不拉开点窗帘，每早都是举着手机收拾完自己。有次无意间发现，M小姐为了不让光透进寝室照醒我们，她竟然是从窗帘缝里钻出寝室去的阳台，这个妹子，实在是太为人着想了。</p><p><strong>M小姐是个特别细心的妹子。</strong></p><p>我是出了名的健忘，自从跟M小姐混在一起后，我就更健忘了。因为细心的M小姐什么都会帮我记住，什么时候要去哪里，出门要带什么东西，去超市要买什么，欠了谁的钱谁欠了我的钱都给我记着了。M小姐有时候在认真看电视，突然来一句，你上次说的那件事办了吗？我：……额，差点忘了……有了细心的M小姐，我根本没理由逼自己记住这一切啊。</p><p>以前出去玩手机电量一定不能低于90%，因为要查路线查导航，但是跟M小姐出去手机关机都不怕～毕竟M小姐是我公认的活地图，去过一次的地方就记住地点了，走过一遍的路就记住路线了。所以跟M小姐出门，只管带上自己就好了。</p><p><strong>M小姐是个特别认真的妹子。</strong></p><p>309实验室是个特别不正经的场所，但是里面出了个特别认真的M小姐。起初这对M小姐可不是什么好事，认真的M小姐在我们这群老司机段子手中间总是略显格格不入。可这也不是什么坏事，正经的M小姐不知不觉中就被带偏了，现在是个开车稳段子冷的正经妹子了。不过尽管那群老司机们带偏了M小姐，M小姐仍然是个非常认真的人。有句话怎么说的来着，狗改不了吃屎？（原谅我没文化……）</p><p>不管你跟M小姐讲什么，她都会非常认真地帮你分析。虽然你的有些观点她未必赞同，但她会认真地站在你的角度去理解，然后一本正经地告诉你应该怎样，不敷衍。</p><p><strong>M小姐是个特别有活力的妹子。</strong></p><p>在跟M小姐同居之前，我们一直都觉得M小姐是个永动机，从来都不知累为何物。每次我们出去浪，临近回来时我就开始叫累不迭，连回去的力气都没了。可是M小姐还是精力不减，还能又蹦又跳，继续奋战。但是有一点M小姐比不上我，那就是…吃！M小姐有时候很想多尝试些美食，无奈胃容量有限，只能安慰自己下次再来了。</p><p><strong>M小姐给我下毒了。</strong></p><p>上面夸了M小姐那么多，那都是可忽略的，接下来这点才重要，她对我下毒这件事才重要。</p><p>曾经，我生活独立精神独立，可以一个人背着书包去自习室，一个人带着饭卡去食堂，一个人拿着球拍去球馆，一个人拉着行李去实习，不需要朋友的关心不需要倾诉的对象不需要所谓的精神寄托，很会掩饰自己的感情不轻易表现自己的情绪。用高中闺蜜们的话来说，就是太坚强，让人有距离感。</p><p>可是M小姐竟然给我下了慢性毒药。我有什么决定会愿意告诉M小姐，M小姐会先帮我分析一波然后表示支持我的决定；我有什么开心的事情会乐于跟M小姐分享，M小姐会特别开心地为我的开心而开心；我有什么难过伤感的情绪会在M小姐面前流露，M小姐都会想办法帮我排解忧愁；更可怕的是，有些事情我以为可以藏在心里一辈子，但会不经意间跟M小姐说起。想到这，真是觉得可怕，M小姐都知道我所有的秘密了。</p><p>在学校的时候，我们都亲切地称M小姐为“天使”，但是这个天使都快把我毒害成孩子了，那个坚强独立的人设已经被毒没了。毕竟，健忘的时候有人帮你记着事情，出门的时候有人帮你导航路线，犯懒的时候有人帮你做好早餐，难过的时候有人切好水果放你面前，开心有人跟你分享，伤心有人陪你聊天，委屈有人替你心疼。还要啥坚强！要啥独立！</p><p>我在想啊，要是我以后找不到男朋友，M小姐是要背一半锅的。</p><p><strong>这才是重点。</strong></p><p>恩，上面其实都不是重点，重点是，这么好这么优秀的一个妹子，是单身哦~现附上背影一张~</p><p><img src="https://hu33.github.io/images/来自M小姐的毒药/1.jpg" alt=""></p><p>心动不如行动，汉子们，燥起来吧^O^ </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;M小姐是我上研究生认识的，是我的硕士同班同学兼实验室伙伴兼项目战友兼寝室室友兼实习同事兼实习室友兼我的亲人。&lt;/p&gt;
&lt;p&gt;在见到她之前，听另一个室友说，她比我还瘦。我感到无比惊讶，比那时候的我还瘦得瘦成什么样。&lt;/p&gt;
&lt;p&gt;第一眼见到她时，是在二舍寝室，她面向着门背对着窗，明明无比逆光，我却清楚地看到了她脸上洋溢的微笑，热情而亲切。而逆光下的她的身形一览无遗，当时我就在想，真是个小巧玲珑的妹子。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://hu33.tech/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="人物" scheme="http://hu33.tech/tags/%E4%BA%BA%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>React相关面试题</title>
    <link href="http://hu33.tech/2017/07/31/React%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://hu33.tech/2017/07/31/React相关面试题/</id>
    <published>2017-07-31T14:32:07.756Z</published>
    <updated>2019-01-10T14:00:09.317Z</updated>
    
    <content type="html"><![CDATA[<ol><li>React解决了什么问题</li><li>如何设计一个好的组件</li><li>组件的render函数在何时被调用</li><li>调用render时DOM就一定会被更新吗</li><li>组件的生命周期</li><li>进行远程数据加载时，应该在哪个周期中完成</li><li>在哪些生命周期中可以修改组件的state</li><li>不同父节点的组件需要对彼此的状态进行改变时应该怎么实现</li><li>state里应该有什么</li><li>如何对组件进行优化</li><li>组件中的key属性有什么用</li><li>Component与Element和Instance的区别</li><li>调用setState时，发生了什么事</li><li>什么时候使用类组件（Class Component）而非功能组件（Functional Component）</li><li>什么是React的refs，为什么它们很重要</li><li>受控组件（controlled component）和不受控组件（uncontrolled component）有什么区别</li><li>描述事件在React中的处理方式</li></ol><a id="more"></a><h3 id="React解决了什么问题？"><a href="#React解决了什么问题？" class="headerlink" title="React解决了什么问题？"></a>React解决了什么问题？</h3><p><strong>a. React实现了Virtual DOM</strong></p><p>在一定程度上提升了性能，尤其是在进行小量数据更新时。因为DOM操作是很耗性能的，而Virtual DOM是在内存中进行操作的，当数据发生变化时，通过diff算法比较两棵树之间的变化，再进行必要的DOM更新，省去了不必要的高消耗的DOM操作。当然，这种性能优化主要体现在有小量数据更新的情况下。因为React的基本思维模式是每次有变动就重新渲染整个应用，简单想来就是直接重置innerHTML，比如说在一个大型列表所有数据都变动的情况下，重置innerHTML还比较合理，但若是只有一行数据变了，它也需要重置整个innerHTML，就会造成大量的浪费。而Virtual DOM虽然进行了JS层面的计算，但是比起DOM操作来说，简直不要太便宜。</p><blockquote><p><a href="https://www.zhihu.com/question/31809713" target="_blank" rel="external">为什么操作真实DOM比React更快？</a></p></blockquote><p><strong>b. React的一个核心思想是声明式编程。</strong></p><p>命令式编程是解决做什么的问题，就像是下命令一样，关注于怎么做，而声明式编程关注于得到什么结果，在React中，我们只需要关注“目前的状态是什么”，而不是“我需要做什么让页面变成目前的状态”。React就是不断声明，然后在特定的参数下渲染UI界面。这种编程方式可以让我们的代码更容易被理解，从而易于维护。</p><p><strong>c. 组件化</strong></p><p>React天生组件化，我们可以将一个大的应用分割成很多小组件，这样有好几个优势。首先组件化的代码像一棵树一样清楚干净，比起传统的面条式代码可读性更高；其次前端人员在开发过程中可以并行开发组件而不影响，大大提高了开发效率；最重要的是，组件化使得复用性大大提高，团队可以沉淀一些公共组件或工具库。</p><p><strong>d. 单向数据流</strong></p><p>在React中数据流是单向的，由父节点流向子节点，如果父节点的props发生了变化，那么React会递归遍历整个组件树，重新渲染所有使用该属性的子组件。这种单向的数据流一方面比较清晰不容易混乱，另一方面是比较好维护，出了问题也比较好定位。</p><h3 id="如何设计一个好组件"><a href="#如何设计一个好组件" class="headerlink" title="如何设计一个好组件"></a>如何设计一个好组件</h3><p>组件的主要目的是为了更好的复用，所以在设计组件的时候需要遵循高内聚低耦合的原则。</p><ul><li>可以通过遵循几种设计模式原则来达到高复用的目的，比如单一职责原则：React推崇的是“组合”而非“继承”，所以在设计时尽量不设计大的组件，而是开发若干个单一功能的组件，重点就是每个组件只做一件事；开放/封闭原则，就是常说的对修改封闭，对扩展开放。在React中我们可以用高阶组件来实现。</li><li>使用高阶组件来实现组件的复用。高阶组件就是一个包装了另一个React组件的React组件，它包括属性代理（高阶组件操控着传递给被包裹组件的属性）和反向继承（实际上高阶组件继承被包裹组件）。我们可以用高阶组件实现代码复用，逻辑抽象。</li><li>使用容器组件来处理逻辑，展示组件来展示数据（也就是逻辑处理与数据展示分离）。比如可以在容器组件中进行数据的请求与处理，然后将处理后的数据传递给展示组件，展示组件只负责展示，这样容器组件和展示组件就可以更好地复用了。</li><li>编写组件代码时要符合规范，总之就是要可读性强、复用性高、可维护性好。</li></ul><h3 id="组件的render函数何时被调用"><a href="#组件的render函数何时被调用" class="headerlink" title="组件的render函数何时被调用"></a>组件的render函数何时被调用</h3><ul><li>组件state发生改变时会调用render函数，比如通过setState函数改变组件自身的state值</li><li>继承的props属性发生改变时也会调用render函数，即使改变的前后值一样</li><li>React生命周期中有个componentShouldUpdate函数，默认返回true，即允许render被调用，我们也可以重写这个函数，判断是否应该调用render函数</li></ul><h3 id="调用render时DOM就一定会被更新吗"><a href="#调用render时DOM就一定会被更新吗" class="headerlink" title="调用render时DOM就一定会被更新吗"></a>调用render时DOM就一定会被更新吗</h3><p>不一定更新。</p><p>React组件中存在两类DOM，render函数被调用后， React会根据props或者state重新创建一棵virtual DOM树，虽然每一次调用都重新创建，但因为创建是发生在内存中，所以很快不影响性能。而 virtual dom的更新并不意味着真实DOM的更新，React采用diff算法将virtual DOM和真实DOM进行比较，找出需要更新的最小的部分，这时Real DOM才可能发生修改。</p><p>所以每次state的更改都会使得render函数被调用，但是页面DOM不一定发生修改。</p><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><p>组件生命周期有三种阶段：初始化阶段（Mounting）、更新阶段（Updating）、析构阶段（Unmouting）。</p><p><strong>初始化阶段：</strong></p><ul><li>constructor()：初始化state、绑定事件</li><li>componentWillMount()：在render()之前执行，除了同构，跟constructor没啥差别</li><li>render()：用于渲染DOM。如果有操作DOM或和浏览器打交道的操作，最好在下一个步骤执行。</li><li>componentDidMount()：在render()之后立即执行，可以在这个函数中对DOM就进行操作，可以加载服务器数据，可以使用setState()方法触发重新渲染</li></ul><p><strong>组件更新阶段：</strong></p><ul><li>componentWillReceiveProps(nextProps)：在已挂载的组件接收到新props时触发，传进来的props没有变化也可能触发该函数，若需要实现props变化才执行操作的话需要自己手动判断</li><li>componentShouldUpdate(nextProps，nextState)：默认返回true，我们可以手动判断需不需要触发render，若返回false，就不触发下一步骤</li><li>componentWillUpdate()：componentShouldUpdate返回true时触发，在render之前，可以在里面进行操作DOM</li><li>render()：重渲染</li><li>componentDidUpdate()：render之后立即触发</li></ul><p>组件卸载阶段：</p><ul><li>componentWillUnmount()：在组件销毁之前触发，可以处理一些清理操作，如无效的timers等</li><li>componentDidMount()：卸载后立即触发</li></ul><h3 id="进行远程数据加载时，应该在哪个周期中完成"><a href="#进行远程数据加载时，应该在哪个周期中完成" class="headerlink" title="进行远程数据加载时，应该在哪个周期中完成"></a>进行远程数据加载时，应该在哪个周期中完成</h3><ul><li><p>最好是在<code>componentDidMount</code>中进行异步请求。如果我们将ajax请求放在生命周期其他函数中，如<code>constructor</code>或<code>componentWIllMount</code>中，我们并不能保证请求仅在组件挂载完毕后才响应。如果我们的数据请求在组件挂载前就完成，并调用<code>setState</code>函数将数据添加到组件状态中，对于未挂载的组件会报错。而在<code>componentDidMount</code>中进行ajax请求能有效避免这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component.</div></pre></td></tr></table></figure></li><li><p>React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 <code>componentWillMount</code> 的触发次数。对于 <code>componentWillMount</code> 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 <code>componentWillMount</code>。如果我们将 AJAX 请求放到 <code>componentWillMount</code> 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。[没深入]</p></li></ul><p>顺便说说<code>componentWillMount</code>函数，这个方法是在<code>render</code>前立刻执行的，也是服务器渲染中唯一调用的钩子，其实除了同构的需求，通常情况下可以用<code>constructor()</code>方法代替。</p><h3 id="在哪些生命周期中可以修改组件的state"><a href="#在哪些生命周期中可以修改组件的state" class="headerlink" title="在哪些生命周期中可以修改组件的state"></a>在哪些生命周期中可以修改组件的state</h3><ul><li>componentDidMount和componentDidUpdate</li><li>constructor、componentWillMount中setState会发生错误：setState只能在mounted或mounting组件中执行</li><li>componentWillUpdate中setState会导致死循环</li></ul><h3 id="不同父节点的组件需要对彼此的状态进行改变时应该怎么实现"><a href="#不同父节点的组件需要对彼此的状态进行改变时应该怎么实现" class="headerlink" title="不同父节点的组件需要对彼此的状态进行改变时应该怎么实现"></a>不同父节点的组件需要对彼此的状态进行改变时应该怎么实现</h3><ul><li>在没有Flux之前，Facebook推荐使用事件机制，但是一旦应用中这种需求增多，事件和回调会满天飞</li><li>传递接口，就是需要root传递两个接口给A和B，当A想改变B的状态时，A调用root传递给它的接口，然后这个接口再调用root传给B的接口（这个方法也很不科学）</li><li>用Flux管理状态</li></ul><h3 id="state里应该有什么"><a href="#state里应该有什么" class="headerlink" title="state里应该有什么"></a>state里应该有什么</h3><p>应该有啥：</p><ul><li>事件函数可能进行修改的会导致UI进行渲染的数据</li></ul><p>不应该有啥：</p><ul><li>计算得出的值</li><li>React组件</li><li>props复制来的数据</li></ul><h3 id="如何对组件进行优化"><a href="#如何对组件进行优化" class="headerlink" title="如何对组件进行优化"></a>如何对组件进行优化</h3><ul><li>使用上线构建（Production Build）：会移除脚本中不必要的报错和警告，减少文件体积</li><li>避免重绘：重写shouldComponentUpdate函数，手动控制是否应该调用render函数进行重绘</li><li>尽可能使用Immutable Data：尽可能不修改数据，而是重新赋值数据。这样在检测数据对象是否发生修改方面会非常快，因为只需要检测对象引用即可，不需要挨个检测对象属性的更改</li><li>在渲染组件时尽可能添加key，这样virtual DOM在对比的时候就更容易知道哪里是修改元素，哪里是新插入的元素</li></ul><h3 id="组件中的key属性有什么用"><a href="#组件中的key属性有什么用" class="headerlink" title="组件中的key属性有什么用"></a>组件中的key属性有什么用</h3><p>React中的key是一个特殊的属性，它的出现不是给开发者用的，而是给React自己用的（给一个组件设置了key属性，并不能获取这个组件的key props）</p><p>React使用key来识别组件，它是一种身份标识，每一个key对应一个组件，react认为相同的key是同一个组件，这样后续相同的key就不会被创建</p><p>有了key属性后，就可以与组件建立一种对应关系，react根据key来决定是销毁重新创建组件还是更新组件：</p><ul><li>key相同：若组件属性有变化，react只更新对应的属性；没有变化则不更新</li><li>key值不同：react会先销毁该组件，然后重新创建该组件</li></ul><h3 id="Component与Element和Instance的区别"><a href="#Component与Element和Instance的区别" class="headerlink" title="Component与Element和Instance的区别"></a>Component与Element和Instance的区别</h3><ul><li>Element其实是一个纯粹的Object对象，用于描述在屏幕上看到的DOM节点，这个对象包括type、props、key和ref属性，但不包括DOM方法（React.createElement()）</li><li>Component是组件级别的类：接收参数并返回React元素的函数或类</li><li>Instance：当使用ReactDOM.render()将一个组件渲染到一个具体的DOM元素中，返回的值就为一个实例</li></ul><h3 id="调用setState时，发生了什么事"><a href="#调用setState时，发生了什么事" class="headerlink" title="调用setState时，发生了什么事"></a>调用setState时，发生了什么事</h3><p>调用setState时，react会做的第一件事就是将传递给setState的对象合并到组件的当前状态，然后会触发调和过程。经过调和过程，React会以相对高效的方式根据新的状态构建React元素树，并准备重新渲染整个UI界面。在React得到元素树后，React会通过diff算法算出新的树与老树之间的节点差异，然后根据差异对界面进行最小化重渲染。在diff算法中，React能够相对精确地算出哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p><h3 id="什么时候使用类组件（Class-Component）而非功能组件（Functional-Component）"><a href="#什么时候使用类组件（Class-Component）而非功能组件（Functional-Component）" class="headerlink" title="什么时候使用类组件（Class Component）而非功能组件（Functional Component）"></a>什么时候使用类组件（Class Component）而非功能组件（Functional Component）</h3><p>若组件需要有state或需要使用生命周期，就用类组件，否则就用功能组件</p><h3 id="什么是React的refs，为什么它们很重要"><a href="#什么是React的refs，为什么它们很重要" class="headerlink" title="什么是React的refs，为什么它们很重要"></a>什么是React的refs，为什么它们很重要</h3><p>我们用render方法得到了组价的实例，然后就可以对它进行相关操作，但是在组件内，JSX是不会返回一个组件的实例，它只是一个ReactElement，只是告诉React被挂载的组件应该是长什么样。</p><p>refs是组件的一个很特殊的prop，可以附加到任何一个组件上，refs就是reference，组件被调用时会新建一个该组件的实例，refs就会指向这个实例</p><p>我们把refs放到原生的DOM组件input中，就可以通过refs得到DOM结点；如果把refs放到React组件中，就可以获得组件的实例，可以调用该组件的实例方法</p><h3 id="受控组件（controlled-component）和不受控组件（uncontrolled-component）有什么区别"><a href="#受控组件（controlled-component）和不受控组件（uncontrolled-component）有什么区别" class="headerlink" title="受控组件（controlled component）和不受控组件（uncontrolled component）有什么区别"></a>受控组件（controlled component）和不受控组件（uncontrolled component）有什么区别</h3><p>受控组件：在HTML中，标签\<input>、\<select>等值的改变通常是根据用户输入进行更新，在React中，可变状态通常保存在组件的状态属性中，并且只能用setState()更新，而呈现表单的React组件也控制着在后续用户输入时该表单发生的情况，以这种由React控制输入表单元素而改变其值的方式，就称为“受控组件”</select></p><p>不受控组件：表单数据不受setState控制，而是由DOM本身处理，与传统HTML表单输入相似，input输入值即显示最新值（使用ref从DOM获取表单值）</p><h3 id="描述事件在React中的处理方式"><a href="#描述事件在React中的处理方式" class="headerlink" title="描述事件在React中的处理方式"></a>描述事件在React中的处理方式</h3><p>React在virtual DOM的基础上实现了一个SyntheticEvent（合成事件）层，所有事件都绑定到最外层上。</p><p>在React底层，主要对合成事件做了两件事：事件委托和自动绑定。</p><p>事件委托：React的事件代理机制不会把事件处理函数直接绑定到真实的结点上，而是把所有事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。</p><p>自动绑定：在React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。在使用ES6 classes和纯函数时，这种自动绑定就不存在了，需要我们手动绑定this：bind方法、双冒号语法、构造器内声明、箭头函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;React解决了什么问题&lt;/li&gt;
&lt;li&gt;如何设计一个好的组件&lt;/li&gt;
&lt;li&gt;组件的render函数在何时被调用&lt;/li&gt;
&lt;li&gt;调用render时DOM就一定会被更新吗&lt;/li&gt;
&lt;li&gt;组件的生命周期&lt;/li&gt;
&lt;li&gt;进行远程数据加载时，应该在哪个周期中完成&lt;/li&gt;
&lt;li&gt;在哪些生命周期中可以修改组件的state&lt;/li&gt;
&lt;li&gt;不同父节点的组件需要对彼此的状态进行改变时应该怎么实现&lt;/li&gt;
&lt;li&gt;state里应该有什么&lt;/li&gt;
&lt;li&gt;如何对组件进行优化&lt;/li&gt;
&lt;li&gt;组件中的key属性有什么用&lt;/li&gt;
&lt;li&gt;Component与Element和Instance的区别&lt;/li&gt;
&lt;li&gt;调用setState时，发生了什么事&lt;/li&gt;
&lt;li&gt;什么时候使用类组件（Class Component）而非功能组件（Functional Component）&lt;/li&gt;
&lt;li&gt;什么是React的refs，为什么它们很重要&lt;/li&gt;
&lt;li&gt;受控组件（controlled component）和不受控组件（uncontrolled component）有什么区别&lt;/li&gt;
&lt;li&gt;描述事件在React中的处理方式&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="笔记" scheme="http://hu33.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://hu33.tech/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>美团实习生面试(一面)</title>
    <link href="http://hu33.tech/2017/07/29/%E7%BE%8E%E5%9B%A2%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95/"/>
    <id>http://hu33.tech/2017/07/29/美团实习生面试/</id>
    <published>2017-07-29T00:39:14.516Z</published>
    <updated>2019-01-10T14:13:02.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ol><li><p>平常用JS做什么</p></li><li><p>平常写项目用ES6吗，用什么比较多</p></li><li><p>箭头函数和普通函数有什么区别</p><a id="more"></a></li><li><p>用原生JS写一个删除元素的函数</p></li><li><p>浅克隆和深克隆，用原生JS写一个clone函数</p></li><li><p>动态添加和删除一条消息要怎么用JS实现</p></li><li><p>cookie是什么，怎么设cookie，前端可以修改cookie吗，cookie的安全性</p></li><li><p>localStorage和sessionStorage</p></li></ol><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ol><li>你用过的display属性值，讲讲block，inline，inline-block的差别</li><li>讲讲几种position属性值</li><li>什么选择器用得比较多</li><li>用CSS写过什么有趣或炫酷的东西</li></ol><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ol><li>网络7层协议，数据是怎么传输的</li><li>http协议是哪一层的</li><li>http协议有哪些header</li><li>http请求方法，get和post的使用场景，post和put的本质区别</li><li>http返回码，什么时候返回200，什么时候返回500，201表示什么</li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ol><li>React生命周期</li><li>在哪几个生命周期里可以使用setState</li><li>有没有function的方式写过组件</li><li>异步请求一般在哪个生命周期</li><li>谈一下你怎么理解render的触发</li><li>refs用来干什么</li><li>react如何实现事件委托</li><li>redux的流程</li><li>用过哪些redux中间件，中间件实现原理，有没有自己写过中间件</li><li>用redux时遇到过什么坑</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>为什么要用mongodb</li><li>MySQL有办法存json数据吗</li></ol><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 有一个数组arr代表外卖的价格，比如[1, 2, 2.5, 30, 25]，用户现在有购物车已经买了N元了，需要凑到&gt;=M元，求给出一个最佳凑单组合</span></div><div class="line"></div><div class="line"><span class="comment">// [1,2,3] 20 25 [2,3] [1, 1, 1, 1, 1] [1,1,3]</span></div><div class="line"><span class="comment">// [1,2,3]  19.5 20 [1]</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">itemPrice, N, M</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> items = [];</div><div class="line">  ...</div><div class="line">  return items;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JS&quot;&gt;&lt;a href=&quot;#JS&quot; class=&quot;headerlink&quot; title=&quot;JS&quot;&gt;&lt;/a&gt;JS&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;平常用JS做什么&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;平常写项目用ES6吗，用什么比较多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;箭头函数和普通函数有什么区别&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面经" scheme="http://hu33.tech/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Express+MongoDB搭建多人博客系统</title>
    <link href="http://hu33.tech/2017/07/25/Express+MongoDB%E6%90%AD%E5%BB%BA%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
    <id>http://hu33.tech/2017/07/25/Express+MongoDB搭建多人博客系统/</id>
    <published>2017-07-25T14:04:11.377Z</published>
    <updated>2019-01-13T08:25:45.797Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/hu33/myblog" target="_blank" rel="external">项目地址</a>  目前还是bug多多~</p><p>本项目完全<a href="https://github.com/nswbmw/N-blog" target="_blank" rel="external">该教程</a>，教程很详细很入门很通俗，本文是纯为面试准备的啦。</p><a id="more"></a><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>Node.js: 6.11.0</li><li>Express: 4.15.3</li><li>MongoDB: 3.4</li></ul><h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>Express的基本使用方法可以查看其<a href="http://www.expressjs.com.cn/guide/routing.html" target="_blank" rel="external">使用指南</a>。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>本项目使用的是<code>express.Router</code>。</p><p>创建一个<code>routes</code>的文件夹，将路由控制都写在该文件夹内，每个路由文件通过生成一个<code>express.Router</code>实例<code>router</code>并导出，通过<code>app.use</code>挂载到不同的路径。</p><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>本项目模板引擎使用的是ejs。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置模板目录</span></div><div class="line">app.set(<span class="string">'views'</span>, path.join(__dirname, <span class="string">'views'</span>));</div><div class="line"><span class="comment">//设置模板引擎为ejs</span></div><div class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>);</div></pre></td></tr></table></figure><p>通过调用<code>res.render()</code>渲染<code>ejs</code>模板，第一个参数是模板的名字，第二个参数传给模板的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">res.render(<span class="string">'error'</span>,&#123;</div><div class="line">   <span class="attr">error</span>: err</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><code>res.render()</code>的作用就是将模板和数据结合成HTML，同时响应头中的<code>Content-Type：text/html</code>，告诉浏览器返回的是HTML，不是文本，要按HTML展示。</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul><li><p><strong>express-session：实现对会话的支持</strong></p><p>由于HTTP协议是无状态协议，所以服务器需要记录用户的状态时，需要用某种机制来识别具体的用户，这个机制就是会话（<code>session</code>）。</p><p>本项目中<code>session</code>配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">app.use(session(&#123;</div><div class="line">    <span class="attr">name</span>: config.session.key, <span class="comment">//设置cookie中保存session id的字段名称</span></div><div class="line">    secret: config.session.secret,</div><div class="line">    <span class="attr">resave</span>: <span class="literal">true</span>, <span class="comment">//强制更新session</span></div><div class="line">    saveUninitialized: <span class="literal">false</span>, <span class="comment">//设置为false，强制创建一个session，即使用户未登录</span></div><div class="line">    cookie: &#123;</div><div class="line">        <span class="attr">maxAge</span>: config.session.maxAge</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">store</span>: <span class="keyword">new</span> MongoStore(&#123;</div><div class="line">        <span class="attr">url</span>: config.mongodb</div><div class="line">    &#125;)</div><div class="line">&#125;));</div></pre></td></tr></table></figure><p><code>session</code>中间件会在<code>req</code>上设置<code>session</code>对象，及<code>req.session={}</code>，当用户登录后设置<code>req.session.user=用户信息</code>，返回浏览器的头信息中会带上<code>set-cookie</code>，将<code>session id</code>写到浏览器<code>cookie</code>中，所以用户下次请求时，通过带上来的<code>cookie</code>中的<code>session id</code>就能查找到该用户，并将用户信息保存早<code>req.session.user</code>。</p><p>session资料：</p><ol><li><a href="http://justsee.iteye.com/blog/1570652" target="_blank" rel="external">http://justsee.iteye.com/blog/1570652</a></li><li><a href="https://www.zhihu.com/question/19786827" target="_blank" rel="external">https://www.zhihu.com/question/19786827</a></li></ol></li><li><p><strong>connect-mongo：将session存入到mongodb中</strong></p><p>作用就是将<code>connect</code>的<code>session</code>持久化到mongodb中，配置见上面的<code>session</code>配置。</p></li><li><p><strong>connect-flash：通知功能</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.use(flash());</div></pre></td></tr></table></figure><p>原理：设置初始值<code>req.session.flash={}</code>，通过<code>req.flash(name, value)</code>设置<code>flash</code>字段和值，通过<code>req.flash(name)</code>获取该对象下的值，同时删除该字段。</p></li><li><p><strong>express-formidable：处理表单及文件上传</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="built_in">require</span>(<span class="string">'express-formidable'</span>)(&#123;</div><div class="line">    <span class="attr">uploadDir</span>: path.join(__dirname, <span class="string">'public/img'</span>),  <span class="comment">//上传文件目录</span></div><div class="line">    keepExtensions: <span class="literal">true</span> <span class="comment">//保留后缀</span></div><div class="line">&#125;));</div></pre></td></tr></table></figure><p>获取文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> avatar = req.files.avatar.path.split(path.sep).pop();</div></pre></td></tr></table></figure></li><li><p><strong>config-lite：读取配置文件</strong></p><p><code>config-lite</code>会根据环境变量（<code>NODE_ENV</code>）的不同从当前执行进程目录下的config目录加载不同的配置文件。如果不设置<code>NODE_ENV</code>，则读取默认的default配置文件，若指定了<code>NODE_ENV</code>，则会合并指定的配置文件和default配置文件作为配置。<code>config-lite</code>支持<code>.js</code>、<code>.json</code>、<code>.node</code>、<code>.yml</code>、<code>.yaml</code>后缀的文件。</p><p>如果程序以 <code>NODE_ENV=test node app</code> 启动，则 <code>config-lite</code> 会依次降级查找 <code>config/test.js</code>、<code>config/test.json</code>、<code>config/test.node</code>、<code>config/test.yml</code>、<code>config/test.yaml</code> 并合并 default 配置; 如果程序以 <code>NODE_ENV=production node app</code> 启动，则 <code>config-lite</code> 会依次降级查找 <code>config/production.js</code>、<code>config/production.json</code>、<code>config/production.node</code>、<code>config/production.yml</code>、<code>config/production.yaml</code> 并合并 default 配置。</p></li><li><p><strong>winston和express-winston</strong>：记录日志</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//正常请求的日志</span></div><div class="line">app.use(expressWinston.logger(&#123;</div><div class="line">    <span class="attr">transports</span>: [</div><div class="line">        <span class="keyword">new</span> (winston.transports.Console)(&#123;</div><div class="line">            <span class="attr">json</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">colorize</span>: <span class="literal">true</span></div><div class="line">        &#125;),</div><div class="line">        <span class="keyword">new</span> winston.transports.File(&#123;</div><div class="line">            <span class="attr">filename</span>: <span class="string">'logs/success.log'</span></div><div class="line">        &#125;)</div><div class="line">    ]</div><div class="line">&#125;));</div><div class="line"><span class="comment">//路由</span></div><div class="line">routes(app);</div><div class="line"><span class="comment">//错误请求的日志</span></div><div class="line">app.use(expressWinston.errorLogger(&#123;</div><div class="line">    <span class="attr">transports</span>: [</div><div class="line">        <span class="keyword">new</span> winston.transports.Console(&#123;</div><div class="line">            <span class="attr">json</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">colorize</span>: <span class="literal">true</span></div><div class="line">        &#125;),</div><div class="line">        <span class="keyword">new</span> winston.transports.File(&#123;</div><div class="line">            <span class="attr">filename</span>: <span class="string">'logs/error.log'</span></div><div class="line">        &#125;)</div><div class="line">    ]</div><div class="line">&#125;));</div></pre></td></tr></table></figure><p>将正常请求的日志打印到终端并写入<code>logs/success.log</code>，将错误请求的日志打印到终端并写入<code>logs/error.log</code>。</p><p>注：记录正常请求日志的中间件要放到<code>routes(app)</code>之前，记录错误请求日志的中间件要放到<code>routes(app)</code>之后</p></li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>目前只实现了最最基本的功能，即登录注册登出、查看文章发表文章修改文章删除文章、创建留言删除留言。以及会话、消息通知、权限控制。会话及消息通知用的第三方中间件，权限控制为自定义中间件。</p><p>权限控制（主要是验证用户是否登录）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">checkLogin</span>: <span class="function"><span class="keyword">function</span> <span class="title">checkLogin</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!req.session.user)&#123;</div><div class="line">            req.flash(<span class="string">'error'</span>,<span class="string">'未登录'</span>);</div><div class="line">            <span class="keyword">return</span> res.redirect(<span class="string">'/signin'</span>);</div><div class="line">        &#125;</div><div class="line">        next();</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">checkNotLogin</span>: <span class="function"><span class="keyword">function</span> <span class="title">checkNotLogin</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(req.session.user)&#123;</div><div class="line">            req.flash(<span class="string">'error'</span>,<span class="string">'已登录'</span>);</div><div class="line">            <span class="keyword">return</span> res.redirect(<span class="string">'back'</span>);   <span class="comment">//返回之前的页面</span></div><div class="line">        &#125;</div><div class="line">        next();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><p>项目中目前只有三个<code>model</code>，分别为<code>User</code>、<code>Post</code>及<code>Comment</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/hu33/myblog&quot;&gt;项目地址&lt;/a&gt;  目前还是bug多多~&lt;/p&gt;
&lt;p&gt;本项目完全&lt;a href=&quot;https://github.com/nswbmw/N-blog&quot;&gt;该教程&lt;/a&gt;，教程很详细很入门很通俗，本文是纯为面试准备的啦。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="项目" scheme="http://hu33.tech/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Node.js" scheme="http://hu33.tech/tags/Node-js/"/>
    
      <category term="Express" scheme="http://hu33.tech/tags/Express/"/>
    
  </entry>
  
</feed>
