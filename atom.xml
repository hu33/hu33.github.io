<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小胡不说八道</title>
  
  <subtitle>Go easy on the soul.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hu33.tech/"/>
  <updated>2019-01-13T15:46:19.135Z</updated>
  <id>http://hu33.tech/</id>
  
  <author>
    <name>不说八道的小胡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>飞羽作品集（一）</title>
    <link href="http://hu33.tech/2019/01/13/%E9%A3%9E%E7%BE%BD%E4%BD%9C%E5%93%81%E9%9B%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://hu33.tech/2019/01/13/飞羽作品集（一）/</id>
    <published>2019-01-13T13:55:22.206Z</published>
    <updated>2019-01-13T15:46:19.135Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本作品集为飞羽原创，19岁生日时飞羽将其作为礼物赠与本人，现将该作品摘抄并记录在该博客中。</p></blockquote><h2 id="淡淡"><a href="#淡淡" class="headerlink" title="淡淡"></a>淡淡</h2><p>人生是一本最短也最长的书，</p><p>真实中夹杂着虚幻与飘无。</p><p>我们不停地写着，头脑麻木，</p><p>突然发现，</p><p>无数的喜悦与哀愁，都在不停地重复。</p><p>也许我们早该醒悟，</p><p>去寻找人生真正的归宿。</p><p>你的欢笑是我的翅膀，</p><p>带我飞离书中的荒芜。</p><p><code>----------本篇完----------</code></p><h2 id="无题"><a href="#无题" class="headerlink" title="无题"></a>无题</h2><p>两滴雨住在云里，整日悠闲，四处闲逛。</p><p>一天，一滴雨被吹过的风带走了，还没来得及和自己的朋友道别就落到了一片池塘里。原本它以为云中的生活才是最舒适安逸，没想到这池塘是如此迷人–鱼儿们自由嬉戏，一两只蜻蜓在池面飞过，……雨滴喜欢上了这里的生活。</p><p>然而，池塘中的雨滴还想着云中的雨滴，它不能让它的朋友孤单地生活在云里，不过一旦回去，就不知道什么时候才能再落到这片池塘。纠结了一番后，池塘的雨滴还是觉得朋友更重要，便努力地吸收阳光，希望将自己蒸发回云里。</p><p>云中的雨滴同样在想着它的朋友，它在担心朋友落下后生活会不会很困苦，它不能独自在云中过着安逸的生活，让自己的朋友受苦。于是，它努力地挣扎着，一心想落下去寻找自己的朋友，毕竟，两个一起受苦比一个单独受苦要好过些。</p><p>终于有一天，池塘中的雨滴吸收了足够多的阳光，兴奋地飞上天去寻找自己的朋友，也就在那一刻，云中的雨滴挣脱了束缚向下落去。他们相遇在半空，它笑了，它也笑了，因为尽管彼此依旧分离，但心中那一份友谊已在半空相遇的那一瞬定格。</p><p>（这是童话，亦菲童话）</p><p><code>----------本篇完----------</code></p><h2 id="风筝与风"><a href="#风筝与风" class="headerlink" title="风筝与风"></a>风筝与风</h2><p>角落里有一只风筝，身上布满了灰尘。</p><p>一天，风筝实在受不了这无聊的生活，偷偷跑出去寻找能带给风筝天堂般快乐的风。</p><p>风筝先飞到大树的枝头，期盼地问大树：“大树爷爷，您知道风在哪儿吗？”大树看了看摇曳着的树叶：“看，这不就是吗？”风筝挠了挠头：“哪有啊？除了树叶什么都没有嘛，大树爷爷肯定是看我太小，在逗我玩呢，我还是去别处寻找吧！”</p><p>风筝飞啊，飞啊，飞到了云朵旁边，风筝急切地问云朵：“云朵姐姐，你知道风在哪儿吗？”云朵惊讶地看着风筝：“哈哈，你傻呀，风不就在这儿吗？”风筝又纳闷了：“明明就没有嘛，你们怎么都逗我玩呢！”风筝想找云朵问清楚，可云朵已经捂着嘴偷笑着飘走了。</p><p>不知不觉，风筝已经飘到了天堂，这儿一片欢声笑语，只有风筝闷闷不乐，因为它还是没有看到风，它在想风不是能带给他天堂般的快乐吗？可是自己已经到天堂了，怎么还是一点都不快乐啊！风筝受不了了，大喊了一声：“风啊，你到底在哪啊！”只听四周传来声音：“呵呵，傻孩子，你以为是谁带你到这天堂上来的啊？”</p><p>风筝突然明白了，原来风一直就在它身边，只是自己看不到罢了。</p><p>我们每个人都是风筝，总有那么一些人是我们的风，我们只顾着寻找他们，却不知道其实他们一直在我们身边，默默地帮助着我们，不离，不弃……</p><p><code>----------本篇完----------</code></p><h2 id="逆流的溪水"><a href="#逆流的溪水" class="headerlink" title="逆流的溪水"></a>逆流的溪水</h2><p>一条小溪哗啦啦地流着，带着欢声与笑语。</p><p>突然有一天，溪水在想自己会去哪，便问周围的大树自己会去哪儿。</p><p>大树说：“流到河里啊！”</p><p>溪水又问：“然后呢？”</p><p>“流去江里。”</p><p>“再然后呢？”</p><p>“流到大海里。”</p><p>“再然后呢？”</p><p>“到大海里就是你们最终的归宿，你们可以尽情地咆哮，也可以平静地生活。总之，你们是最伟大的。”</p><p>溪水有些兴奋：“最伟大的？那我们该做些什么事呢？”</p><p>大树笑呵呵的，“你们流入大海后就什么都不用做了，没有什么能再阻拦你们，连太阳也蒸发不了你们。”</p><p>溪水倒是有点失落了，它就是想着能多做些什么才不断前行，如果前方是没有意义的伟大，它又何苦盲目前行呢？于是，溪水毅然决然往回流，不顾一切阻挠。</p><p>溪水艰苦地逆流着，前方的路越来越窄了，溪水看到前方的路快到尽头了，源头的后方是一片荒凉。溪水勇敢地冲了过去，冲破了源头，冲向它不曾见过的一片荒凉–它以前只看到溪水流过的地方有花有草，从未知道源头后面是日此干涸。</p><p>终于，溪水放弃了大海的伟大，成就了源头背后的绿意盎然。</p><p><code>----------本篇完----------</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本作品集为飞羽原创，19岁生日时飞羽将其作为礼物赠与本人，现将该作品摘抄并记录在该博客中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;淡淡&quot;&gt;&lt;a href=&quot;#淡淡&quot; class=&quot;headerlink&quot; title=&quot;淡淡&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="随笔" scheme="http://hu33.tech/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="作品集" scheme="http://hu33.tech/tags/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
      <category term="礼物" scheme="http://hu33.tech/tags/%E7%A4%BC%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>《你的名字》影评</title>
    <link href="http://hu33.tech/2019/01/11/%E3%80%8A%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E3%80%8B%E5%BD%B1%E8%AF%84/"/>
    <id>http://hu33.tech/2019/01/11/《你的名字》影评/</id>
    <published>2019-01-11T10:45:11.082Z</published>
    <updated>2019-01-12T11:15:15.728Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://hu33.github.io/images/影评/你的名字.jpeg" alt="《你的名字》剧照"></p><a id="more"></a><blockquote><p>导演：<a href="https://movie.douban.com/celebrity/1005177/" target="_blank" rel="external">新海诚</a></p><p>编剧：<a href="https://movie.douban.com/celebrity/1005177/" target="_blank" rel="external">新海诚</a>、<a href="https://movie.douban.com/celebrity/1330986/" target="_blank" rel="external">Waris Dirie</a>、<a href="https://movie.douban.com/celebrity/1286916/" target="_blank" rel="external">Sherry Hormann</a></p><p>演员：<a href="https://movie.douban.com/celebrity/1185637/" target="_blank" rel="external">神木隆之介</a>、<a href="https://movie.douban.com/celebrity/1316660/" target="_blank" rel="external">上白石萌音</a></p></blockquote><p>一句话评价：超好看超好看超好看！</p><p>这是唯一一部电脑上看过后还想去电影院看的电影，没有失望，满满的满足感，从整体的剧情到唯美的画面再到人物塑造我都特别喜欢。</p><p>其实看电影这种事，除了电影本身的质量外，自己的状态也特别能影响整个观影心情。最近因为一些事情导致心里老是空落落又七上八下的，就是那种惦记着某个东西却得不到的感觉。这不正与电影中他俩一直在寻找着神秘却找不到（准确说是并不知道在找什么）一样嘛。</p><p>还好，还好最后他俩相遇了，还好泷鼓足了勇气叫住了三叶，还好在那之前他俩都还单着，还好还好。</p><p>如果一辈子都想不起来心里那个东西是什么该如何生活？因为想不起，所以何来忘记。</p><p>回到电影中来，其实整个电影中伏笔都设置非常好，包括后面勅使炸发电站，泷喝口嚼酒来产生联系。电影中每一幕都是有意图的，都是能在后面找到对应的情节的，每一个画面，每一句台词都是有意义的。这就是我特别喜欢这部电影的原因，饱满而不做作，多看几遍也还是能看出新东西来。</p><p>关键是！！每一帧都可以当做壁纸，真的是美翻天！！！</p><p><code>本影评写于16年12月</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://hu33.github.io/images/影评/你的名字.jpeg&quot; alt=&quot;《你的名字》剧照&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://hu33.tech/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="影评" scheme="http://hu33.tech/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>《沙漠之花》影评</title>
    <link href="http://hu33.tech/2019/01/11/%E3%80%8A%E6%B2%99%E6%BC%A0%E4%B9%8B%E8%8A%B1%E3%80%8B%E5%BD%B1%E8%AF%84/"/>
    <id>http://hu33.tech/2019/01/11/《沙漠之花》影评/</id>
    <published>2019-01-11T10:00:35.514Z</published>
    <updated>2019-01-11T10:44:14.605Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://hu33.github.io/images/影评/沙漠之花.jpg" alt="《沙漠之花》剧照"></p><a id="more"></a><blockquote><p>导演：<a href="https://movie.douban.com/celebrity/1286916/" target="_blank" rel="external">Sherry Hormann</a></p><p>编剧：<a href="https://movie.douban.com/celebrity/1305350/" target="_blank" rel="external">Smita Bhide</a>、<a href="https://movie.douban.com/celebrity/1330986/" target="_blank" rel="external">Waris Dirie</a>、<a href="https://movie.douban.com/celebrity/1286916/" target="_blank" rel="external">Sherry Hormann</a></p><p>演员：<a href="https://movie.douban.com/celebrity/1014172/" target="_blank" rel="external">Liya Kebede</a>、<a href="https://movie.douban.com/celebrity/1044915/" target="_blank" rel="external">Sally Hawkins</a>、</p></blockquote><p>这部电影讲的是一个受割礼的索马里女孩从非洲逃到英国，被唐纳森发掘而成为一代超模，而后勇敢站出来向全世界反映割礼的残忍与对女性的不尊重。</p><p>整部电影的基调比较平淡，却不时地透露出让人心塞的情景，尤其当女主角会议割礼的过程，让人无比揪心，悲恸却有种哭不出来的压抑。</p><p>看完电影后便查了很多关于割礼的资料，这种残害人身心的习俗真是太可怕了，千千万万的妇女死于这种惨无人道的习俗，千千万万的妇女因这种毫无因全弊无利的事情而无法享受很多美好的体验。好在总有人站出来，顶着巨大压力和危险与信仰做斗争，为女权奋斗，为更多人的幸福与正常生活而奋斗。</p><p>很庆幸自己一直活得没什么障碍，那些自以为很大的事很大的问题在这面前根本不值一提。任何困难都可以被解决，可能不一定恢复，但是能愈合。</p><p><code>本影评写自16年8月</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://hu33.github.io/images/影评/沙漠之花.jpg&quot; alt=&quot;《沙漠之花》剧照&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://hu33.tech/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="影评" scheme="http://hu33.tech/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>《爆裂鼓手》影评</title>
    <link href="http://hu33.tech/2019/01/11/%E3%80%8A%E7%88%86%E8%A3%82%E9%BC%93%E6%89%8B%E3%80%8B%E5%BD%B1%E8%AF%84/"/>
    <id>http://hu33.tech/2019/01/11/《爆裂鼓手》影评/</id>
    <published>2019-01-11T05:38:00.229Z</published>
    <updated>2019-01-11T10:36:36.564Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://hu33.github.io/images/影评/爆裂鼓手.jpg" alt="《爆裂鼓手》剧照"></p><a id="more"></a><blockquote><p>导演：<a href="https://movie.douban.com/celebrity/1014996/" target="_blank" rel="external">Damien Chazelle</a></p><p>编剧：<a href="https://movie.douban.com/celebrity/1014996/" target="_blank" rel="external">Damien Chazelle</a></p><p>主演：<a href="https://movie.douban.com/celebrity/1313408/" target="_blank" rel="external">Miles Teller</a>、<a href="https://movie.douban.com/celebrity/1147911/" target="_blank" rel="external">J.K. Simmons</a></p></blockquote><p>与其说Andrew是在追求自己的梦想，还不如说他是对击鼓有着强烈的偏激的疯狂的热爱。当然这种热爱与Fletcher的魔鬼式训练与咄咄逼人是分不开的。有人把《爆裂鼓手》当做励志来看，寓意一切伟大背后必历经辛酸磨难，但我在观看的过程中却感受到了压迫的气息，不仅仅是Fletcher对学生们的压迫，还有Andrew对自己的逼迫，逼迫自己不断练习不断加速，到最后哪怕是出车祸了都不愿暂时放弃一次机会。</p><p>最终的Andrew应该是成功的，但是成功是需要代价的，也是需要突破的机遇。如此偏执的热爱若未完全突破很容易出问题的，从Andrew跟女朋友说分手及家庭聚餐上说的话就能感觉出来。</p><p>不管怎样，本宝宝还是偏向于快乐学习健康成长，娃哈哈！</p><p><code>本影评写自16年8月</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://hu33.github.io/images/影评/爆裂鼓手.jpg&quot; alt=&quot;《爆裂鼓手》剧照&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://hu33.tech/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="影评" scheme="http://hu33.tech/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>Chrome显示小于12px的字体</title>
    <link href="http://hu33.tech/2019/01/10/Chrome%E6%9C%80%E5%B0%8F%E6%98%BE%E7%A4%BA12px%E5%AD%97%E4%BD%93/"/>
    <id>http://hu33.tech/2019/01/10/Chrome最小显示12px字体/</id>
    <published>2019-01-10T13:52:44.437Z</published>
    <updated>2019-01-10T14:00:51.647Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><code>Chrome</code>上默认最小字体是<code>12px</code>，这就意味着你想设置某个元素(可能是个上标或下标)的<code>font-size</code>为<code>9px</code>，结果显示出来的是<code>12px</code>，有那么一点恼火是吧？</p><a id="more"></a><p>曾经是可以使用<code>-webkit-text-size-adjust: none</code>来禁止网页调整字体大小，但是<code>Chrome27</code>之后就将该属性禁用了（该属性<a href="https://trac.webkit.org/changeset/145168/webkit" target="_blank" rel="external">具体变更集</a>）。这个禁用是有道理的，因为该属性很容易被滥用：很多开发者会直接将该属性设置为全局属性，然后当用户放大或缩小页面时（按住Ctrl滚动鼠标滚轮可缩放网页），文字却维持定义的大小而不放缩，给用户带来的不太友好的体验。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>现在一般是使用<code>transform: scale(0.82)</code>来实现小于<code>12px</code>的字体显示。比如要显示<code>8px</code>的字体，那么可以将该元素加上以下属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">font-size</span>: 12<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.667</span>);</div><div class="line"><span class="selector-tag">-moz-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.667</span>);</div><div class="line"><span class="selector-tag">-ms-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.667</span>);</div><div class="line"><span class="selector-tag">-o-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.667</span>);</div><div class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.667</span>);</div></pre></td></tr></table></figure><p>只要缩小到需要尺寸的比例即好。需要注意的是，这个方案需要该元素表现为<code>inline-block</code>。</p><p>具体效果<a href="http://jsbin.com/wiroweh/1/edit?html,css,output" target="_blank" rel="external">戳这儿</a>~</p><p>上述代码可以使用<code>sass</code>的<code>@mixin</code>抽象一下（<code>@mixin</code>相关内容可以看<a href="https://github.com/hu33/project-problem-notes/blob/master/sass%20-%20%E4%BD%BF%E7%94%A8mixin%E6%88%96%E5%8D%A0%E4%BD%8D%E7%AC%A6%E5%A4%8D%E7%94%A8CSS%E4%BB%A3%E7%A0%81.md" target="_blank" rel="external">这里</a>），通过传参数来得到想要的字体。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@mixin webkit-font-size($size: 10) &#123;</div><div class="line">    font-size: 12px;</div><div class="line">    -webkit-transform: scale($size / 12);</div><div class="line">    -moz-transform: scale($size / 12);</div><div class="line">    -ms-transform: scale($size / 12);</div><div class="line">    -o-transform: scale($size / 12);</div><div class="line">    transform: scale($size / 12);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Chrome&lt;/code&gt;上默认最小字体是&lt;code&gt;12px&lt;/code&gt;，这就意味着你想设置某个元素(可能是个上标或下标)的&lt;code&gt;font-size&lt;/code&gt;为&lt;code&gt;9px&lt;/code&gt;，结果显示出来的是&lt;code&gt;12px&lt;/code&gt;，有那么一点恼火是吧？&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="问题记录" scheme="http://hu33.tech/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>《高性能JavaScript》- DOM编程</title>
    <link href="http://hu33.tech/2017/09/15/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDJavaScript%E3%80%8B-%20DOM%E7%BC%96%E7%A8%8B/"/>
    <id>http://hu33.tech/2017/09/15/《高性能JavaScript》- DOM编程/</id>
    <published>2017-09-15T12:26:58.482Z</published>
    <updated>2019-01-13T08:30:01.737Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，用JS进行<code>DOM</code>操作那是灰常的昂贵，毕竟人家web应用的性能瓶颈之一啊，但也是有不少优化的法子的~~本章大致从三个方向阐述了<code>DOM</code>编程的优化方法。</p><h3 id="尽量减少访问和修改DOM次数"><a href="#尽量减少访问和修改DOM次数" class="headerlink" title="尽量减少访问和修改DOM次数"></a>尽量减少访问和修改DOM次数</h3><p>浏览器中通常是独立实现<code>DOM</code>和<code>JavaScript</code>的，这样可以允许其他技术和语言也能共享使用<code>DOM</code>和渲染函数，但这也意味着JS想去访问<code>DOM</code>，是要花费一定代价的，访问和修改的次数越高，代价就越高，代码运行速度就越慢。</p><a id="more"></a><h4 id="优化点1-使用DOM更新页面内容时，克隆已有元素，而不是创建新元素"><a href="#优化点1-使用DOM更新页面内容时，克隆已有元素，而不是创建新元素" class="headerlink" title="优化点1  使用DOM更新页面内容时，克隆已有元素，而不是创建新元素"></a>优化点1  使用DOM更新页面内容时，克隆已有元素，而不是创建新元素</h4><p>在大多数浏览器中，节点克隆都更有效率，虽然效果不是特别明显~~所以对于一些需要多次重复创建的元素，可以先创建第一个，然后重复拷贝操作。也就是用<code>element.cloneNode()</code>代替<code>document.createElement()</code>。</p><h4 id="优化点2-遍历HTML集合时，把集合存在局部变量中，并把length缓存在循环外部，用局部变量代替这些需要多次读取的元素"><a href="#优化点2-遍历HTML集合时，把集合存在局部变量中，并把length缓存在循环外部，用局部变量代替这些需要多次读取的元素" class="headerlink" title="优化点2  遍历HTML集合时，把集合存在局部变量中，并把length缓存在循环外部，用局部变量代替这些需要多次读取的元素"></a>优化点2  遍历HTML集合时，把集合存在局部变量中，并把length缓存在循环外部，用局部变量代替这些需要多次读取的元素</h4><p>看个例子就造了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//最慢</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectionGlobal</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> coll = <span class="built_in">document</span>.getElementByTagName(<span class="string">'div'</span>),</div><div class="line">    len = coll.length,</div><div class="line">    name = <span class="string">''</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; len; count++) &#123;</div><div class="line">        name = <span class="built_in">document</span>.getElementByTagName(<span class="string">'div'</span>)[count].nodeName;</div><div class="line">        name = <span class="built_in">document</span>.getElementByTagName(<span class="string">'div'</span>)[count].nodeType;</div><div class="line">        name = <span class="built_in">document</span>.getElementByTagName(<span class="string">'div'</span>)[count].tagName;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//较快</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectionGlobal</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> coll = <span class="built_in">document</span>.getElementByTagName(<span class="string">'div'</span>),</div><div class="line">    len = coll.length,</div><div class="line">    name = <span class="string">''</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; len; count++) &#123;</div><div class="line">        name = coll[count].nodeName;</div><div class="line">        name = coll(<span class="string">'div'</span>)[count].nodeType;</div><div class="line">        name = coll(<span class="string">'div'</span>)[count].tagName;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最快</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectionGlobal</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> coll = <span class="built_in">document</span>.getElementByTagName(<span class="string">'div'</span>),</div><div class="line">    len = coll.length,</div><div class="line">    name = <span class="string">''</span>,</div><div class="line">    ele = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; len; count++) &#123;</div><div class="line">        ele = coll[count]; </div><div class="line">        name = ele.nodeName;</div><div class="line">        name = ele.nodeType;</div><div class="line">        name = ele.tagName;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="优化点3-访问元素节点时，推荐使用只返回元素节点的API，因为它们的执行效率比自己在JS代码中实现过滤的效率要高"><a href="#优化点3-访问元素节点时，推荐使用只返回元素节点的API，因为它们的执行效率比自己在JS代码中实现过滤的效率要高" class="headerlink" title="优化点3  访问元素节点时，推荐使用只返回元素节点的API，因为它们的执行效率比自己在JS代码中实现过滤的效率要高"></a>优化点3  访问元素节点时，推荐使用只返回元素节点的API，因为它们的执行效率比自己在JS代码中实现过滤的效率要高</h4><p>这些API如下：</p><ul><li><code>children</code> – <code>childNodes</code></li><li><code>childElementCount</code> – <code>childNodes.length</code></li><li><code>firstElementChild</code> – <code>firstChild</code></li><li><code>lastElementChild</code> – <code>lastChild</code></li><li><code>nextElementSibling</code> – <code>nextSibing</code></li><li><code>previousElementSibling</code> – <code>previousSibing</code></li></ul><h4 id="优化点4-使用querySelectorAll-查询DOM"><a href="#优化点4-使用querySelectorAll-查询DOM" class="headerlink" title="优化点4  使用querySelectorAll()查询DOM"></a>优化点4  使用<code>querySelectorAll()</code>查询DOM</h4><p>当咱需要得到特定的DOM元素列表时，需要使用<code>getElementById()</code>和<code>getElementByTagName()</code>进行组合调用，而且还得手动遍历筛选，好不麻烦且效率低下~~</p><p>后来~~<code>querySelectorAll()</code>就横空出世了，只要传入相应的CSS选择器字符串，就能得到咱需要的元素了，而且还是浏览器原生API，比起用JS和DOM操作来遍历查找元素不要快太多啊~~</p><p>而且，<code>querySelectorAll()</code>返回的是一个<code>NodeList</code>，是一个快照而不是动态集合，所以还避免了HTML集合会导致的性能问题。</p><h3 id="尽量避免重绘和重排"><a href="#尽量避免重绘和重排" class="headerlink" title="尽量避免重绘和重排"></a>尽量避免重绘和重排</h3><p>浏览器下载完页面中所有的组件后会解析并生成两个内部数据结构–<code>DOM</code>树和<code>Render</code>树，<code>DOM</code>树都知道是表示页面结果，<code>Render</code>树则是表示<code>DOM</code>节点如何显示。<code>Render</code>树中的节点就是一个“盒”，一旦<code>DOM</code>树和<code>Render</code>树构建完成，浏览器就开始绘制元素了。</p><p>当<code>DOM</code>的变化影响了元素的几何属性（宽和高），浏览器就需要重新计算元素的几何属性，其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的元素的部分失效，并重新构建<code>Render</code>树，这就是传说中的重排。重排之后，浏览器会重新绘制受影响的部分，这就是重绘。</p><p>易得：重绘和重排都是代价很昂贵的操作，所以要尽量避免避免啊~</p><h4 id="优化点5-合并多次对DOM和样式的修改，然后一次处理"><a href="#优化点5-合并多次对DOM和样式的修改，然后一次处理" class="headerlink" title="优化点5  合并多次对DOM和样式的修改，然后一次处理"></a>优化点5  合并多次对DOM和样式的修改，然后一次处理</h4><ul><li>改变样式：可以用<code>CSSText</code>属性做批量修改</li><li>批量修改<code>DOM</code>：可以让<code>DOM</code>脱离文档流，修改完再带回文档中，具体有三种方式：<ol><li>隐藏元素（<code>display：none</code>），修改后再重新显示</li><li>使用文档片段在当前<code>DOM</code>之外构建一个子树，再把它拷贝回文档</li><li>将原始元素拷贝到一个脱离文档流的节点中，修改该副本节点，完成后再替换原始元素</li></ol></li></ul><h4 id="优化点6-缓存布局信息"><a href="#优化点6-缓存布局信息" class="headerlink" title="优化点6  缓存布局信息"></a>优化点6  缓存布局信息</h4><p>现在大多数浏览器对重排进行了优化，通过队列化修改并批量修改执行来实现，但是有种操作会强制刷新队列并要求计划任务立即执行！它！就！是！获取元素的布局信息！因为查询布局信息时，浏览器会为了返回最新值而会刷新队列并应用所有变更。</p><p>这个时候，局部变量又派上用场了，我们可以通过获取布局信息，把它赋值给局部变量，然后操作局部变量，尽可能地减少布局信息的获取次数。</p><h4 id="优化点7-让元素脱离动画流"><a href="#优化点7-让元素脱离动画流" class="headerlink" title="优化点7  让元素脱离动画流"></a>优化点7  让元素脱离动画流</h4><p>假设有个元素处在页面顶部，然后它可以展开/折叠，那岂不是对它之后所有的元素位置都会产生影响？那岂不是要进行大规模重排？？那岂不是很消耗性能？？？</p><p>咱可以让它脱离文档流啊~先给它设置绝对定位，然后它想咋动就咋动吧，反正就导致一小区域的重绘，等动画结束再恢复它本来的定位。</p><h3 id="优化点8-使用事件委托"><a href="#优化点8-使用事件委托" class="headerlink" title="优化点8  使用事件委托"></a>优化点8  使用事件委托</h3><p>元素绑定事件处理器是有代价的，会占用处理时间，而且浏览器还要跟踪这些处理器，又会占更多的内存。要是页面上一大堆元素都需要绑定一个或多个事件处理器，那还不堵死啊。。。</p><p>不过呢，大部分事件是能够冒泡的，咱就可以给外层元素绑定一个处理器，用来处理在其子元素上触发的事件。除了性能上有很大的优化，事件委托其实还有个好处，就是如果一个元素的子元素是动态的，它也可以进行处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，用JS进行&lt;code&gt;DOM&lt;/code&gt;操作那是灰常的昂贵，毕竟人家web应用的性能瓶颈之一啊，但也是有不少优化的法子的~~本章大致从三个方向阐述了&lt;code&gt;DOM&lt;/code&gt;编程的优化方法。&lt;/p&gt;
&lt;h3 id=&quot;尽量减少访问和修改DOM次数&quot;&gt;&lt;a href=&quot;#尽量减少访问和修改DOM次数&quot; class=&quot;headerlink&quot; title=&quot;尽量减少访问和修改DOM次数&quot;&gt;&lt;/a&gt;尽量减少访问和修改DOM次数&lt;/h3&gt;&lt;p&gt;浏览器中通常是独立实现&lt;code&gt;DOM&lt;/code&gt;和&lt;code&gt;JavaScript&lt;/code&gt;的，这样可以允许其他技术和语言也能共享使用&lt;code&gt;DOM&lt;/code&gt;和渲染函数，但这也意味着JS想去访问&lt;code&gt;DOM&lt;/code&gt;，是要花费一定代价的，访问和修改的次数越高，代价就越高，代码运行速度就越慢。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://hu33.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
      <category term="性能" scheme="http://hu33.tech/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>《高性能JavaScript》- 数据存取</title>
    <link href="http://hu33.tech/2017/09/14/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDJavaScript%E3%80%8B-%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96/"/>
    <id>http://hu33.tech/2017/09/14/《高性能JavaScript》- 数据存取/</id>
    <published>2017-09-14T11:06:39.958Z</published>
    <updated>2019-01-10T14:34:51.662Z</updated>
    
    <content type="html"><![CDATA[<p>数据的存储位置会很大程度影响其读取速度，so本章就是从这个方向来讨论的优化点~</p><h3 id="优化点1-将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量"><a href="#优化点1-将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量" class="headerlink" title="优化点1  将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量"></a>优化点1  将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量</h3><p>函数在执行过程中，每遇到一个变量，都会经历一次标识符解析的过程，来决定从哪里获取或存储数据。这个过程就是在搜索执行环境的作用域链，从作用域头部（当前函数运行的活动对象）开始搜索，直到找到标识符。</p><a id="more"></a><p>然鹅，标识符的解析也是要产生性能开销的好不啦，<strong>标识符的位置越深，它的读写速度肯定会越慢啊~</strong>也就是说，函数中读写局部变量是最快的，因为它们是在作用域链最前线嘛，读取全局变量是最慢的，毕竟是在作用域链最末端位置嘛（emmm…优化了<code>JavaScript</code>引擎的先不管哈）。</p><p>所以啊，如果我们在一个函数中要多次引用全局变量或者是跨作用域的变量，最好是先用一个局部变量存起来，通过这个局部变量去访问就好啦。</p><h3 id="优化点2-避免使用with语句，谨慎使用try-catch语句"><a href="#优化点2-避免使用with语句，谨慎使用try-catch语句" class="headerlink" title="优化点2  避免使用with语句，谨慎使用try-catch语句"></a>优化点2  避免使用<code>with</code>语句，谨慎使用<code>try-catch</code>语句</h3><p><code>with</code>语句和<code>try-catch</code>中的<code>catch</code>语句在执行时是有临时改变作用域链的能力的！这么强大的技能怎么能随便用呢？</p><ul><li><p><code>with</code>语句用来给对象的所有属性都创建一个变量，它会将指定的对象添加到作用域链中，看下这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> qs = <span class="string">"?debug=true"</span>;</div><div class="line">  <span class="keyword">with</span>(location) &#123;</div><div class="line">      <span class="keyword">var</span> url = href + qs;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> url;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当代码执行到<code>with</code>语句时，一个新的变量对象被创建，它包含了参数指定的对象的所有属性，这个对象会被推入到作用域链首位，也就是说，函数的所有局部变量就被挤到第二个作用域对象中了，访问的代价也就高了啊~~</p></li><li><p><code>try-catch</code>语句中的<code>catch</code>子句也有同样的效果。当<code>try</code>代码块中发生错误时，执行过程会自动跳到<code>catch</code>子句，然后把异常对象推入一个变量对象并置于作用域链首位。</p><p>咱可以尽量简化代码来是的<code>catch</code>子句对性能的影响最小化，推荐将错误委托给一个函数来处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapArr</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        result = arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> item*<span class="number">2</span>;</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span>(ex) &#123;</div><div class="line">        handleError(ex);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleError</span>(<span class="params">ex</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ex: '</span>, ex);</div><div class="line">&#125;</div><div class="line"></div><div class="line">mapArr(&#123;&#125;);</div></pre></td></tr></table></figure><p>其中<code>catch</code>子句的作用域链如下：</p><p><img src="http://ow7p6xhhi.bkt.clouddn.com/2-1.png" alt=""></p><p>书中给出这种推荐的理由是：只执行一条语句，且没有局部变量的访问，作用域链的临时改变不会影响代码性能。<strong>但是！有点想不通的是，如果要访问局部变量，<code>handleError()</code>怎么访问得到嘛，难道是通过传参？那在<code>catch</code>子句中调用<code>handleError()</code>并传参的话也就意味着还是要在<code>catch</code>里访问局部变量嘛。。。如果<code>handleError()</code>不用访问局部变量，表示<code>catch</code>子句里也不用访问局部变量呀，那用不用这个委托函数岂不是没差？？？</strong></p></li></ul><h3 id="优化点3-确实必要时才使用动态作用域"><a href="#优化点3-确实必要时才使用动态作用域" class="headerlink" title="优化点3  确实必要时才使用动态作用域"></a>优化点3  确实必要时才使用动态作用域</h3><p>像<code>with</code>语句、<code>try-catch</code>语句中的<code>catch</code>子句、或者包含<code>eval()</code>的函数，都算是动态作用域。动态作用域只存在于代码运行时，也就是说不能通过静态分析（查看代码结构）检测出来。</p><p>有些经过优化的<code>JavaScript</code>引擎，会尝试通过分析代码来确定哪些变量可以在特定时候被访问，它们会试图避开传统作用域链的查找，当涉及动态作用域时，这种优化方式就失效了。</p><h3 id="优化点4-只在必要时使用对象成员"><a href="#优化点4-只在必要时使用对象成员" class="headerlink" title="优化点4  只在必要时使用对象成员"></a>优化点4  只在必要时使用对象成员</h3><p>理由如下：</p><ul><li>属性或方法在原型链中的位置越深，访问它的速度就越慢</li><li>嵌套的对象成员越深，其读取速度就越慢</li></ul><p>比如说，在同一个函数中没有必要多次读取同一个对象成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasEitherClass</span>(<span class="params">element, className1, className2</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> element.className == className1 || element.className == className2;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个代码中读取了两次<code>element.className</code>，也就是说执行了两次对象查找，咱可以将值保存在局部变量中减少一次查找。改成下面这样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasEitherClass</span>(<span class="params">element, className1, className2</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> currentClassName = element.className;</div><div class="line">  <span class="keyword">return</span> currentClassName == className1 || currentClassName == className2;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>反正这一章最重要的优化点就在于<strong>善用局部变量做缓存</strong>~把那些需多次使用的对象成员、数组元素、跨域变量都保存在局部变量就对了，谁叫它访问速度快呢~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据的存储位置会很大程度影响其读取速度，so本章就是从这个方向来讨论的优化点~&lt;/p&gt;
&lt;h3 id=&quot;优化点1-将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量&quot;&gt;&lt;a href=&quot;#优化点1-将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量&quot; class=&quot;headerlink&quot; title=&quot;优化点1  将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量&quot;&gt;&lt;/a&gt;优化点1  将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量&lt;/h3&gt;&lt;p&gt;函数在执行过程中，每遇到一个变量，都会经历一次标识符解析的过程，来决定从哪里获取或存储数据。这个过程就是在搜索执行环境的作用域链，从作用域头部（当前函数运行的活动对象）开始搜索，直到找到标识符。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://hu33.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
      <category term="性能" scheme="http://hu33.tech/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>《高性能JavaScript》- 加载并执行</title>
    <link href="http://hu33.tech/2017/09/13/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDJavaScript%E3%80%8B-%20%E5%8A%A0%E8%BD%BD%E5%B9%B6%E6%89%A7%E8%A1%8C/"/>
    <id>http://hu33.tech/2017/09/13/《高性能JavaScript》- 加载并执行/</id>
    <published>2017-09-13T11:22:56.869Z</published>
    <updated>2019-01-13T08:22:34.996Z</updated>
    
    <content type="html"><![CDATA[<p>这一章主要从管理浏览器中的js代码来进行阐述优化点。</p><h3 id="优化点1：将脚本放在底部"><a href="#优化点1：将脚本放在底部" class="headerlink" title="优化点1：将脚本放在底部"></a>优化点1：将脚本放在底部</h3><p>讲道理，按我们的理解，将js文件和css文件一起放在head中好像没什么毛病，先加载它们，有助于页面渲染和正确交互呀。</p><p>可是！可是坑爹的是，脚本是会阻塞页面渲染的啊，浏览器需要等到它们全部下载并执行完成后，才继续页面渲染。所以把脚本放页面头部会导致明显的延迟，表现为显示空白页面，用户无法浏览页面，也无法与页面进行交互。</p><a id="more"></a><p>更坑爹的是，有些浏览器下载js文件是串行的，也就是说每个文件必须等到前一个文件下载并执行完成后才会开始下载，在这些个文件逐个下载过程中，浏览器上的页面就是一片白茫茫啊~~现在很多浏览器都允许并行下载js文件了，但是仍然会阻塞其他资源的下载，比如图片。尽管脚本的下载过程不会相互影响了，但是页面还是得等所有的js代码下载并执行完才能继续。所以呀，新的浏览器只是治标不治本啊。</p><p>恩，综上所述，咱要把所有的<code>&lt;script&gt;</code>标签放到<code>&lt;body&gt;</code>标签的底部，来尽量减少对整个页面下载的影响。</p><h3 id="优化点2：合并脚本"><a href="#优化点2：合并脚本" class="headerlink" title="优化点2：合并脚本"></a>优化点2：合并脚本</h3><p>这个当然是为了减少http请求带来的性能开销咯。下载1个100k的文件会比下载4个25k的文件要快的呀。</p><p>可以使用离线的打包工具或者类似Yahoo! combo handler的实时在线服务实现。</p><h3 id="优化点3：无阻塞脚本"><a href="#优化点3：无阻塞脚本" class="headerlink" title="优化点3：无阻塞脚本"></a>优化点3：无阻塞脚本</h3><p>上回讲到，合并脚本可以减少http请求数，提高性能。可是问题来了，合并完的脚本可能很大啊，那我浏览器得等这么大一个脚本下载并执行完再进行后面的操作嘛？</p><p>当然，我们也是有办法解决的。咱实现无阻塞脚本不就好了？咱可以等页面加载完再加载js代码呀，专业点讲，就是在<code>window</code>对象的<code>load</code>事件触发后再下载脚本。实现方法有如下几种：</p><h4 id="延迟的脚本"><a href="#延迟的脚本" class="headerlink" title="延迟的脚本"></a>延迟的脚本</h4><p>主角：<code>defer</code></p><p>技能：允许并行下载（包括其他资源哦），但不会执行，直到DOM加载完成（<code>onload</code>事件被触发前）</p><p>可以看个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Script Defer Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    alert(<span class="string">'defer'</span>);</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    alert(<span class="string">'script'</span>);</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     alert(<span class="string">'load'</span>); </div><div class="line">    &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>猜猜弹出顺序是啥？恩，<code>script</code>、<code>defer</code>、<code>load</code>。</p><p><em>注：h5规范里讲了，<code>defer</code>属性仅当<code>src</code>属性声明时才生效~~</em></p><p>BTW，<code>async</code>也是允许并行下载的，但是它跟<code>defer</code>不同的在于它是下载完了就直接执行了，没有<code>defer</code>那么好的耐心，还等<code>dom</code>完成加载后才执行。</p><p><img src="https://hu33.github.io/images/高性能JavaScript/1-1.jpg" alt=""></p><h4 id="动态脚本元素"><a href="#动态脚本元素" class="headerlink" title="动态脚本元素"></a>动态脚本元素</h4><p>原理：使用DOM操作创建一个<code>&lt;script&gt;</code>元素，这个元素中加载某个js文件，然后将该<code>&lt;scirpt&gt;</code>元素添加到页面中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">script.type = <span class="string">"text/javascript"</span>;</div><div class="line">script.src = <span class="string">"file.js"</span>;</div><div class="line"><span class="built_in">document</span>.head.append(script);</div></pre></td></tr></table></figure><p>技能：无论何时启动下载，文件的下载和执行都不回阻塞页面其他进程。</p><p>这种方式还有个特点：返回的代码一般会立即执行（是不是想到了JSONP，哈哈哈）。但是我可能需要它下载完成且准备就绪的时候才执行啊，这个时候，<code>&lt;script&gt;</code>的<code>onload</code>事件就派上用场了~~封装一个<code>loadScript</code>方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url, callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">    script.type = <span class="string">"text/javascript"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (script.readyState) &#123; <span class="comment">//还不是为了兼容IE</span></div><div class="line">        <span class="keyword">if</span> (script.onreadystatechange) &#123;</div><div class="line">            <span class="keyword">if</span> (script.readyState === <span class="string">'loaded'</span> || script.readyState === <span class="string">'completed'</span>) &#123;</div><div class="line">                script.onreadystatechange = <span class="literal">null</span>;</div><div class="line">                callback();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            callback();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    script.src = url;</div><div class="line">    <span class="built_in">document</span>.getElementByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果需要按顺序下载执行代码的话，可以进行嵌套使用<code>loadScript()</code>方法。当然如果多个文件的下载顺序很重要，更好的做法还是把它们按正确的顺序合并成一个文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">loadScript(<span class="string">'file1.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  loadScript(<span class="string">'file2.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    loadScript(<span class="string">'file3.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      alert(<span class="string">'all files are loaded~~'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="XMLHttpRequest脚本注入"><a href="#XMLHttpRequest脚本注入" class="headerlink" title="XMLHttpRequest脚本注入"></a>XMLHttpRequest脚本注入</h4><p>原理：创建一个<code>xhr</code>对象，用它下载js文件，然后通过创建动态<code>&lt;script&gt;</code>元素将代码注入页面中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'file1.js'</span>, <span class="literal">true</span>);  <span class="comment">//第三个参数表是否异步</span></div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (xhr.readystate === <span class="number">4</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status === <span class="number">304</span>) &#123;</div><div class="line">            <span class="keyword">var</span> script = <span class="built_in">document</span>.craeteElement(<span class="string">'script'</span>);</div><div class="line">            script.type = <span class="string">"text/javascript"</span>;</div><div class="line">            script.text = xhr.responseText;</div><div class="line">            <span class="built_in">document</span>.body.appendChild(script);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">xhr.send(<span class="literal">null</span>);</div></pre></td></tr></table></figure><p>优点：js代码下载后不会自动执行，你可以把脚本的执行推迟到准备好的时候。<em>（为什么啊？？？书上说代码返回在script标签外，所以不自动执行…没看懂啊…）</em></p><p>局限：不能跨域请求js文件，也就不能从CDN下载咯。</p><h4 id="推荐的无阻塞模式"><a href="#推荐的无阻塞模式" class="headerlink" title="推荐的无阻塞模式"></a>推荐的无阻塞模式</h4><p>先添加动态加载所需的代码，然后加载初始化页面所需的剩下的代码。</p><p>有几个延迟加载工具：</p><ul><li><code>LazyLoad</code>类库，其实就是<code>loadScript()</code>的增强版</li><li><code>LABjs</code>，它的优点是管理依赖关系的能力</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一章主要从管理浏览器中的js代码来进行阐述优化点。&lt;/p&gt;
&lt;h3 id=&quot;优化点1：将脚本放在底部&quot;&gt;&lt;a href=&quot;#优化点1：将脚本放在底部&quot; class=&quot;headerlink&quot; title=&quot;优化点1：将脚本放在底部&quot;&gt;&lt;/a&gt;优化点1：将脚本放在底部&lt;/h3&gt;&lt;p&gt;讲道理，按我们的理解，将js文件和css文件一起放在head中好像没什么毛病，先加载它们，有助于页面渲染和正确交互呀。&lt;/p&gt;
&lt;p&gt;可是！可是坑爹的是，脚本是会阻塞页面渲染的啊，浏览器需要等到它们全部下载并执行完成后，才继续页面渲染。所以把脚本放页面头部会导致明显的延迟，表现为显示空白页面，用户无法浏览页面，也无法与页面进行交互。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://hu33.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
      <category term="性能" scheme="http://hu33.tech/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>网易秋招面试</title>
    <link href="http://hu33.tech/2017/08/31/%E7%BD%91%E6%98%93%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
    <id>http://hu33.tech/2017/08/31/网易秋招面试/</id>
    <published>2017-08-31T14:13:25.359Z</published>
    <updated>2019-01-10T14:12:01.471Z</updated>
    
    <content type="html"><![CDATA[<p>2017年网易公共技术秋招-前端开发工程师。</p><p>记录一下噢。</p><a id="more"></a><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol><li>自我介绍一下</li><li>jQuery有哪些优势</li><li>jQuery插件怎么写</li><li>怎么学习前端的，看过哪些书</li><li>JS、CSS、HTML哪个比较熟</li><li>js的基本数据类型</li><li>js中比较经典的引用类型</li><li>基本数据类型和引用类型的区别</li><li>Function对象是干嘛用的</li><li>写一个构造函数继承（因为上面讲到了可以实现继承…）</li><li>Array对象的slice方法（因为写继承的时候有用到…）</li><li>怎么处理浏览器兼容，比如添加事件这个方法（DOM0级事件添加我竟然忘了…IE的attachEvent也没想起来…）</li><li>事件委托的原理，举例，优点</li><li>哪些事件不能冒泡</li><li>写一个经典的闭包（刚好前两天在项目里实现了个函数防抖，就写了这个哈哈哈）</li><li>讲一下CSS的盒模型</li><li>position有哪几种值，分别表示什么</li><li>CSS选择器有哪些</li><li>兄弟选择器是用什么表示，举个用到了兄弟选择器的例子</li><li>CSS如果有重复，怎么判断哪些生效（计算权重）</li><li>伪类和伪元素是一样的吗？</li><li>cookie、sessionStorage、localStorage区别</li><li>chrome开发者工具有哪些部分很好用？</li><li>最近在学什么？接下来半年准备学什么？</li></ol><p>总的来说一面还是蛮顺利的，二面就开始被吊打了。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ol><li>介绍一下项目（介绍了公司实习的项目，然而介绍完之后面试官并不问我项目啊啊，直接甩后面的问题了）</li><li>如何学习前端知识的</li><li>JS、CSS、HTML熟悉程度排序（我的回答是JS&gt;CSS&gt;HTML，他默默抬头看了我一眼…然后我有点虚，说这样排序并不是表示我真的对JS最熟悉，而是因为JS内容太多了，我在它上面花的时间最多…）</li><li>要你用原生JS实现一个模块预加载器的话，你会怎么做？（懵逼啊，题目都没搞明白，搞明白后就是懵逼啊…完全没思路…不过面试官看我很迷茫就说了句，没关系的，总有人知道有人不知道的）</li><li>要判断一个元素是否在数组中，你会怎么做？（我当时第一反应是indexOf啊，但是我想着这个问题不会这么简单，就说把数组遍历一遍，用forEach，后来又改成some。面试官竟然笑了…瘆得我呀…他说不用考虑我想考察你什么，你就平常怎么用的就怎么说好了。然后我就说那就用indexOf，要是不存在就返回-1咯。）</li><li>那一个数组中某个元素可能不止一个，你怎么判断？（这次直接就说了用lastIndexOf跟indexOf比较，相等就表示只有一个）</li><li>平常怎么给数组排序的？（我说如果不考虑性能的话就用Array自带的sort()，他问我那要是考虑性能呢？我弱弱地说了句，那就看情况吧…）</li><li>平常编码的时候有考虑代码层面的性能优化吗？（…表示除了eslint上的规范，其他没怎么考虑了…）</li><li>H5和CSS3用了些什么？（这里又给自己挖了个坑，说用CSS3实现字符串长度过长就截取并用省略号代替，然后面试官让我写一下，我竟然把white-space属性名给忘了…）</li><li>SEO有了解吗？（还真没去了解过…）</li><li>实现一个ajax</li><li>跨域知道哪些？（jsonp的安全攻防问题，cors怎么实现？）</li><li>要你实现一个UI和数据的双向绑定，你怎么做？（我问能用框架吗…他表示当然是用原生js实现啦，框架都帮你实现了…）</li><li>双向绑定和单向数据流的优缺点（表示只用过单向数据流的React，大致讲了一下，感觉他并不满意…）</li></ol><p>能想起来的问题基本是这些了，最后他说那我这边基本上没问题了，你有什么问题要问的吗？我感觉才面了很短的时间啊，怎么这么快就面完了，然后就表示很惊讶，“恩？这么快？我感觉我比较熟的方向您都没有问诶。。。”他问我对什么比较熟，我说react，然后他回了一句，因为我们不用react，我们有自己实现的一套框架。我：……</p><p>唉，然后我感觉没戏血崩炮灰，问的问题要么不会要么没答好。尤其是js基础方面太差，很多东西大概了解，但是没有去深入理解，所以问到一些实现思路的时候只能一脸懵逼了。所以后来问了下，面试下来您觉得我哪些方面需要加强，我感觉自己js基础比较差应该再深入学习一下。然后面试官停下敲键盘的手，以一个过来人的身份语重心长地跟我讲，其实基础才是最重要的。很多人会觉得会很多框架很炫酷，但其实不管怎么样你都只是在用别人的东西，只是一个不断找坑填坑的过程。但是真正牛逼的人都是基础很牢固，他们能在开发中发现一些底层的问题，然后考虑自己的业务场景和实际需求，自己实现，其实这个过程也就是框架的诞生过程。我们不能只看到市面上的各类框架，我们得知道为啥这些框架为什么会出现，为了解决什么问题，又是如何去实现解决的。</p><p>上面的话并不是原话…反正大概是这个意思吧，之前美团面试官也跟我讲过类似的话。不管怎么样，想成为一名合格的工程师，除了会用API，还要对底层原理很熟悉呀，不然就真的只是程序猿了…</p><h3 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h3><p>我也觉得很神奇啊，二面答成那样还能有HR面。</p><p>HR面其实没啥好讲了，基本是闲聊。比如学习路径，实习的公司能留下来为啥还会参加秋招，投了哪些公司，职业规划，为啥投网易，薪资要求，还有就是一些调查式的问题了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>啊呀，虽然走完了流程，但是表示心里很方啊。不过也好，又深刻地认识到了一个不足之处，只有被吊打之后才有强劲动力去弥补啊。好的吧，自我安慰到此结束，还是继续学习吧…毕竟前路茫茫~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年网易公共技术秋招-前端开发工程师。&lt;/p&gt;
&lt;p&gt;记录一下噢。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面经" scheme="http://hu33.tech/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript常见编程题（下）</title>
    <link href="http://hu33.tech/2017/08/28/JavaScript%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://hu33.tech/2017/08/28/JavaScript常见编程题（下）/</id>
    <published>2017-08-28T15:10:07.346Z</published>
    <updated>2019-01-13T13:21:34.782Z</updated>
    
    <content type="html"><![CDATA[<ol><li>用两个栈实现队列 </li><li>实现对象的深克隆  <code>deepClone</code></li><li>实现函数防抖和节流  <code>debounce</code>, <code>thottle</code></li><li>模拟ES5 bind实现 <code>Function.prototype.bind</code></li><li>用函数表达<code>new</code>实例化的过程  <code>createObject</code></li><li>实现懒加载 <code>lazyLoad</code></li><li>实现一个LazyMan  <code>LazyMan</code></li></ol><a id="more"></a><h4 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h4><p>用两个栈来实现一个队列，完成队列的enqueue和dequeue操作。 队列中的元素为int类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueue</span>(<span class="params">inputStack, item</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> inputStack.push(item);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span>(<span class="params">inputStack, outputStack</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (outputStack.length &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">while</span> (inputStack.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            outputStack.push(inputStack.pop());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> outputStack.pop();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="实现对象的深克隆"><a href="#实现对象的深克隆" class="headerlink" title="实现对象的深克隆"></a>实现对象的深克隆</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'return'</span> + obj.toString());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</div><div class="line">        <span class="keyword">if</span> (obj[key] === obj) &#123;</div><div class="line">            <span class="keyword">continue</span> ;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj[key]) || <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</div><div class="line">            target[key] = deepClone(obj[key]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            target[key] = obj[key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="实现函数防抖和节流"><a href="#实现函数防抖和节流" class="headerlink" title="实现函数防抖和节流"></a>实现函数防抖和节流</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//防抖：等待事件触发后等一段时间再执行，如果触发频率高于设定的延迟时间，就一直等下去</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, interval</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> timer, firstTime = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        clearTimeout(timer);  <span class="comment">//每次触发前都清空定时器，重新计时</span></div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</div><div class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">if</span>(firstTime) &#123;</div><div class="line">            firstTime = <span class="literal">false</span>;</div><div class="line">            fn.apply(self, args);</div><div class="line">        &#125;</div><div class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            fn.apply(self, args);</div><div class="line">        &#125;, interval || <span class="number">500</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//节流：不论触发频率，单位时间内指定函数就只被调用一次</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, interval</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> timer, firstTime = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</div><div class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">if</span> (firstTime) &#123;  <span class="comment">//第一次立即执行</span></div><div class="line">            firstTime = <span class="literal">false</span>;</div><div class="line">            fn.apply(<span class="keyword">this</span>, args);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (timer) &#123;    <span class="comment">//上次的延迟还没执行</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   <span class="comment">//延迟执行</span></div><div class="line">            clearTimeout(timer);</div><div class="line">            timer = <span class="literal">null</span>;</div><div class="line">            fn.apply(<span class="keyword">this</span>, args);</div><div class="line">        &#125;, interval || <span class="number">500</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>####模拟ES5bind实现Function.prototype.bind</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">        self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="keyword">this</span> : context, args.concat(bindArgs));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</div><div class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</div><div class="line">    <span class="keyword">return</span> fBound;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="external">参考</a></p></blockquote><p>####用函数表达new实例化的过程 createObject</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>;</div><div class="line">  <span class="keyword">var</span> Constructor = <span class="built_in">Array</span>.shift.call(<span class="built_in">arguments</span>);</div><div class="line">  obj.__proto__ = Constructor.prototype;</div><div class="line">  <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret : obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="external">参考</a></p></blockquote><p>####实现一个LazyMan</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_LazyMan</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.tasks = [];   </div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> fn =(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> name = n;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"Hi! This is "</span> + name + <span class="string">"!"</span>);</div><div class="line">            self.next();</div><div class="line">        &#125;</div><div class="line">    &#125;)(name);</div><div class="line">    <span class="keyword">this</span>.tasks.push(fn);</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        self.next();</div><div class="line">    &#125;, <span class="number">0</span>); <span class="comment">// 在下一个事件循环启动任务</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 事件调度函数 */</span></div><div class="line">_LazyMan.prototype.next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span>.tasks.shift();</div><div class="line">    fn &amp;&amp; fn();</div><div class="line">&#125;</div><div class="line"></div><div class="line">_LazyMan.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">var</span> fn =(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"Eat "</span> + name + <span class="string">"~"</span>);</div><div class="line">            self.next()</div><div class="line">        &#125;</div><div class="line">    &#125;)(name);</div><div class="line">    <span class="keyword">this</span>.tasks.push(fn);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 实现链式调用</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">_LazyMan.prototype.sleep = <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span>(<span class="params">time</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"Wake up after "</span> + time + <span class="string">"s!"</span>);</div><div class="line">                self.next();</div><div class="line">            &#125;, time * <span class="number">1000</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;)(time);</div><div class="line">    <span class="keyword">this</span>.tasks.push(fn);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">_LazyMan.prototype.sleepFirst = <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"Wake up after "</span> + time + <span class="string">"s!"</span>);</div><div class="line">                self.next();</div><div class="line">            &#125;, time * <span class="number">1000</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;)(time);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.tasks.unshift(fn);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 封装 */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LazyMan</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _LazyMan(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><a href="https://zhuanlan.zhihu.com/p/22387417" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/22387417</a></p><p><a href="http://www.jianshu.com/p/f1b7cb456d37" target="_blank" rel="external">http://www.jianshu.com/p/f1b7cb456d37</a></p></blockquote><h4 id="实现懒加载"><a href="#实现懒加载" class="headerlink" title="实现懒加载"></a>实现懒加载</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyLoad</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> imgs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>);</div><div class="line">    <span class="keyword">var</span> n = <span class="number">0</span>;  <span class="comment">//提升的变量，避免每次都从第一张图片进行遍历</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> clientHeight = <span class="built_in">document</span>.documentElement.clientHeight;</div><div class="line">        <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</div><div class="line">        </div><div class="line">        <span class="keyword">var</span> i, len;</div><div class="line">        <span class="keyword">for</span> (i = n, len = imgs.length; i &lt; length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (imgs[i].offsetTop &lt; clientHeight + scrollTop) &#123;</div><div class="line">                <span class="keyword">if</span> (imgs[i].getAttribute(<span class="string">'src'</span>) === <span class="string">'images/loading.gif'</span>) &#123;</div><div class="line">                    imgs[i].src = imgs[i].getAttribute(<span class="string">'data-src'</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        n++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.addEventListner(<span class="string">'scroll'</span>, throttle(lazyLoad, <span class="number">200</span>), <span class="literal">false</span>);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;用两个栈实现队列 &lt;/li&gt;
&lt;li&gt;实现对象的深克隆  &lt;code&gt;deepClone&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实现函数防抖和节流  &lt;code&gt;debounce&lt;/code&gt;, &lt;code&gt;thottle&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;模拟ES5 bind实现 &lt;code&gt;Function.prototype.bind&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用函数表达&lt;code&gt;new&lt;/code&gt;实例化的过程  &lt;code&gt;createObject&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实现懒加载 &lt;code&gt;lazyLoad&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实现一个LazyMan  &lt;code&gt;LazyMan&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
      <category term="编程题" scheme="http://hu33.tech/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript常见编程题（中）</title>
    <link href="http://hu33.tech/2017/08/26/JavaScript%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
    <id>http://hu33.tech/2017/08/26/JavaScript常见编程题（中）/</id>
    <published>2017-08-26T14:37:38.596Z</published>
    <updated>2019-01-13T13:19:44.426Z</updated>
    
    <content type="html"><![CDATA[<ol><li>判断字符串是否为回文串  <code>isPalindrom</code></li><li>乱序同字母字符串  <code>isAnagram</code></li><li>统计一个字符串出现最多的字母  <code>findMaxDuplicateChar</code></li><li>计算二进制中1的个数  <code>countBit</code></li><li>随机生成指定长度的字符串  <code>randomString</code></li><li>判断传入值是否为2的乘方  <code>is2power</code></li><li>使用递归实现二进制转换  <code>decimalToBinary</code></li><li>判断大括号是否闭合  <code>isBalanced</code></li><li>生成斐波拉契数列   <code>getFibonacci</code></li></ol><a id="more"></a><h4 id="判断字符串是否为回文串"><a href="#判断字符串是否为回文串" class="headerlink" title="判断字符串是否为回文串"></a>判断字符串是否为回文串</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//循环</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrom</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> i, len;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = str.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (str.charAt(i) !== str.charAt(len-i<span class="number">-1</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//借用数组的reverse()</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrom</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) === str;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="乱序同字母字符串"><a href="#乱序同字母字符串" class="headerlink" title="乱序同字母字符串"></a>乱序同字母字符串</h4><p>给定两个字符串，判断是否颠倒字母而成的字符串，譬如 Mary 和 Army 就是同字母而顺序颠倒。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isAnagram</span>(<span class="params">str1, str2</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sortedStr1 = str1.toLowerCase().split(<span class="string">''</span>).sort().join(<span class="string">''</span>);</div><div class="line">    <span class="keyword">var</span> sortedStr2 = str2.toLowerCase().split(<span class="string">''</span>).sort().join(<span class="string">''</span>);</div><div class="line">    <span class="keyword">return</span> sortedStr1 === sortedStr2;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="统计一个字符串出现最多的字母"><a href="#统计一个字符串出现最多的字母" class="headerlink" title="统计一个字符串出现最多的字母"></a>统计一个字符串出现最多的字母</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxDuplicateChar</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> hashObj = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> i, len;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = str.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">var</span> char = str.charAt(i);</div><div class="line">        <span class="keyword">if</span> (hashObj[char]) &#123;</div><div class="line">            hashObj[char]++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            hashObj[char] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(hashObj);</div><div class="line">    <span class="keyword">var</span> max = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> maxChar = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> hashObj) &#123;</div><div class="line">        <span class="keyword">if</span> (hashObj[item] &gt; max) &#123;</div><div class="line">            max = hashObj[item];</div><div class="line">            maxChar = item;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxChar;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="计算二进制中1的个数"><a href="#计算二进制中1的个数" class="headerlink" title="计算二进制中1的个数"></a>计算二进制中1的个数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用字符的toString方法，对负整数不管用</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countBit</span>(<span class="params">binaryNum</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> binaryStr = binaryNum.toString(<span class="number">2</span>).replace(<span class="regexp">/0/g</span>,<span class="string">''</span>);</div><div class="line">    <span class="keyword">return</span> binaryStr.length;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用1与n进行与运算，再将n进行无符号右移</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countBit</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (n !== <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="number">1</span> &amp; n) &#123;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">        n = n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//n与n-1进行与运算</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countBit</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (n !== <span class="number">0</span>) &#123;</div><div class="line">        count++;</div><div class="line">        n = n &amp; (n - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><a href="http://www.jianshu.com/p/0b881319745f" target="_blank" rel="external">参考</a></p></blockquote><h4 id="随机生成指定长度的字符串"><a href="#随机生成指定长度的字符串" class="headerlink" title="随机生成指定长度的字符串"></a>随机生成指定长度的字符串</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用36进制大数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomString</span>(<span class="params">len</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> randomStr = <span class="string">""</span>;</div><div class="line">    <span class="keyword">while</span> (randomStr.length &lt; len) &#123;</div><div class="line">        randomStr += <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).substr(<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> randomStr.substr(<span class="number">0</span>, len);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//枚举所有字符，有点蠢额...</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomString</span>(<span class="params">len</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> randomStr = <span class="string">""</span>;</div><div class="line">    <span class="keyword">var</span> strArr = [<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>,<span class="string">"g"</span>,<span class="string">"h"</span>,<span class="string">"i"</span>,<span class="string">"j"</span>,<span class="string">"k"</span>,<span class="string">"l"</span>,<span class="string">"m"</span>,<span class="string">"n"</span>,<span class="string">"o"</span>,<span class="string">"p"</span>,<span class="string">"q"</span>,<span class="string">"r"</span>,<span class="string">"s"</span>,<span class="string">"t"</span>,<span class="string">"u"</span>,<span class="string">"v"</span>,<span class="string">"w"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>];</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">var</span> pos = <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * strArr.length);</div><div class="line">        <span class="built_in">console</span>.log(pos);</div><div class="line">        randomStr += strArr[pos];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> randomStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="判断传入值是否为2的乘方"><a href="#判断传入值是否为2的乘方" class="headerlink" title="判断传入值是否为2的乘方"></a>判断传入值是否为2的乘方</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//若num是2的乘方，那么num &amp; num - 1为0</span></div><div class="line"><span class="comment">//如num为8时，其二进制为1000，num-1的二进制为0111，num &amp; (num-1) === 0</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">is2power</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(num &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((num &amp; (num - <span class="number">1</span>)) === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="使用递归实现二进制转换"><a href="#使用递归实现二进制转换" class="headerlink" title="使用递归实现二进制转换"></a>使用递归实现二进制转换</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">decimalToBinary</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> decimalToBinary((n - <span class="number">1</span>) / <span class="number">2</span>) + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> decimalToBinary(n / <span class="number">2</span>) + <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">''</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="判断大括号是否闭合"><a href="#判断大括号是否闭合" class="headerlink" title="判断大括号是否闭合"></a>判断大括号是否闭合</h4><p>创建一个函数来判断给定的表达式中的大括号是否闭合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBalanced</span>(<span class="params">expression</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (expression.length &lt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> stack = [];</div><div class="line">  <span class="keyword">var</span> i, len;</div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, len = expression.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="keyword">var</span> char = expression.charAt(i);</div><div class="line">    <span class="keyword">if</span> (char === <span class="string">'&#123;'</span>) &#123;</div><div class="line">      stack.push(char);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">'&#125;'</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (stack.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        stack.pop();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (stack.pop())&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="生成斐波拉契数列"><a href="#生成斐波拉契数列" class="headerlink" title="生成斐波拉契数列"></a>生成斐波拉契数列</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//for循环</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFibonacci</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">var</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (i &lt; <span class="number">2</span>) &#123;</div><div class="line">            arr.push(<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            arr.push(arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用闭包实现一个Fibonacci数的生成器</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">genFibo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> res = a;</div><div class="line">        a = b;</div><div class="line">        b = res + b;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> genFibo;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFibonacci</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">var</span> genFibo = fibo();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">        arr.push(genFibo());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;判断字符串是否为回文串  &lt;code&gt;isPalindrom&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;乱序同字母字符串  &lt;code&gt;isAnagram&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;统计一个字符串出现最多的字母  &lt;code&gt;findMaxDuplicateChar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;计算二进制中1的个数  &lt;code&gt;countBit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;随机生成指定长度的字符串  &lt;code&gt;randomString&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;判断传入值是否为2的乘方  &lt;code&gt;is2power&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用递归实现二进制转换  &lt;code&gt;decimalToBinary&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;判断大括号是否闭合  &lt;code&gt;isBalanced&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;生成斐波拉契数列   &lt;code&gt;getFibonacci&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
      <category term="编程题" scheme="http://hu33.tech/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>js中的深拷贝</title>
    <link href="http://hu33.tech/2017/08/26/js%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://hu33.tech/2017/08/26/js中的深拷贝/</id>
    <published>2017-08-26T10:24:43.680Z</published>
    <updated>2019-01-13T13:19:00.775Z</updated>
    
    <content type="html"><![CDATA[<p>深拷贝这个坑我一定要来填上了，毕竟绊了我好几次。。。</p><p>先交代一下这次填坑的背景，简单说来就是使用<code>Object.assign</code>来拷贝对象，结果这玩意儿有陷阱啊~害得我项目中<code>setState</code>没有被触发，子组件死活不更新，不<code>render</code>，找了半天问题才发现原来坑在这个地方。</p><a id="more"></a><h3 id="Object-assign-的陷阱"><a href="#Object-assign-的陷阱" class="headerlink" title="Object.assign()的陷阱"></a>Object.assign()的陷阱</h3><p>平常我们写React处理<code>state</code>时，希望数据是immutable，这样处理起来更容易更方便。一般我们喜欢用<code>Object.assign()</code>来复制对象，我一直以为<code>Object.assign()</code>是深复制，会连子节点一起复制。今天项目中的bug让我认识到，我真是错看了它啊~</p><p><code>Object.assign()</code>其实是浅层拷贝，只会对非嵌套的对象进行拷贝，但是如果对象中有嵌套的话，它就只会对被嵌套的对象做引用拷贝了。</p><p>可以看一下Polyfill对<code>Object.assign</code>的实现源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.assign != <span class="string">'function'</span>) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">Object</span>.assign = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</div><div class="line"><span class="meta">  'use strict'</span>;</div><div class="line">   <span class="keyword">if</span> (target === <span class="literal">undefined</span> || target === <span class="literal">null</span>) &#123;</div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot convert undefined or null to object'</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">var</span> output = <span class="built_in">Object</span>(target);</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">1</span>; index &lt; <span class="built_in">arguments</span>.length; index++) &#123;</div><div class="line">     <span class="keyword">var</span> source = <span class="built_in">arguments</span>[index];</div><div class="line">     <span class="keyword">if</span> (source !== <span class="literal">undefined</span> &amp;&amp; source !== <span class="literal">null</span>) &#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> nextKey <span class="keyword">in</span> source) &#123;</div><div class="line">         <span class="keyword">if</span> (source.hasOwnProperty(nextKey)) &#123;</div><div class="line">           output[nextKey] = source[nextKey];</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> output;</div><div class="line">  &#125;;</div><div class="line">  &#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>好的吧，其实<code>Object.assign</code>只是这样设计的，并不能说是它的陷阱，当一回标题党。。。</p><h3 id="js中的深拷贝"><a href="#js中的深拷贝" class="headerlink" title="js中的深拷贝"></a>js中的深拷贝</h3><p>虽然有些时候用<code>Object.assign()</code>也够了，但是一旦对象嵌套，用<code>Object.assign()</code>就很可能出现问题，那就要实现深拷贝了。</p><p>js深拷贝有两种方式：</p><ol><li><p>一种是用JSON对象，简单粗暴</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个方法好处就是简单，粗暴，但是存在两个问题：</p><ul><li>一个是会破坏原型链，深拷贝之后，不管这个对象原来的构造函数是什么，深拷贝之后都会变成<code>Object</code></li><li>另一个是它只能处理<code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Array</code>、扁平对象，即能够被json直接表示的数据结构，无法拷贝属性为<code>Function</code>以及<code>RegExp</code>这类的属性</li><li>但是如果只是想单纯拷贝一个嵌套对象，用它还是可以的。</li></ul></li><li><p>另一种实现方式就是递归拷贝：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span> &amp;&amp; !isFunction(obj)) &#123;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (isFunction(obj)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"return"</span> + obj.toString())();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">var</span> name,value;</div><div class="line">    <span class="keyword">var</span> target = isArray(obj) ? [] : &#123;&#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (name <span class="keyword">in</span> obj) &#123;</div><div class="line">      value = obj[name];</div><div class="line">      <span class="comment">//判断有没有循环引用</span></div><div class="line">      <span class="keyword">if</span> (value === obj) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> (isArray(obj) || isObject(value)) &#123;</div><div class="line">        target[name] = deepClone(obj[name]);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        target[name] = value;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个方法考虑了obj是否为数组、函数以及是否有循环引用的问题，算是比较全面了，但是要实现<code>isArray</code>、<code>isFunction</code>、<code>isObject</code>的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $ = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> types = <span class="string">'Array Object String Date RegExp Function Boolean Number Null Undefined'</span>.split(<span class="string">' '</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">this</span>).slice(<span class="number">8</span>, <span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = types.length; i--;) &#123;</div><div class="line">    $[<span class="string">'is'</span> + types[i]] = (<span class="function"><span class="keyword">function</span> (<span class="params">self</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">elem</span>) </span>&#123;</div><div class="line">           <span class="keyword">return</span> type.call(elem) === self;</div><div class="line">        &#125;;</div><div class="line">    &#125;)(types[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> $;</div><div class="line">&#125;)();<span class="comment">//类型判断</span></div></pre></td></tr></table></figure></li><li><p>可以直接使用那些类库的<code>deepClone</code>方法，比如<code>lodash</code>的<code>cloneDeep</code>、<code>jQuery.extend</code>等</p></li></ol><h3 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h3><p>JS中的对象一般是可变的，因为是使用了引用赋值，新的随心简单的引用了原始对象，这样可以节约内存，但是应用复杂后，会造成很大的隐患。要解决这个问题的话一般就是用浅拷贝或深拷贝来避免被修改了，但是这样会造成CPU和内存的浪费，就是很耗性能啦。</p><p>结合React来看，我们经常在对React应用进行性能优化时会用到<code>shouldComponentUpdate</code>，在这个函数中对state或props进行比较来判断要不要render，但是<code>deepClone</code>和<code>deepCompare</code>都非常消耗性能。但是用Immutable只需要使用<code>===</code>和<code>is</code>比较就能知道是否要执行<code>render()</code>了，所以性能提升是很大的。</p><p>不过具体要不要用，当然得看项目中对这个需求大不大了。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深拷贝这个坑我一定要来填上了，毕竟绊了我好几次。。。&lt;/p&gt;
&lt;p&gt;先交代一下这次填坑的背景，简单说来就是使用&lt;code&gt;Object.assign&lt;/code&gt;来拷贝对象，结果这玩意儿有陷阱啊~害得我项目中&lt;code&gt;setState&lt;/code&gt;没有被触发，子组件死活不更新，不&lt;code&gt;render&lt;/code&gt;，找了半天问题才发现原来坑在这个地方。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript常见编程题（上）</title>
    <link href="http://hu33.tech/2017/08/21/JavaScript%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://hu33.tech/2017/08/21/JavaScript常见编程题（上）/</id>
    <published>2017-08-21T12:23:49.268Z</published>
    <updated>2019-01-13T13:21:10.746Z</updated>
    
    <content type="html"><![CDATA[<ol><li>单个数组去重  <code>unique</code></li><li>两个数组并集、交集、差集  <code>union</code>、<code>intersection</code>、<code>difference</code></li><li>计算数组中元素乘积  <code>productOfArrayExceptSelf</code></li><li>找出数组中最大差值  <code>getMaxProfit</code></li><li>找出连续数组中的缺失数  <code>findMissingNumber</code></li><li>找出整型数组中乘积最大的三个数</li><li>找出出现奇数次的数  <code>findOddTimesNum</code></li><li>二分搜索递归实现  <code>binarySearch</code></li><li>实现一个洗牌算法  <code>shuffle</code></li></ol><a id="more"></a><h4 id="单个数组去重"><a href="#单个数组去重" class="headerlink" title="单个数组去重"></a>单个数组去重</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//HashObject（会自动对传入的键执行toString()）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> result = [];</div><div class="line">    <span class="keyword">let</span> hashObj = &#123;&#125;;</div><div class="line">    <span class="keyword">let</span> i, len;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!hashObj[arr[i]]) &#123;</div><div class="line">            hashObj[arr[i]] = <span class="literal">true</span>;</div><div class="line">            result.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//遍历数组，使用indexOf看元素是否已在result数组中</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> result = [];</div><div class="line">    <span class="keyword">let</span> i,len;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (result.indexOf(arr[i]) === <span class="number">-1</span>) &#123;</div><div class="line">            result.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用filter过滤出index和lastIndex相等的元素</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> result = arr.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</div><div class="line">       <span class="keyword">return</span> index === arr.lastIndexOf(item); </div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><a href="https://www.toobug.net/article/array_unique_in_javascript.html" target="_blank" rel="external">参考</a></p></blockquote><h4 id="两个数组求并集、交集、差集"><a href="#两个数组求并集、交集、差集" class="headerlink" title="两个数组求并集、交集、差集"></a>两个数组求并集、交集、差集</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">arr1, arr2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> arr1.concat(arr2.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">       <span class="keyword">return</span> arr1.indexOf(item) === <span class="number">-1</span>;</div><div class="line">    &#125;));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params">arr1, arr2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> arr1.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> arr1.indexOf(item) !== <span class="number">-1</span> &amp;&amp; arr2.indexOf(item) !== <span class="number">-1</span>;</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">difference</span>(<span class="params">arr1, arr2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> arr1.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> arr2.indexOf(item) === <span class="number">-1</span>;</div><div class="line">    &#125;).concat(arr2.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> arr1.indexOf(item) === <span class="number">-1</span>;</div><div class="line">    &#125;))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ES6</span></div><div class="line"><span class="keyword">const</span> union = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([...arr1, ...arr2]));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> intersection = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> arr1.filter(<span class="function"><span class="params">item</span>=&gt;</span> <span class="keyword">new</span> <span class="built_in">Set</span>(arr2).has(item));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> difference = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr1);</div><div class="line">    <span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2);</div><div class="line">    <span class="keyword">return</span> arr1.concat(arr2).filter(<span class="function"><span class="params">item</span> =&gt;</span> !set2.has(item) || !set1.has(item));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ES7</span></div><div class="line"><span class="keyword">const</span> union = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> arr1.concat(arr2.filter(<span class="function"><span class="params">item</span> =&gt;</span> !arr1.includes(item)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> intersection = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> arr1.filter(<span class="function"><span class="params">item</span> =&gt;</span> arr2.includes(item));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> difference = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> arr1.concat(arr2).filter(<span class="function"><span class="params">item</span> =&gt;</span> !arr1.includes(item) || !arr2.includes(item));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="计算数组中元素乘积"><a href="#计算数组中元素乘积" class="headerlink" title="计算数组中元素乘积"></a>计算数组中元素乘积</h4><p>给定某无序数组，要求返回新数组 output ，其中 output[i] 为原数组中除了下标为 i 的元素之外的元素乘积，要求以 O(n) 复杂度实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">productExceptSelf</span>(<span class="params">numArray</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> product = <span class="number">1</span>;</div><div class="line">  <span class="keyword">var</span> size = numArray.length;</div><div class="line">  <span class="keyword">var</span> output = [];</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; size; x++) &#123;</div><div class="line">      output.push(product);</div><div class="line">      product = product * numArray[x];</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> product = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = size - <span class="number">1</span>; i &gt; <span class="number">-1</span>; i--) &#123;</div><div class="line">      output[i] = output[i] * product;</div><div class="line">      product = product * numArray[i];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> output;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><a href="https://www.nowcoder.com/questionTerminal/94a4d381a68b47b7a8bed86f2975db46" target="_blank" rel="external">参考</a></p></blockquote><h4 id="找出数组中最大差值"><a href="#找出数组中最大差值" class="headerlink" title="找出数组中最大差值"></a>找出数组中最大差值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用Math的max和min方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxProfit</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, arr);</div><div class="line">    <span class="keyword">var</span> min = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, arr);</div><div class="line">    <span class="keyword">return</span> max-min;</div><div class="line"><span class="comment">//  return Math.max(...arr) - Math.min(...arr);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="找出连续数组中的缺失数"><a href="#找出连续数组中的缺失数" class="headerlink" title="找出连续数组中的缺失数"></a>找出连续数组中的缺失数</h4><p>给定某无序数组，其包含了 n 个连续数字中的 n - 1 个，已知上下边界，要求以O(n)的复杂度找出缺失的数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMissingNumber</span>(<span class="params">arr, max, min</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arrSum = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> pre + cur;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">var</span> sum = (max * (max + <span class="number">1</span>) / <span class="number">2</span>) - (min * (min - <span class="number">1</span>) / <span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> sum - arrSum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="找出整型数组中乘积最大的三个数"><a href="#找出整型数组中乘积最大的三个数" class="headerlink" title="找出整型数组中乘积最大的三个数"></a>找出整型数组中乘积最大的三个数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先把数组排序，最大乘积要么是min1*min2*max1，要么是max1*max2*max3</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxProduct</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sortedArr = arr.sort(compare);</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> product1 = arr[len - <span class="number">1</span>] * arr[len - <span class="number">2</span>] * arr[len - <span class="number">3</span>];</div><div class="line">    <span class="keyword">var</span> product2 = arr[<span class="number">0</span>] * arr[<span class="number">1</span>] * arr[len - <span class="number">1</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a - b;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="找出出现奇数次的数"><a href="#找出出现奇数次的数" class="headerlink" title="找出出现奇数次的数"></a>找出出现奇数次的数</h4><p>给你n个数，其中有且仅有一个数出现了奇数次，其余的数都出现了偶数次。用线性时间常数空间找出出现了奇数次的那一个数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用hashObj</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getShowOddTimesNumber</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> obj[item] = !obj[item]);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</div><div class="line">    <span class="keyword">if</span>(obj[key]) &#123;</div><div class="line">      <span class="keyword">return</span> key;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//将所有元素都异或一遍，最后得到的就是那个出现奇数次的元素</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getShowOddTimesNumber</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre,cur</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> pre ^ cur;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="二分搜索递归实现"><a href="#二分搜索递归实现" class="headerlink" title="二分搜索递归实现"></a>二分搜索递归实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">arr, value, left, right</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>);</div><div class="line">    <span class="keyword">if</span> (arr[mid] === value) &#123;</div><div class="line">        <span class="keyword">return</span> mid;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; value) &#123;</div><div class="line">        <span class="keyword">return</span> binarySearch(arr, value, left, mid - <span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> binarySearch(arr, value, mid + <span class="number">1</span>, right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>####实现一个洗牌算法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//随机选取数组中的元素添加到另一个数组中，复杂度为n^2</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="keyword">var</span> random;</div><div class="line">    <span class="keyword">while</span> (arr.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length);</div><div class="line">        result.push(arr[randomIndex]);</div><div class="line">        arr.splice(randomIndex, <span class="number">1</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在原数组上进行交换元素的操作，时间复杂度为n</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> randomIndex, tmp;</div><div class="line">    <span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</div><div class="line">        randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * len);</div><div class="line">        len--;</div><div class="line">        tmp = arr[randomIndex];</div><div class="line">        arr[randomIndex] = arr[len];</div><div class="line">        arr[len] = tmp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;单个数组去重  &lt;code&gt;unique&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;两个数组并集、交集、差集  &lt;code&gt;union&lt;/code&gt;、&lt;code&gt;intersection&lt;/code&gt;、&lt;code&gt;difference&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;计算数组中元素乘积  &lt;code&gt;productOfArrayExceptSelf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;找出数组中最大差值  &lt;code&gt;getMaxProfit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;找出连续数组中的缺失数  &lt;code&gt;findMissingNumber&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;找出整型数组中乘积最大的三个数&lt;/li&gt;
&lt;li&gt;找出出现奇数次的数  &lt;code&gt;findOddTimesNum&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;二分搜索递归实现  &lt;code&gt;binarySearch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实现一个洗牌算法  &lt;code&gt;shuffle&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
      <category term="编程题" scheme="http://hu33.tech/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>DOM知识点--《高程》</title>
    <link href="http://hu33.tech/2017/08/14/DOM%E7%9F%A5%E8%AF%86%E7%82%B9--%E3%80%8A%E9%AB%98%E7%A8%8B%E3%80%8B/"/>
    <id>http://hu33.tech/2017/08/14/DOM知识点--《高程》/</id>
    <published>2017-08-14T15:40:14.842Z</published>
    <updated>2019-01-13T13:18:19.828Z</updated>
    
    <content type="html"><![CDATA[<p><em>《JavaScript高级程序设计》DOM相关知识点复习。</em></p><a id="more"></a><h2 id="DOM层次"><a href="#DOM层次" class="headerlink" title="DOM层次"></a>DOM层次</h2><ul><li>DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的树形结构</li><li>文档节点是每个文档的根节点，每个文档只能有一个文档元素（<code>\&lt;html&gt;</code>）</li></ul><h3 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h3><ul><li>JS中所有节点类型都继承自<code>Node</code>类型，因此所有节点类型都共享相同的基本属性和方法</li><li>可用<code>Node.nodeType</code>确定节点类型</li><li>对于元素节点，<code>nodeName</code>保存了元素的标签名，<code>nodeValue</code>值为<code>null</code></li></ul><h4 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h4><p>所有节点都有的三个属性：</p><ul><li><strong>childNodes：</strong>其中保存着一个<code>NodeList</code>对象<ul><li><code>NodeList</code>是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点</li><li><code>NodeList</code>是“动态的”，是在访问DOM文档时实时运行的查询，所以DOM结构的变化能自动反映在<code>NodeList</code>对象中（<code>NamedNodeMap</code>和<code>HTMLCollection</code>也是）</li></ul></li><li><strong>parentNode：</strong>该属性指向文档树中的父节点<ul><li>使用<code>previousSibling</code>和<code>nextSibling</code>可以分别访问节点的前一个节点和后一个节点</li><li>父节点的<code>firstChild</code>和<code>lastChild</code>分别指向<code>childNodes</code>列表中的第一个和最后一个节点</li><li>如果某父节点只有一个子节点，那么<code>firstChild</code>和<code>lastChild</code>指向同一个节点，该子节点的<code>previousSibling</code>和<code>nextSibling</code>都为<code>null</code></li><li><code>hasChildNodes()</code>返回节点是否包含子节点</li></ul></li><li><strong>ownerDocument：</strong>指向表示整个文档的文档节点<ul><li>任何节点都不能同时存在于两个或更多个文档中</li></ul></li></ul><h4 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h4><ul><li><p><code>appendChild(newNode)</code>：向<code>childNodes</code>列表的末尾添加一个节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将第一个子节点移到最后一个</span></div><div class="line"><span class="keyword">var</span> returnNode = someNode.appendChild(someNode.firstChild);</div></pre></td></tr></table></figure></li><li><p><code>insertBefore(newNode)</code>：将节点插入到某个节点之前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//插入后成为最后一个子节点</span></div><div class="line"><span class="keyword">var</span> returnNode = someNode.insertBefore(newNode, <span class="literal">null</span>);</div><div class="line"></div><div class="line"><span class="comment">//插入后成为第一个子节点</span></div><div class="line"><span class="keyword">var</span> returnNode = someNode.insertBefore(newNode, someNode.firstNode);</div><div class="line"></div><div class="line"><span class="comment">//插入到最后一个子节点之前</span></div><div class="line"><span class="keyword">var</span> returnNode = someNode.insertBefore(newNode, someNode.lastChild);</div><div class="line"></div><div class="line"><span class="comment">//实现insertAfter</span></div><div class="line">someNode.parentNode.insertBefore(newNode, someNode.nextSibling);</div></pre></td></tr></table></figure></li><li><p><code>replaceChild(newNode，node)</code>：替换某个子节点</p></li><li><p><code>removeChild(node)</code>：删除某个子节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//移除某节点</span></div><div class="line">someNode.parentNode.removeChild(someNode);</div></pre></td></tr></table></figure></li><li><p>前面四个方法操作的是某个节点的子节点，要使用这几个方法必须先获取父节点</p></li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>有两个方法所有类型的节点都有： <code>cloneNode()</code>和<code>normalize()</code></p><ul><li><code>cloneNode()</code>：用于复制节点，参数为true时执行深复制（复制节点及整个子节点数）<ul><li><code>cloneNode()</code>返回的节点属于文档所有，但是并没有为它指定父节点，需要使用插入操作将其插入到文档中</li><li><code>cloneNode()</code>方法只复制特性、子节点，不会复制添加到节点上的js属性，如事件处理程序</li></ul></li><li><code>normalize()</code>：</li></ul><h3 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h3><ul><li><code>document</code>对象是<code>HTMLDocument</code>的一个实例，表示整个HTML页面，也是<code>window</code>对象的一个属性，因此可以作为全局对象来访问</li></ul><h4 id="文档的子节点"><a href="#文档的子节点" class="headerlink" title="文档的子节点"></a>文档的子节点</h4><ul><li>可以使用<code>documentElement</code>属性（始终指向HTML页面中的<code>\&lt;html&gt;</code>元素）或<code>childNodes</code>列表访问文档元素</li><li><code>body</code>属性，直接指向<code>\&lt;body&gt;</code>元素</li><li><code>doctype</code>属性，指向<code>&lt;!DOCTYPE&gt;</code>标签</li><li>多数情况下，不需要在<code>document</code>对象上调用<code>appendChild()</code>、<code>removeChild()</code>和<code>replaceChild()</code>方法，因为文档类型是只读的，且只能有一个元素子节点</li></ul><h4 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h4><p><code>document</code>对象包含一些可表现网页信息的属性。</p><ul><li><code>title</code>：包含<title>元素中的文本</title></li><li><code>URL</code>：包含页面的整个URL</li><li><code>domain</code>：包含页面的域名</li><li><code>referrer</code>：保存着链接到当前页面的那个页面的<code>URL</code></li></ul><p>上面三个属性中，只有<code>domain</code>是可以设置的，但是不能将<code>domain</code>设置为<code>URL</code>不包含的域。</p><p>[通过将不同子域页面的<code>document.domain</code>设为相同的值，就能相互访问对方包含的JavaScript对象了]</p><h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><ul><li><code>getElementById(id)</code>：返回文档中第一次出现的元素（若无则返回<code>null</code>）</li><li><code>getElementsByTagName(tagName)</code>：返回包含零或多个元素的<code>NodeList</code>（在HTML文档中，返回一个<code>HTMLCollection</code>对象）</li><li><code>getElementByName()</code>：返回带有给定<code>name</code>特性的所有元素（一般用来取得单选按钮）</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>使用<code>document.implementation.hasFeature(name, version)</code>检测浏览器是否支持某版本的DOM功能</li><li>使用<code>write()</code>和<code>whiteln()</code>动态向页面中添加内容</li><li>使用<code>open()</code>和<code>close()</code>分别用于打开和关闭网页的输出流</li></ul><h3 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h3><ul><li>要访问元素的标签名，可以用<code>codeName</code>或<code>tagName</code>属性</li><li>HTML中，标签名始终全部大写，XML中，标签名始终与源代码中保持一致</li></ul><h4 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h4><p><code>HTMLElement</code>类型直接继承自<code>Element</code>并添加了一些属性（每个HTML元素中都存在）：<code>id</code>、<code>title</code>、<code>lang</code>、<code>dir</code>、<code>className</code></p><h4 id="操作特性"><a href="#操作特性" class="headerlink" title="操作特性"></a>操作特性</h4><ul><li>获取特性：<code>DOM</code>对象的属性（<code>div.id</code>）、<code>div.getAttribute(&quot;id&quot;)</code>。有两类特殊的特性，其属性值与<code>getAttribute()</code>返回的值不同：<ul><li><code>style</code>：通过属性访问返回一个对象，而用<code>getAttribute()</code>访问返回CSS文本</li><li>事件处理程序（如<code>onClick</code>）：通过属性访问返回一个js函数，用<code>getAttribute()</code>返回相应代码的字符串</li><li>一般使用对象属性获取特性，除非需要自定义特性值，才使用<code>getAttribute()</code></li></ul></li><li>设置特性：<code>setAttribute()</code>。既可以操作HTML特性也可以操作自定义特性。</li><li>删除特性：<code>removeAttribute()</code>。用于彻底删除元素的特性。</li></ul><h4 id="attribute属性"><a href="#attribute属性" class="headerlink" title="attribute属性"></a>attribute属性</h4><ul><li><p><code>Element</code>类型是唯一一个使用<code>attributes</code>属性的DOM节点类型</p></li><li><p><code>attribute</code>属性中包含一个<code>NamedNodeMap</code>，元素的每个特性都由一个<code>Attr</code>节点表示，每个结点都保存在<code>NamedNodeMap</code>对象中。</p></li><li><p><code>NamedNodeMap</code>对象有如下方法：</p><ul><li><code>getNamedItem(name)</code>：返回<code>nodeName</code>为<code>name</code>的特性</li><li>removeNamedItem(name)：删除nodeName为<code>name</code>的特性，并返回该特性的<code>Atrr</code>节点</li><li><code>setNameItem(node)</code>：添加节点，以节点的<code>nodeName</code>属性为索引</li><li><code>item(pos)</code>：返回位于数字<code>pos</code>位置处的节点</li></ul></li></ul><p>[一般要遍历元素的特性时，才会使用<code>attributes</code>属性]</p><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><ul><li>创建元素：<code>document.createElement()</code></li><li>子节点：元素的<code>childNodes</code>属性中包含了它所有子节点</li></ul><h3 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h3><p>其他还比较常见的节点类型有：<code>Text</code>类型、<code>Comment</code>类型、<code>DocumentFragment</code>类型</p><h4 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h4><ul><li>文本节点包含的是纯文本内容，其中包含转义后的HTML字符，但不能包含HTML代码</li><li>每个可以包含内容的元素最多只能有一个文本节点，且必须确实有内容存在</li><li>使用<code>document.createTextNode()</code>创建新文本节点</li><li>在一个包含两个或多个文本节点的父元素上调用<code>normalize()</code>方法，会将所有文本节点合并成一个节点（浏览器在解析文档时永远不会创建相邻的文本节点，这种情况只可能出现在DOM操作中）</li><li>使用<code>splitText()</code>可以将一个文本节点分成两个文本节点（从文本节点中提取数据的DOM解析技术）</li></ul><h4 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h4><ul><li>使用<code>document.createComment()</code>创建注释节点</li><li><code>Comment</code>类型与<code>Text</code>类型继承自相同的基类，拥有除了<code>splitText()</code>之外的所有字符串操作方法</li></ul><h4 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h4><ul><li>所有节点类型中，只有<code>DocumentFragment</code>在文档中没有对应的标记，它可以包含和控制节点，但是不会像完整的文档那样占用额外资源</li><li>可以使用一个文档片保存创建的列表项，然后在一次性将他们添加到文档中，这样可以避免重复渲染</li></ul><h2 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h2><p>对DOM的两个主要的扩展是SelectAPI和HTML。</p><h3 id="选择符API"><a href="#选择符API" class="headerlink" title="选择符API"></a>选择符API</h3><p>SelectAPI致力于让浏览器原生支持CSS查询。</p><ul><li><code>querySelector()</code>：接收一个CSS选择符，返回与该模式匹配的第一个元素:</li><li><code>querySelectorAll()</code>：返回一个NodeList的实例（类似于一组元素的快照，而非不断对文档进行搜索的动态查询）</li><li><code>matchesSelector()</code>：若调用元素与选择符匹配，则返回true，否则返回false</li></ul><h3 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h3><p>Element Traversal API为DOM元素添加了以下5个属性（为了弥补浏览器元素间空格处理不同的差异）：</p><ul><li><code>childElementCount</code>：返回子元素（不包括文本节点和注释）的个数</li><li><code>firstElementChild</code>：指向第一个子元素，<code>firstChild</code>的元素版</li><li><code>lastElementChild</code>：指向最后一个子元素，<code>lastChild</code>的元素版</li><li><code>previousElementSibling</code>：指向前一个同辈元素，<code>previousSibling</code>的元素版</li><li><code>nextElementSibling</code>：指向后一个同辈元素，<code>nextSibling</code>的元素版</li></ul><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><h4 id="与类相关的扩充"><a href="#与类相关的扩充" class="headerlink" title="与类相关的扩充"></a>与类相关的扩充</h4><ul><li><code>getElementByClassName()</code>：返回带有指定类的所有元素的<code>NodeList</code></li><li><code>className</code>属性：用于操作类名，如添加、删除和替换类名</li><li><code>classList</code>属性：也用于操作类名，比<code>className</code>使用更方便安全，有如下方法：<ul><li><code>add(value)</code>：添加类名</li><li><code>remove(value)</code>：删除类名</li><li><code>contains(value)</code>：判断列表中是否存在该类名</li><li><code>toggle(value)</code>：若列表中存在该类名则删除，否则就添加</li></ul></li></ul><h4 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h4><ul><li><code>document.activeElement</code>属性：始终引用DOM中当前获得了焦点的元素</li><li>元素获得焦点的方式有页面加载、用户输入以及在代码中调用<code>focus()</code>方法</li><li>默认情况下，文档加载过程中，<code>document.activeElement</code>的值为<code>null</code>，文档刚刚加载完时，其值为<code>document.body</code>元素的引用</li><li><code>document.hasFocus()</code>可以判断文档是否获得了焦点</li></ul><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><ul><li><code>readyState</code>属性：用来实现一个指示文档已经加载完成的指示器，有两个值：<ul><li><code>loading</code>：正在加载文档</li><li><code>complete</code>：已经加载完文档</li></ul></li><li><code>compatMode</code>属性：说明渲染页面的模式是标准的还是混杂的<ul><li><code>CSS1Compat</code>：标准模式（按照W3C的标准解析和渲染页面）</li><li><code>BackCompat</code>：混杂模式（按浏览器自己的标准解析渲染页面）</li></ul></li><li><code>head</code>属性：指向文档的<code>\&lt;head&gt;</code>元素</li><li><code>charset</code>属性：表示文档中实际使用的字符集，也可以用来指定新字符集</li><li><code>dataset</code>属性：用于访问自定义属性的值，为一个<code>DOMStringMap</code>的实例</li><li><code>scrollIntoView()</code>方法：通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中</li></ul><h4 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h4><ul><li><code>innerHTML</code>属性：<ul><li>读模式下，<code>innerHTML</code>返回与所有子节点对应的HTML标记</li><li>写模式下，<code>innerHTML</code>的值会被解析成DOM子树，替换调用元素原来的所有子节点</li><li>可以使用<code>window.toStaticHTML()</code>处理HTML字符串，删除所有脚本节点和事件处理程序属性</li></ul></li><li><code>outerHTML</code>属性：返回调用它的元素及其所有子节点的HTML标签</li><li><code>insertAdjacentHTML()</code>：接受两个参数，插入位置和要插入的HTML文本，第一个参数必须是下列值之一：<ul><li><code>beforeBegin</code>：在当前元素之前插入一个紧邻的同辈元素</li><li><code>afterBegin</code>：在当前元素下插入一个新的子元素或在第一个子元素前插入新的元素</li><li><code>beforeEnd</code>：在当前元素下插入一个新的子元素或在最后一个子元素后再插入新元素</li><li><code>afterEnd</code>：在当前元素之后插入一个紧邻的同辈元素</li></ul></li><li>在使用上面的属性将元素从文档中删除时，元素与事件处理程序之间的绑定关系在内存中并没有一并删除，所以最好手动删除要被替换的元素的所有事件处理程序和JS对象属性</li></ul><h2 id="DOM2和DOM3"><a href="#DOM2和DOM3" class="headerlink" title="DOM2和DOM3"></a>DOM2和DOM3</h2><ul><li><code>importNode()</code>：从一个文档中取得一个节点，然后将其导入另一个文档（跟<code>Element</code>的<code>cloneNode()</code>相似）</li><li><code>isSameNode()</code>：两个节点引用的是同一个对象时返回true</li><li><code>isEqualNode()</code>：两个节点是相同的类型，具有相等的属性，且其<code>attributes</code>和<code>childNodes</code>属性也相等，就返回true</li></ul><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><h4 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h4><ul><li><p>偏移量：包括元素在屏幕上占用高度所有可见空间</p><ul><li><code>offsetHeight</code>：height+padding(top+bottom)+border(top+bottom)</li><li><code>offsetWidth</code>：width+padding(top+bottom)+border(top+bottom)</li><li><code>offsetTop</code>：top+marginTop，表示距离<code>offsetParent</code>的左间距</li><li><code>offsetLeft</code>：left+marginLeft</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//得到某个元素在页面上的偏移量，将该元素的offsetLeft和offsetTop与其offsetParent的相同属性想家，如此循环至根元素</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementLeft</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> actualLeft = element.offsetLeft;</div><div class="line">  <span class="keyword">var</span> current = element.offsetParent;</div><div class="line">  <span class="keyword">while</span>(current != <span class="literal">null</span>) &#123;</div><div class="line">    actualLeft += current.offsetLeft;</div><div class="line">    current = current.offsetElement;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> actualLeft;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>客户区大小（<code>clientWidth</code>，<code>clientHeight</code>）：指元素内容及其内边距所占据的空间大小，通常用于确定浏览器视口大小（<code>document.body.clientWidth</code> || <code>document.documentElementWidth</code>）</p></li><li><p>滚动大小：包含滚动内容的元素的大小</p><ul><li><p><code>scrollHeight</code>：在没有滚动条的情况下，元素内容的总高度</p></li><li><p><code>scrollWidth</code>：在没有滚动条的情况下，元素内容的总宽度</p><p>[<code>scrollHeight</code>和<code>scrollWidth</code>主要用于确定元素内容的实际大小]</p></li></ul></li></ul><ul><li><p><code>scrollLeft</code>：被隐藏在内容区域左侧的像素数</p></li><li><p><code>scrollTop</code>：被隐藏在内容区域上方的像素数</p><p>[元素未被滚动时，<code>scrollLeft</code>和<code>scrollTop</code>的值为0，将这两个值设为0可以重置元素的滚动位置]</p></li></ul><ul><li><code>getBoundingClientRect()</code>：返回一个矩形对象，包含<code>left</code>、<code>top</code>、<code>right</code>和<code>bottom</code>四个属性，给出了元素在页面中相对于视口的位置</li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>DOM2级遍历和范围模块定义了两个类型用于辅助进行DOM结构的遍历：<code>NodeIterator</code>、<code>TreeWalker</code>，这两个类型都是基于给定的起点对DOM结构进行深度优先的遍历操作。</p><h4 id="NodeIterator"><a href="#NodeIterator" class="headerlink" title="NodeIterator"></a>NodeIterator</h4><ul><li>可以使用<code>document.createNodeIterator()</code>创建<code>NodeIterator</code>实例，该方法接收四个参数：<ul><li><code>root</code>：搜索起点节点</li><li><code>whatToShow</code>：表示要访问哪些节点的数字节点</li><li><code>filter</code>：一个<code>NodeFilter</code>对象，或一个表示应该接收还是拒绝某种特定节点的函数</li><li><code>entityReferenceExpansion</code>：表示是否要扩展实体引用</li></ul></li><li><code>nextNode()</code>：在深度优先的DOM子树遍历中，用于向前前进一步，第一次调用会返回根节点</li><li><code>previousNode()</code>：用户向后后退一步</li></ul><h4 id="TreeWalker"><a href="#TreeWalker" class="headerlink" title="TreeWalker"></a>TreeWalker</h4><ul><li><code>TreeWalker</code>是<code>NodeIterator</code>的一个更高级的版本，除了<code>nextNode</code>和<code>previousNode</code>以外，还有几个其他方法：<ul><li><code>parentNode()</code>：遍历到当前节点的父节点</li><li><code>firstChild()</code>：遍历到当前节点的第一个子节点</li><li><code>lastChild()</code>：遍历到当前节点的最后一个子节点</li><li><code>nextSibling()</code>：遍历到当前节点的下一个同辈节点</li><li><code>previousSibling()</code>：遍历到当前节点的上一个同辈节点</li></ul></li><li>使用<code>document.createTreeWalker()</code>创建<code>TreeWalker</code>实例</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;《JavaScript高级程序设计》DOM相关知识点复习。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://hu33.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
      <category term="DOM" scheme="http://hu33.tech/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>来自M小姐的毒药</title>
    <link href="http://hu33.tech/2017/08/02/%E6%9D%A5%E8%87%AAM%E5%B0%8F%E5%A7%90%E7%9A%84%E6%AF%92%E8%8D%AF/"/>
    <id>http://hu33.tech/2017/08/02/来自M小姐的毒药/</id>
    <published>2017-08-02T15:35:16.084Z</published>
    <updated>2019-01-10T14:17:28.739Z</updated>
    
    <content type="html"><![CDATA[<p>M小姐是我上研究生认识的，是我的硕士同班同学兼实验室伙伴兼项目战友兼寝室室友兼实习同事兼实习室友兼我的亲人。</p><p>在见到她之前，听另一个室友说，她比我还瘦。我感到无比惊讶，比那时候的我还瘦得瘦成什么样。</p><p>第一眼见到她时，是在二舍寝室，她面向着门背对着窗，明明无比逆光，我却清楚地看到了她脸上洋溢的微笑，热情而亲切。而逆光下的她的身形一览无遗，当时我就在想，真是个小巧玲珑的妹子。</p><a id="more"></a><p><strong>M小姐是个特别善良的妹子。</strong></p><p>某个周六我们赖在寝室不想出门吃饭，M回来后看到我们一副懒虫样，提出可以帮我们带饭。我们也不是那么无理的人啊，怎么好意思让人家专门跑一趟给带饭呢，就拒绝了。结果M小姐特别执着地说，没关系的，我刚好想出去走走，就顺便帮你们带吧，不然你们下午会饿的，硬生生地说服了我们接受了她的帮助。回来时可开心了，还怕我们过意不去一个劲儿地给我们洗脑说是她自己想出去走走的，当时我就在想，真是个善良可爱的妹子。</p><p>知乎上有句话我特别同意，一个人最大的善良就是在别人休息时轻手关门轻声讲话。我曾经觉得我就属于这类人，但是认识了M小姐后，我才发现M小姐才是高手啊。在学校时，M小姐早上都醒得很早，还没7点就醒了，而我们寝室的水龙头声音特别大，开关门的声音也特别大，M小姐怕这么早会影响我们休息，就在床上躺到7点半才起床。实际上，M小姐啥时候起床啥时候走的我们也不知道，因为她动作特别轻。M小姐没有准备台灯，但是早上起来既不开灯也不拉开点窗帘，每早都是举着手机收拾完自己。有次无意间发现，M小姐为了不让光透进寝室照醒我们，她竟然是从窗帘缝里钻出寝室去的阳台，这个妹子，实在是太为人着想了。</p><p><strong>M小姐是个特别细心的妹子。</strong></p><p>我是出了名的健忘，自从跟M小姐混在一起后，我就更健忘了。因为细心的M小姐什么都会帮我记住，什么时候要去哪里，出门要带什么东西，去超市要买什么，欠了谁的钱谁欠了我的钱都给我记着了。M小姐有时候在认真看电视，突然来一句，你上次说的那件事办了吗？我：……额，差点忘了……有了细心的M小姐，我根本没理由逼自己记住这一切啊。</p><p>以前出去玩手机电量一定不能低于90%，因为要查路线查导航，但是跟M小姐出去手机关机都不怕～毕竟M小姐是我公认的活地图，去过一次的地方就记住地点了，走过一遍的路就记住路线了。所以跟M小姐出门，只管带上自己就好了。</p><p><strong>M小姐是个特别认真的妹子。</strong></p><p>309实验室是个特别不正经的场所，但是里面出了个特别认真的M小姐。起初这对M小姐可不是什么好事，认真的M小姐在我们这群老司机段子手中间总是略显格格不入。可这也不是什么坏事，正经的M小姐不知不觉中就被带偏了，现在是个开车稳段子冷的正经妹子了。不过尽管那群老司机们带偏了M小姐，M小姐仍然是个非常认真的人。有句话怎么说的来着，狗改不了吃屎？（原谅我没文化……）</p><p>不管你跟M小姐讲什么，她都会非常认真地帮你分析。虽然你的有些观点她未必赞同，但她会认真地站在你的角度去理解，然后一本正经地告诉你应该怎样，不敷衍。</p><p><strong>M小姐是个特别有活力的妹子。</strong></p><p>在跟M小姐同居之前，我们一直都觉得M小姐是个永动机，从来都不知累为何物。每次我们出去浪，临近回来时我就开始叫累不迭，连回去的力气都没了。可是M小姐还是精力不减，还能又蹦又跳，继续奋战。但是有一点M小姐比不上我，那就是…吃！M小姐有时候很想多尝试些美食，无奈胃容量有限，只能安慰自己下次再来了。</p><p><strong>M小姐给我下毒了。</strong></p><p>上面夸了M小姐那么多，那都是可忽略的，接下来这点才重要，她对我下毒这件事才重要。</p><p>曾经，我生活独立精神独立，可以一个人背着书包去自习室，一个人带着饭卡去食堂，一个人拿着球拍去球馆，一个人拉着行李去实习，不需要朋友的关心不需要倾诉的对象不需要所谓的精神寄托，很会掩饰自己的感情不轻易表现自己的情绪。用高中闺蜜们的话来说，就是太坚强，让人有距离感。</p><p>可是M小姐竟然给我下了慢性毒药。我有什么决定会愿意告诉M小姐，M小姐会先帮我分析一波然后表示支持我的决定；我有什么开心的事情会乐于跟M小姐分享，M小姐会特别开心地为我的开心而开心；我有什么难过伤感的情绪会在M小姐面前流露，M小姐都会想办法帮我排解忧愁；更可怕的是，有些事情我以为可以藏在心里一辈子，但会不经意间跟M小姐说起。想到这，真是觉得可怕，M小姐都知道我所有的秘密了。</p><p>在学校的时候，我们都亲切地称M小姐为“天使”，但是这个天使都快把我毒害成孩子了，那个坚强独立的人设已经被毒没了。毕竟，健忘的时候有人帮你记着事情，出门的时候有人帮你导航路线，犯懒的时候有人帮你做好早餐，难过的时候有人切好水果放你面前，开心有人跟你分享，伤心有人陪你聊天，委屈有人替你心疼。还要啥坚强！要啥独立！</p><p>我在想啊，要是我以后找不到男朋友，M小姐是要背一半锅的。</p><p><strong>这才是重点。</strong></p><p>恩，上面其实都不是重点，重点是，这么好这么优秀的一个妹子，是单身哦~现附上背影一张~</p><p><img src="https://hu33.github.io/images/来自M小姐的毒药/1.jpg" alt=""></p><p>心动不如行动，汉子们，燥起来吧^O^ </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;M小姐是我上研究生认识的，是我的硕士同班同学兼实验室伙伴兼项目战友兼寝室室友兼实习同事兼实习室友兼我的亲人。&lt;/p&gt;
&lt;p&gt;在见到她之前，听另一个室友说，她比我还瘦。我感到无比惊讶，比那时候的我还瘦得瘦成什么样。&lt;/p&gt;
&lt;p&gt;第一眼见到她时，是在二舍寝室，她面向着门背对着窗，明明无比逆光，我却清楚地看到了她脸上洋溢的微笑，热情而亲切。而逆光下的她的身形一览无遗，当时我就在想，真是个小巧玲珑的妹子。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://hu33.tech/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="人物" scheme="http://hu33.tech/tags/%E4%BA%BA%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>React相关面试题</title>
    <link href="http://hu33.tech/2017/07/31/React%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://hu33.tech/2017/07/31/React相关面试题/</id>
    <published>2017-07-31T14:32:07.756Z</published>
    <updated>2019-01-10T14:00:09.317Z</updated>
    
    <content type="html"><![CDATA[<ol><li>React解决了什么问题</li><li>如何设计一个好的组件</li><li>组件的render函数在何时被调用</li><li>调用render时DOM就一定会被更新吗</li><li>组件的生命周期</li><li>进行远程数据加载时，应该在哪个周期中完成</li><li>在哪些生命周期中可以修改组件的state</li><li>不同父节点的组件需要对彼此的状态进行改变时应该怎么实现</li><li>state里应该有什么</li><li>如何对组件进行优化</li><li>组件中的key属性有什么用</li><li>Component与Element和Instance的区别</li><li>调用setState时，发生了什么事</li><li>什么时候使用类组件（Class Component）而非功能组件（Functional Component）</li><li>什么是React的refs，为什么它们很重要</li><li>受控组件（controlled component）和不受控组件（uncontrolled component）有什么区别</li><li>描述事件在React中的处理方式</li></ol><a id="more"></a><h3 id="React解决了什么问题？"><a href="#React解决了什么问题？" class="headerlink" title="React解决了什么问题？"></a>React解决了什么问题？</h3><p><strong>a. React实现了Virtual DOM</strong></p><p>在一定程度上提升了性能，尤其是在进行小量数据更新时。因为DOM操作是很耗性能的，而Virtual DOM是在内存中进行操作的，当数据发生变化时，通过diff算法比较两棵树之间的变化，再进行必要的DOM更新，省去了不必要的高消耗的DOM操作。当然，这种性能优化主要体现在有小量数据更新的情况下。因为React的基本思维模式是每次有变动就重新渲染整个应用，简单想来就是直接重置innerHTML，比如说在一个大型列表所有数据都变动的情况下，重置innerHTML还比较合理，但若是只有一行数据变了，它也需要重置整个innerHTML，就会造成大量的浪费。而Virtual DOM虽然进行了JS层面的计算，但是比起DOM操作来说，简直不要太便宜。</p><blockquote><p><a href="https://www.zhihu.com/question/31809713" target="_blank" rel="external">为什么操作真实DOM比React更快？</a></p></blockquote><p><strong>b. React的一个核心思想是声明式编程。</strong></p><p>命令式编程是解决做什么的问题，就像是下命令一样，关注于怎么做，而声明式编程关注于得到什么结果，在React中，我们只需要关注“目前的状态是什么”，而不是“我需要做什么让页面变成目前的状态”。React就是不断声明，然后在特定的参数下渲染UI界面。这种编程方式可以让我们的代码更容易被理解，从而易于维护。</p><p><strong>c. 组件化</strong></p><p>React天生组件化，我们可以将一个大的应用分割成很多小组件，这样有好几个优势。首先组件化的代码像一棵树一样清楚干净，比起传统的面条式代码可读性更高；其次前端人员在开发过程中可以并行开发组件而不影响，大大提高了开发效率；最重要的是，组件化使得复用性大大提高，团队可以沉淀一些公共组件或工具库。</p><p><strong>d. 单向数据流</strong></p><p>在React中数据流是单向的，由父节点流向子节点，如果父节点的props发生了变化，那么React会递归遍历整个组件树，重新渲染所有使用该属性的子组件。这种单向的数据流一方面比较清晰不容易混乱，另一方面是比较好维护，出了问题也比较好定位。</p><h3 id="如何设计一个好组件"><a href="#如何设计一个好组件" class="headerlink" title="如何设计一个好组件"></a>如何设计一个好组件</h3><p>组件的主要目的是为了更好的复用，所以在设计组件的时候需要遵循高内聚低耦合的原则。</p><ul><li>可以通过遵循几种设计模式原则来达到高复用的目的，比如单一职责原则：React推崇的是“组合”而非“继承”，所以在设计时尽量不设计大的组件，而是开发若干个单一功能的组件，重点就是每个组件只做一件事；开放/封闭原则，就是常说的对修改封闭，对扩展开放。在React中我们可以用高阶组件来实现。</li><li>使用高阶组件来实现组件的复用。高阶组件就是一个包装了另一个React组件的React组件，它包括属性代理（高阶组件操控着传递给被包裹组件的属性）和反向继承（实际上高阶组件继承被包裹组件）。我们可以用高阶组件实现代码复用，逻辑抽象。</li><li>使用容器组件来处理逻辑，展示组件来展示数据（也就是逻辑处理与数据展示分离）。比如可以在容器组件中进行数据的请求与处理，然后将处理后的数据传递给展示组件，展示组件只负责展示，这样容器组件和展示组件就可以更好地复用了。</li><li>编写组件代码时要符合规范，总之就是要可读性强、复用性高、可维护性好。</li></ul><h3 id="组件的render函数何时被调用"><a href="#组件的render函数何时被调用" class="headerlink" title="组件的render函数何时被调用"></a>组件的render函数何时被调用</h3><ul><li>组件state发生改变时会调用render函数，比如通过setState函数改变组件自身的state值</li><li>继承的props属性发生改变时也会调用render函数，即使改变的前后值一样</li><li>React生命周期中有个componentShouldUpdate函数，默认返回true，即允许render被调用，我们也可以重写这个函数，判断是否应该调用render函数</li></ul><h3 id="调用render时DOM就一定会被更新吗"><a href="#调用render时DOM就一定会被更新吗" class="headerlink" title="调用render时DOM就一定会被更新吗"></a>调用render时DOM就一定会被更新吗</h3><p>不一定更新。</p><p>React组件中存在两类DOM，render函数被调用后， React会根据props或者state重新创建一棵virtual DOM树，虽然每一次调用都重新创建，但因为创建是发生在内存中，所以很快不影响性能。而 virtual dom的更新并不意味着真实DOM的更新，React采用diff算法将virtual DOM和真实DOM进行比较，找出需要更新的最小的部分，这时Real DOM才可能发生修改。</p><p>所以每次state的更改都会使得render函数被调用，但是页面DOM不一定发生修改。</p><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><p>组件生命周期有三种阶段：初始化阶段（Mounting）、更新阶段（Updating）、析构阶段（Unmouting）。</p><p><strong>初始化阶段：</strong></p><ul><li>constructor()：初始化state、绑定事件</li><li>componentWillMount()：在render()之前执行，除了同构，跟constructor没啥差别</li><li>render()：用于渲染DOM。如果有操作DOM或和浏览器打交道的操作，最好在下一个步骤执行。</li><li>componentDidMount()：在render()之后立即执行，可以在这个函数中对DOM就进行操作，可以加载服务器数据，可以使用setState()方法触发重新渲染</li></ul><p><strong>组件更新阶段：</strong></p><ul><li>componentWillReceiveProps(nextProps)：在已挂载的组件接收到新props时触发，传进来的props没有变化也可能触发该函数，若需要实现props变化才执行操作的话需要自己手动判断</li><li>componentShouldUpdate(nextProps，nextState)：默认返回true，我们可以手动判断需不需要触发render，若返回false，就不触发下一步骤</li><li>componentWillUpdate()：componentShouldUpdate返回true时触发，在render之前，可以在里面进行操作DOM</li><li>render()：重渲染</li><li>componentDidUpdate()：render之后立即触发</li></ul><p>组件卸载阶段：</p><ul><li>componentWillUnmount()：在组件销毁之前触发，可以处理一些清理操作，如无效的timers等</li><li>componentDidMount()：卸载后立即触发</li></ul><h3 id="进行远程数据加载时，应该在哪个周期中完成"><a href="#进行远程数据加载时，应该在哪个周期中完成" class="headerlink" title="进行远程数据加载时，应该在哪个周期中完成"></a>进行远程数据加载时，应该在哪个周期中完成</h3><ul><li><p>最好是在<code>componentDidMount</code>中进行异步请求。如果我们将ajax请求放在生命周期其他函数中，如<code>constructor</code>或<code>componentWIllMount</code>中，我们并不能保证请求仅在组件挂载完毕后才响应。如果我们的数据请求在组件挂载前就完成，并调用<code>setState</code>函数将数据添加到组件状态中，对于未挂载的组件会报错。而在<code>componentDidMount</code>中进行ajax请求能有效避免这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component.</div></pre></td></tr></table></figure></li><li><p>React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 <code>componentWillMount</code> 的触发次数。对于 <code>componentWillMount</code> 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 <code>componentWillMount</code>。如果我们将 AJAX 请求放到 <code>componentWillMount</code> 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。[没深入]</p></li></ul><p>顺便说说<code>componentWillMount</code>函数，这个方法是在<code>render</code>前立刻执行的，也是服务器渲染中唯一调用的钩子，其实除了同构的需求，通常情况下可以用<code>constructor()</code>方法代替。</p><h3 id="在哪些生命周期中可以修改组件的state"><a href="#在哪些生命周期中可以修改组件的state" class="headerlink" title="在哪些生命周期中可以修改组件的state"></a>在哪些生命周期中可以修改组件的state</h3><ul><li>componentDidMount和componentDidUpdate</li><li>constructor、componentWillMount中setState会发生错误：setState只能在mounted或mounting组件中执行</li><li>componentWillUpdate中setState会导致死循环</li></ul><h3 id="不同父节点的组件需要对彼此的状态进行改变时应该怎么实现"><a href="#不同父节点的组件需要对彼此的状态进行改变时应该怎么实现" class="headerlink" title="不同父节点的组件需要对彼此的状态进行改变时应该怎么实现"></a>不同父节点的组件需要对彼此的状态进行改变时应该怎么实现</h3><ul><li>在没有Flux之前，Facebook推荐使用事件机制，但是一旦应用中这种需求增多，事件和回调会满天飞</li><li>传递接口，就是需要root传递两个接口给A和B，当A想改变B的状态时，A调用root传递给它的接口，然后这个接口再调用root传给B的接口（这个方法也很不科学）</li><li>用Flux管理状态</li></ul><h3 id="state里应该有什么"><a href="#state里应该有什么" class="headerlink" title="state里应该有什么"></a>state里应该有什么</h3><p>应该有啥：</p><ul><li>事件函数可能进行修改的会导致UI进行渲染的数据</li></ul><p>不应该有啥：</p><ul><li>计算得出的值</li><li>React组件</li><li>props复制来的数据</li></ul><h3 id="如何对组件进行优化"><a href="#如何对组件进行优化" class="headerlink" title="如何对组件进行优化"></a>如何对组件进行优化</h3><ul><li>使用上线构建（Production Build）：会移除脚本中不必要的报错和警告，减少文件体积</li><li>避免重绘：重写shouldComponentUpdate函数，手动控制是否应该调用render函数进行重绘</li><li>尽可能使用Immutable Data：尽可能不修改数据，而是重新赋值数据。这样在检测数据对象是否发生修改方面会非常快，因为只需要检测对象引用即可，不需要挨个检测对象属性的更改</li><li>在渲染组件时尽可能添加key，这样virtual DOM在对比的时候就更容易知道哪里是修改元素，哪里是新插入的元素</li></ul><h3 id="组件中的key属性有什么用"><a href="#组件中的key属性有什么用" class="headerlink" title="组件中的key属性有什么用"></a>组件中的key属性有什么用</h3><p>React中的key是一个特殊的属性，它的出现不是给开发者用的，而是给React自己用的（给一个组件设置了key属性，并不能获取这个组件的key props）</p><p>React使用key来识别组件，它是一种身份标识，每一个key对应一个组件，react认为相同的key是同一个组件，这样后续相同的key就不会被创建</p><p>有了key属性后，就可以与组件建立一种对应关系，react根据key来决定是销毁重新创建组件还是更新组件：</p><ul><li>key相同：若组件属性有变化，react只更新对应的属性；没有变化则不更新</li><li>key值不同：react会先销毁该组件，然后重新创建该组件</li></ul><h3 id="Component与Element和Instance的区别"><a href="#Component与Element和Instance的区别" class="headerlink" title="Component与Element和Instance的区别"></a>Component与Element和Instance的区别</h3><ul><li>Element其实是一个纯粹的Object对象，用于描述在屏幕上看到的DOM节点，这个对象包括type、props、key和ref属性，但不包括DOM方法（React.createElement()）</li><li>Component是组件级别的类：接收参数并返回React元素的函数或类</li><li>Instance：当使用ReactDOM.render()将一个组件渲染到一个具体的DOM元素中，返回的值就为一个实例</li></ul><h3 id="调用setState时，发生了什么事"><a href="#调用setState时，发生了什么事" class="headerlink" title="调用setState时，发生了什么事"></a>调用setState时，发生了什么事</h3><p>调用setState时，react会做的第一件事就是将传递给setState的对象合并到组件的当前状态，然后会触发调和过程。经过调和过程，React会以相对高效的方式根据新的状态构建React元素树，并准备重新渲染整个UI界面。在React得到元素树后，React会通过diff算法算出新的树与老树之间的节点差异，然后根据差异对界面进行最小化重渲染。在diff算法中，React能够相对精确地算出哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p><h3 id="什么时候使用类组件（Class-Component）而非功能组件（Functional-Component）"><a href="#什么时候使用类组件（Class-Component）而非功能组件（Functional-Component）" class="headerlink" title="什么时候使用类组件（Class Component）而非功能组件（Functional Component）"></a>什么时候使用类组件（Class Component）而非功能组件（Functional Component）</h3><p>若组件需要有state或需要使用生命周期，就用类组件，否则就用功能组件</p><h3 id="什么是React的refs，为什么它们很重要"><a href="#什么是React的refs，为什么它们很重要" class="headerlink" title="什么是React的refs，为什么它们很重要"></a>什么是React的refs，为什么它们很重要</h3><p>我们用render方法得到了组价的实例，然后就可以对它进行相关操作，但是在组件内，JSX是不会返回一个组件的实例，它只是一个ReactElement，只是告诉React被挂载的组件应该是长什么样。</p><p>refs是组件的一个很特殊的prop，可以附加到任何一个组件上，refs就是reference，组件被调用时会新建一个该组件的实例，refs就会指向这个实例</p><p>我们把refs放到原生的DOM组件input中，就可以通过refs得到DOM结点；如果把refs放到React组件中，就可以获得组件的实例，可以调用该组件的实例方法</p><h3 id="受控组件（controlled-component）和不受控组件（uncontrolled-component）有什么区别"><a href="#受控组件（controlled-component）和不受控组件（uncontrolled-component）有什么区别" class="headerlink" title="受控组件（controlled component）和不受控组件（uncontrolled component）有什么区别"></a>受控组件（controlled component）和不受控组件（uncontrolled component）有什么区别</h3><p>受控组件：在HTML中，标签\<input>、\<select>等值的改变通常是根据用户输入进行更新，在React中，可变状态通常保存在组件的状态属性中，并且只能用setState()更新，而呈现表单的React组件也控制着在后续用户输入时该表单发生的情况，以这种由React控制输入表单元素而改变其值的方式，就称为“受控组件”</select></p><p>不受控组件：表单数据不受setState控制，而是由DOM本身处理，与传统HTML表单输入相似，input输入值即显示最新值（使用ref从DOM获取表单值）</p><h3 id="描述事件在React中的处理方式"><a href="#描述事件在React中的处理方式" class="headerlink" title="描述事件在React中的处理方式"></a>描述事件在React中的处理方式</h3><p>React在virtual DOM的基础上实现了一个SyntheticEvent（合成事件）层，所有事件都绑定到最外层上。</p><p>在React底层，主要对合成事件做了两件事：事件委托和自动绑定。</p><p>事件委托：React的事件代理机制不会把事件处理函数直接绑定到真实的结点上，而是把所有事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。</p><p>自动绑定：在React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。在使用ES6 classes和纯函数时，这种自动绑定就不存在了，需要我们手动绑定this：bind方法、双冒号语法、构造器内声明、箭头函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;React解决了什么问题&lt;/li&gt;
&lt;li&gt;如何设计一个好的组件&lt;/li&gt;
&lt;li&gt;组件的render函数在何时被调用&lt;/li&gt;
&lt;li&gt;调用render时DOM就一定会被更新吗&lt;/li&gt;
&lt;li&gt;组件的生命周期&lt;/li&gt;
&lt;li&gt;进行远程数据加载时，应该在哪个周期中完成&lt;/li&gt;
&lt;li&gt;在哪些生命周期中可以修改组件的state&lt;/li&gt;
&lt;li&gt;不同父节点的组件需要对彼此的状态进行改变时应该怎么实现&lt;/li&gt;
&lt;li&gt;state里应该有什么&lt;/li&gt;
&lt;li&gt;如何对组件进行优化&lt;/li&gt;
&lt;li&gt;组件中的key属性有什么用&lt;/li&gt;
&lt;li&gt;Component与Element和Instance的区别&lt;/li&gt;
&lt;li&gt;调用setState时，发生了什么事&lt;/li&gt;
&lt;li&gt;什么时候使用类组件（Class Component）而非功能组件（Functional Component）&lt;/li&gt;
&lt;li&gt;什么是React的refs，为什么它们很重要&lt;/li&gt;
&lt;li&gt;受控组件（controlled component）和不受控组件（uncontrolled component）有什么区别&lt;/li&gt;
&lt;li&gt;描述事件在React中的处理方式&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://hu33.tech/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://hu33.tech/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>美团实习生面试(一面)</title>
    <link href="http://hu33.tech/2017/07/29/%E7%BE%8E%E5%9B%A2%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95/"/>
    <id>http://hu33.tech/2017/07/29/美团实习生面试/</id>
    <published>2017-07-29T00:39:14.516Z</published>
    <updated>2019-01-10T14:13:02.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ol><li><p>平常用JS做什么</p></li><li><p>平常写项目用ES6吗，用什么比较多</p></li><li><p>箭头函数和普通函数有什么区别</p><a id="more"></a></li><li><p>用原生JS写一个删除元素的函数</p></li><li><p>浅克隆和深克隆，用原生JS写一个clone函数</p></li><li><p>动态添加和删除一条消息要怎么用JS实现</p></li><li><p>cookie是什么，怎么设cookie，前端可以修改cookie吗，cookie的安全性</p></li><li><p>localStorage和sessionStorage</p></li></ol><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ol><li>你用过的display属性值，讲讲block，inline，inline-block的差别</li><li>讲讲几种position属性值</li><li>什么选择器用得比较多</li><li>用CSS写过什么有趣或炫酷的东西</li></ol><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ol><li>网络7层协议，数据是怎么传输的</li><li>http协议是哪一层的</li><li>http协议有哪些header</li><li>http请求方法，get和post的使用场景，post和put的本质区别</li><li>http返回码，什么时候返回200，什么时候返回500，201表示什么</li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ol><li>React生命周期</li><li>在哪几个生命周期里可以使用setState</li><li>有没有function的方式写过组件</li><li>异步请求一般在哪个生命周期</li><li>谈一下你怎么理解render的触发</li><li>refs用来干什么</li><li>react如何实现事件委托</li><li>redux的流程</li><li>用过哪些redux中间件，中间件实现原理，有没有自己写过中间件</li><li>用redux时遇到过什么坑</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>为什么要用mongodb</li><li>MySQL有办法存json数据吗</li></ol><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 有一个数组arr代表外卖的价格，比如[1, 2, 2.5, 30, 25]，用户现在有购物车已经买了N元了，需要凑到&gt;=M元，求给出一个最佳凑单组合</span></div><div class="line"></div><div class="line"><span class="comment">// [1,2,3] 20 25 [2,3] [1, 1, 1, 1, 1] [1,1,3]</span></div><div class="line"><span class="comment">// [1,2,3]  19.5 20 [1]</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">itemPrice, N, M</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> items = [];</div><div class="line">  ...</div><div class="line">  return items;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JS&quot;&gt;&lt;a href=&quot;#JS&quot; class=&quot;headerlink&quot; title=&quot;JS&quot;&gt;&lt;/a&gt;JS&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;平常用JS做什么&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;平常写项目用ES6吗，用什么比较多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;箭头函数和普通函数有什么区别&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面经" scheme="http://hu33.tech/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Express+MongoDB搭建多人博客系统</title>
    <link href="http://hu33.tech/2017/07/25/Express+MongoDB%E6%90%AD%E5%BB%BA%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
    <id>http://hu33.tech/2017/07/25/Express+MongoDB搭建多人博客系统/</id>
    <published>2017-07-25T14:04:11.377Z</published>
    <updated>2019-01-13T08:25:45.797Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/hu33/myblog" target="_blank" rel="external">项目地址</a>  目前还是bug多多~</p><p>本项目完全<a href="https://github.com/nswbmw/N-blog" target="_blank" rel="external">该教程</a>，教程很详细很入门很通俗，本文是纯为面试准备的啦。</p><a id="more"></a><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>Node.js: 6.11.0</li><li>Express: 4.15.3</li><li>MongoDB: 3.4</li></ul><h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>Express的基本使用方法可以查看其<a href="http://www.expressjs.com.cn/guide/routing.html" target="_blank" rel="external">使用指南</a>。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>本项目使用的是<code>express.Router</code>。</p><p>创建一个<code>routes</code>的文件夹，将路由控制都写在该文件夹内，每个路由文件通过生成一个<code>express.Router</code>实例<code>router</code>并导出，通过<code>app.use</code>挂载到不同的路径。</p><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>本项目模板引擎使用的是ejs。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置模板目录</span></div><div class="line">app.set(<span class="string">'views'</span>, path.join(__dirname, <span class="string">'views'</span>));</div><div class="line"><span class="comment">//设置模板引擎为ejs</span></div><div class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>);</div></pre></td></tr></table></figure><p>通过调用<code>res.render()</code>渲染<code>ejs</code>模板，第一个参数是模板的名字，第二个参数传给模板的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">res.render(<span class="string">'error'</span>,&#123;</div><div class="line">   <span class="attr">error</span>: err</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><code>res.render()</code>的作用就是将模板和数据结合成HTML，同时响应头中的<code>Content-Type：text/html</code>，告诉浏览器返回的是HTML，不是文本，要按HTML展示。</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul><li><p><strong>express-session：实现对会话的支持</strong></p><p>由于HTTP协议是无状态协议，所以服务器需要记录用户的状态时，需要用某种机制来识别具体的用户，这个机制就是会话（<code>session</code>）。</p><p>本项目中<code>session</code>配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">app.use(session(&#123;</div><div class="line">    <span class="attr">name</span>: config.session.key, <span class="comment">//设置cookie中保存session id的字段名称</span></div><div class="line">    secret: config.session.secret,</div><div class="line">    <span class="attr">resave</span>: <span class="literal">true</span>, <span class="comment">//强制更新session</span></div><div class="line">    saveUninitialized: <span class="literal">false</span>, <span class="comment">//设置为false，强制创建一个session，即使用户未登录</span></div><div class="line">    cookie: &#123;</div><div class="line">        <span class="attr">maxAge</span>: config.session.maxAge</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">store</span>: <span class="keyword">new</span> MongoStore(&#123;</div><div class="line">        <span class="attr">url</span>: config.mongodb</div><div class="line">    &#125;)</div><div class="line">&#125;));</div></pre></td></tr></table></figure><p><code>session</code>中间件会在<code>req</code>上设置<code>session</code>对象，及<code>req.session={}</code>，当用户登录后设置<code>req.session.user=用户信息</code>，返回浏览器的头信息中会带上<code>set-cookie</code>，将<code>session id</code>写到浏览器<code>cookie</code>中，所以用户下次请求时，通过带上来的<code>cookie</code>中的<code>session id</code>就能查找到该用户，并将用户信息保存早<code>req.session.user</code>。</p><p>session资料：</p><ol><li><a href="http://justsee.iteye.com/blog/1570652" target="_blank" rel="external">http://justsee.iteye.com/blog/1570652</a></li><li><a href="https://www.zhihu.com/question/19786827" target="_blank" rel="external">https://www.zhihu.com/question/19786827</a></li></ol></li><li><p><strong>connect-mongo：将session存入到mongodb中</strong></p><p>作用就是将<code>connect</code>的<code>session</code>持久化到mongodb中，配置见上面的<code>session</code>配置。</p></li><li><p><strong>connect-flash：通知功能</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.use(flash());</div></pre></td></tr></table></figure><p>原理：设置初始值<code>req.session.flash={}</code>，通过<code>req.flash(name, value)</code>设置<code>flash</code>字段和值，通过<code>req.flash(name)</code>获取该对象下的值，同时删除该字段。</p></li><li><p><strong>express-formidable：处理表单及文件上传</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="built_in">require</span>(<span class="string">'express-formidable'</span>)(&#123;</div><div class="line">    <span class="attr">uploadDir</span>: path.join(__dirname, <span class="string">'public/img'</span>),  <span class="comment">//上传文件目录</span></div><div class="line">    keepExtensions: <span class="literal">true</span> <span class="comment">//保留后缀</span></div><div class="line">&#125;));</div></pre></td></tr></table></figure><p>获取文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> avatar = req.files.avatar.path.split(path.sep).pop();</div></pre></td></tr></table></figure></li><li><p><strong>config-lite：读取配置文件</strong></p><p><code>config-lite</code>会根据环境变量（<code>NODE_ENV</code>）的不同从当前执行进程目录下的config目录加载不同的配置文件。如果不设置<code>NODE_ENV</code>，则读取默认的default配置文件，若指定了<code>NODE_ENV</code>，则会合并指定的配置文件和default配置文件作为配置。<code>config-lite</code>支持<code>.js</code>、<code>.json</code>、<code>.node</code>、<code>.yml</code>、<code>.yaml</code>后缀的文件。</p><p>如果程序以 <code>NODE_ENV=test node app</code> 启动，则 <code>config-lite</code> 会依次降级查找 <code>config/test.js</code>、<code>config/test.json</code>、<code>config/test.node</code>、<code>config/test.yml</code>、<code>config/test.yaml</code> 并合并 default 配置; 如果程序以 <code>NODE_ENV=production node app</code> 启动，则 <code>config-lite</code> 会依次降级查找 <code>config/production.js</code>、<code>config/production.json</code>、<code>config/production.node</code>、<code>config/production.yml</code>、<code>config/production.yaml</code> 并合并 default 配置。</p></li><li><p><strong>winston和express-winston</strong>：记录日志</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//正常请求的日志</span></div><div class="line">app.use(expressWinston.logger(&#123;</div><div class="line">    <span class="attr">transports</span>: [</div><div class="line">        <span class="keyword">new</span> (winston.transports.Console)(&#123;</div><div class="line">            <span class="attr">json</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">colorize</span>: <span class="literal">true</span></div><div class="line">        &#125;),</div><div class="line">        <span class="keyword">new</span> winston.transports.File(&#123;</div><div class="line">            <span class="attr">filename</span>: <span class="string">'logs/success.log'</span></div><div class="line">        &#125;)</div><div class="line">    ]</div><div class="line">&#125;));</div><div class="line"><span class="comment">//路由</span></div><div class="line">routes(app);</div><div class="line"><span class="comment">//错误请求的日志</span></div><div class="line">app.use(expressWinston.errorLogger(&#123;</div><div class="line">    <span class="attr">transports</span>: [</div><div class="line">        <span class="keyword">new</span> winston.transports.Console(&#123;</div><div class="line">            <span class="attr">json</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">colorize</span>: <span class="literal">true</span></div><div class="line">        &#125;),</div><div class="line">        <span class="keyword">new</span> winston.transports.File(&#123;</div><div class="line">            <span class="attr">filename</span>: <span class="string">'logs/error.log'</span></div><div class="line">        &#125;)</div><div class="line">    ]</div><div class="line">&#125;));</div></pre></td></tr></table></figure><p>将正常请求的日志打印到终端并写入<code>logs/success.log</code>，将错误请求的日志打印到终端并写入<code>logs/error.log</code>。</p><p>注：记录正常请求日志的中间件要放到<code>routes(app)</code>之前，记录错误请求日志的中间件要放到<code>routes(app)</code>之后</p></li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>目前只实现了最最基本的功能，即登录注册登出、查看文章发表文章修改文章删除文章、创建留言删除留言。以及会话、消息通知、权限控制。会话及消息通知用的第三方中间件，权限控制为自定义中间件。</p><p>权限控制（主要是验证用户是否登录）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">checkLogin</span>: <span class="function"><span class="keyword">function</span> <span class="title">checkLogin</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!req.session.user)&#123;</div><div class="line">            req.flash(<span class="string">'error'</span>,<span class="string">'未登录'</span>);</div><div class="line">            <span class="keyword">return</span> res.redirect(<span class="string">'/signin'</span>);</div><div class="line">        &#125;</div><div class="line">        next();</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">checkNotLogin</span>: <span class="function"><span class="keyword">function</span> <span class="title">checkNotLogin</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(req.session.user)&#123;</div><div class="line">            req.flash(<span class="string">'error'</span>,<span class="string">'已登录'</span>);</div><div class="line">            <span class="keyword">return</span> res.redirect(<span class="string">'back'</span>);   <span class="comment">//返回之前的页面</span></div><div class="line">        &#125;</div><div class="line">        next();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><p>项目中目前只有三个<code>model</code>，分别为<code>User</code>、<code>Post</code>及<code>Comment</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/hu33/myblog&quot;&gt;项目地址&lt;/a&gt;  目前还是bug多多~&lt;/p&gt;
&lt;p&gt;本项目完全&lt;a href=&quot;https://github.com/nswbmw/N-blog&quot;&gt;该教程&lt;/a&gt;，教程很详细很入门很通俗，本文是纯为面试准备的啦。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="项目" scheme="http://hu33.tech/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Node.js" scheme="http://hu33.tech/tags/Node-js/"/>
    
      <category term="Express" scheme="http://hu33.tech/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题（二）</title>
    <link href="http://hu33.tech/2017/07/20/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://hu33.tech/2017/07/20/面试题（二）/</id>
    <published>2017-07-20T00:33:27.091Z</published>
    <updated>2019-01-10T14:18:45.176Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CSS单位有哪些，简述其计算方法"><a href="#CSS单位有哪些，简述其计算方法" class="headerlink" title="CSS单位有哪些，简述其计算方法"></a>CSS单位有哪些，简述其计算方法</h3><p><strong>尺寸单位：</strong></p><ol><li><p>相对长度单位：<code>em</code>、<code>ex</code>、<code>px</code></p><p><code>em</code>：相对于当前对象内文本的字体尺寸，<code>1em</code>等于当前字体尺寸</p><p><code>ex</code>：相对于字符”x”的高度，通常为字体尺寸的一半，<code>1ex</code>等于当前字体的<code>x-height</code></p><p><code>px</code>：像素，相对于显示器屏幕分辨率而言</p><p><code>%</code>：百分比</p><a id="more"></a></li><li><p>绝对长度单位：<code>in</code>、<code>cm</code>、<code>mm</code>、<code>pt</code>、<code>pc</code></p><p><code>in</code>：英寸 </p><p><code>cm</code>：厘米</p><p><code>mm</code>：毫米</p><p><code>pt</code>：磅，<code>1pt=1/72in</code></p><p><code>pc</code>：12点活字，<code>1pc=12px</code></p><p><code>px</code>：像素（计算机屏幕上的一个点）</p></li><li><p>不太常见的单位：<code>rem</code>、<code>vh</code>和<code>vw</code>、<code>vmin</code>和<code>vmax</code></p><p><code>rem</code>：<code>rem</code>中的”<code>r</code>“代表”<code>root</code>“，等同于<code>font-size</code>基于根元素进行设置，在大多数情况下根元素为<code>html</code>元素</p><p><code>vh</code>：viewport高度的1/100</p><p><code>vw</code>：viewport宽度的1/100</p><p><code>vmin</code>：视口高度及宽度中最小值的1/100</p><p><code>vmax</code>：视口高度及宽度中最大值的1/100</p></li></ol><p><strong>颜色单位：</strong></p><ol><li>颜色名：如<code>red</code></li><li><code>rgb(x, x, x)</code>：<code>RGB</code>值</li><li><code>rgb(x%, x%, x%)</code>：RGB百分比值</li><li>`#rrggbb<code>：十六进制数(\#</code>ff0000`)</li></ol><blockquote><p>参考：</p><p><a href="http://www.w3school.com.cn/cssref/css_units.asp" target="_blank" rel="external">http://www.w3school.com.cn/cssref/css_units.asp</a></p><p><a href="http://www.w3cplus.com/css/7-css-units-you-might-not-know-about.html" target="_blank" rel="external">http://www.w3cplus.com/css/7-css-units-you-might-not-know-about.html</a></p></blockquote><h3 id="CSS优先顺序"><a href="#CSS优先顺序" class="headerlink" title="CSS优先顺序"></a>CSS优先顺序</h3><p><strong>层叠样式顺序：</strong></p><p>浏览器默认样式  &lt;  浏览器用户自定义样式  &lt;  外部样式表 &lt; 内部样式表 &lt; 内联样式表</p><p><strong>样式表内部选择器：</strong></p><p>类选择器 &lt; 类派生选择器 &lt; id选择器 &lt; id派生选择器</p><p><strong>生效规则：</strong></p><ul><li><p>样式表的元素选择器选择越精确，其中的样式优先级越高</p><p>id选择器指定的样式 &gt; 类选择器指定的样式 &gt; 元素类型选择器指定的样式</p></li><li><p>对于相同类型选择器指定的样式，在样式表文件中，越靠后的优先级越高</p></li><li><p>一个元素同时应用多个class，后定义的优先（就近原则）</p></li><li><p>如果要让某个样式的优先级变高，可以使用!important来指定</p></li></ul><h3 id="简述CSS单位rem，以及rem适合使用的场景"><a href="#简述CSS单位rem，以及rem适合使用的场景" class="headerlink" title="简述CSS单位rem，以及rem适合使用的场景"></a>简述CSS单位rem，以及rem适合使用的场景</h3><p><code>rem</code>是相对于<code>HTML</code>根元素的字体大小的单位</p><p>适用于响应式布局，每个元素的高宽、文字大小、行距、补白等一切可以使用长度单位的地方都可以用<code>rem</code></p><h3 id="画出一个内半径为10px，外边框白色1px的纯红色圆圈"><a href="#画出一个内半径为10px，外边框白色1px的纯红色圆圈" class="headerlink" title="画出一个内半径为10px，外边框白色1px的纯红色圆圈"></a>画出一个内半径为10px，外边框白色1px的纯红色圆圈</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.circle</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid white;</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">background-color</span>: red;</div><div class="line">  <span class="attribute">background-clip</span>: padding-box</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>感觉比较重要的两个属性是<code>border-radius</code>和<code>background-clip</code></p><h3 id="举出三个行内元素和块级元素"><a href="#举出三个行内元素和块级元素" class="headerlink" title="举出三个行内元素和块级元素"></a>举出三个行内元素和块级元素</h3><p><strong>行内元素：</strong><code>a</code>、<code>span</code>、<code>strong</code>、<code>em</code>、<code>br</code>、<code>img</code>、<code>input</code>、<code>select</code>、<code>label</code>、<code>textarea</code>、<code>cite</code></p><p><strong>块级元素：</strong><code>div</code>、<code>form</code>、<code>hr</code>、<code>h1-h6</code>、<code>p</code>、<code>ul</code>、<code>li</code>、<code>ol</code>、<code>fieldset</code>、<code>menu</code>、<code>table</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CSS单位有哪些，简述其计算方法&quot;&gt;&lt;a href=&quot;#CSS单位有哪些，简述其计算方法&quot; class=&quot;headerlink&quot; title=&quot;CSS单位有哪些，简述其计算方法&quot;&gt;&lt;/a&gt;CSS单位有哪些，简述其计算方法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;尺寸单位：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;相对长度单位：&lt;code&gt;em&lt;/code&gt;、&lt;code&gt;ex&lt;/code&gt;、&lt;code&gt;px&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;em&lt;/code&gt;：相对于当前对象内文本的字体尺寸，&lt;code&gt;1em&lt;/code&gt;等于当前字体尺寸&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ex&lt;/code&gt;：相对于字符”x”的高度，通常为字体尺寸的一半，&lt;code&gt;1ex&lt;/code&gt;等于当前字体的&lt;code&gt;x-height&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;px&lt;/code&gt;：像素，相对于显示器屏幕分辨率而言&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%&lt;/code&gt;：百分比&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>面试题（一）</title>
    <link href="http://hu33.tech/2017/07/17/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://hu33.tech/2017/07/17/面试题（一）/</id>
    <published>2017-07-17T11:40:29.277Z</published>
    <updated>2019-01-10T14:19:15.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new操作符做了哪些事"><a href="#new操作符做了哪些事" class="headerlink" title="new操作符做了哪些事"></a>new操作符做了哪些事</h3><p>new操作符接收一个函数F和参数：new F(arguments…)，它做了简单的三个步骤：</p><ol><li><strong>创建这个类的实例instance：</strong>将实例的__proto__设为F.prototype</li><li><strong>初始化实例：</strong>调用函数F并将this指向该实例</li><li><strong>判断F的返回值：</strong><ul><li>若为值类型，就丢弃它，返回该实例instance</li><li>若为引用类型，就返回这个引用类型的对象，替换掉instance</li></ul></li></ol><a id="more"></a><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">f</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> n = &#123;<span class="string">'__proto__'</span>: f.prototype&#125;;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    f.apply(n, <span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注：</p><ul><li>若函数F没有写return，相当于return undefined，JS中undefined是值类型，因此返回instance</li><li>若return this相当于返回一个引用类型的对象，这个对象就是instance，所以无所谓替换不替换</li></ul><blockquote><p>参考：<a href="http://blog.vjeux.com/2011/javascript/how-prototypal-inheritance-really-works.html" target="_blank" rel="external">http://blog.vjeux.com/2011/javascript/how-prototypal-inheritance-really-works.html</a></p></blockquote><h3 id="JS怎么判断变量的类型"><a href="#JS怎么判断变量的类型" class="headerlink" title="JS怎么判断变量的类型"></a>JS怎么判断变量的类型</h3><p>判断JS中数据类型有以下几种方法：typeof、instanceof、constructor、prototype、$.type()/jquery.type()</p><p>先举几个例子啊：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">"iamstring."</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">222</span>;</div><div class="line"><span class="keyword">var</span> c= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">111</span>);&#125;;</div><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.name=<span class="string">"22"</span>;&#125;;</div></pre></td></tr></table></figure><ol><li><p><strong>typeof（最常见）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">alert(<span class="keyword">typeof</span> a)  ------------&gt; string</div><div class="line">alert(<span class="keyword">typeof</span> b)  ------------&gt; number</div><div class="line">alert(<span class="keyword">typeof</span> c)  ------------&gt; object</div><div class="line">alert(<span class="keyword">typeof</span> d)  ------------&gt; object</div><div class="line">alert(<span class="keyword">typeof</span> e)  ------------&gt; <span class="function"><span class="keyword">function</span></span></div><div class="line"><span class="title">alert</span>(<span class="params">typeof f</span>)  ------------&gt; <span class="title">function</span></div></pre></td></tr></table></figure><p>注：typeof在判断除Object类型的对象时比较方便。</p></li><li><p><strong>instanceof（判断已知对象类型）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(c <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ---------------&gt; <span class="literal">true</span></div><div class="line">alert(d <span class="keyword">instanceof</span> <span class="built_in">Date</span>) ----------------&gt; <span class="literal">true</span></div><div class="line">alert(f <span class="keyword">instanceof</span> <span class="built_in">Function</span>) ------------&gt; <span class="literal">true</span></div><div class="line">alert(f <span class="keyword">instanceof</span> <span class="function"><span class="keyword">function</span>) ------------&gt; <span class="title">false</span></span></div></pre></td></tr></table></figure><p>注：instanceof后面一定是对象类型，该方法适合一些条件选择或分支。</p></li><li><p><strong>constructor（根据对象的constructor判断）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(c.constructor === <span class="built_in">Array</span>) ----------&gt; <span class="literal">true</span></div><div class="line">alert(d.constructor === <span class="built_in">Date</span>) -----------&gt; <span class="literal">true</span></div><div class="line">alert(e.constructor === <span class="built_in">Function</span>) -------&gt; <span class="literal">true</span></div></pre></td></tr></table></figure><p>注：constructor在类继承时可能会出错</p><p>eg:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">A.prototype = <span class="keyword">new</span> B(); <span class="comment">//A继承自B(原型链继承)</span></div><div class="line"><span class="keyword">var</span> aObj = <span class="keyword">new</span> A();</div><div class="line">alert(aobj.constructor === B) -----------&gt; <span class="literal">true</span>;</div><div class="line">alert(aobj.constructor === A) -----------&gt; <span class="literal">false</span>;</div></pre></td></tr></table></figure><p>而instanceof不会出现该问题，对象直接继承和间接继承都是true:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(aobj <span class="keyword">instanceof</span> A) ----------------&gt; <span class="literal">true</span>;</div><div class="line">alert(aobj <span class="keyword">instanceof</span> B) ----------------&gt; <span class="literal">true</span>;</div></pre></td></tr></table></figure><p>要解决这个问题，一般是将对象的constructor手动指向自己：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aobj.constructor = A; <span class="comment">//将自己的类赋值给对象的constructor属性</span></div><div class="line">alert(aobj.constructor === A) -----------&gt; <span class="literal">true</span>;</div><div class="line">alert(aobj.constructor === B) -----------&gt; <span class="literal">false</span>; <span class="comment">//基类不会报true了;</span></div></pre></td></tr></table></figure><p>所以一般继承的严格写法应该是寄生组合继承（<a href="http://hu33.tech/2017/03/11/JavaScript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/">不懂就看这里</a>）</p></li><li><p><strong>prototype（通用但繁琐）</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">alert(Object.prototype.toString.call(a) === ‘[object String]') -------&gt; true;</div><div class="line">alert(Object.prototype.toString.call(b) === ‘[object Number]') -------&gt; true;</div><div class="line">alert(Object.prototype.toString.call(c) === ‘[object Array]') -------&gt; true;</div><div class="line">alert(Object.prototype.toString.call(d) === ‘[object Date]') -------&gt; true;</div><div class="line">alert(Object.prototype.toString.call(e) === ‘[object Function]') -------&gt; true;</div><div class="line">alert(Object.prototype.toString.call(f) === ‘[object Function]') -------&gt; true;</div></pre></td></tr></table></figure><p>麻烦是麻烦了点，但是通用啊~</p></li><li><p><strong>jquery.type()（万能啊）</strong></p><p>如果对象是undefined或null，则返回相应的”undefined”或”null”：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jQuery.type( <span class="literal">undefined</span> ) === <span class="string">"undefined"</span></div><div class="line">jQuery.type() === <span class="string">"undefined"</span></div><div class="line">jQuery.type( <span class="built_in">window</span>.notDefined ) === <span class="string">"undefined"</span></div><div class="line">jQuery.type( <span class="literal">null</span> ) === <span class="string">"null"</span></div></pre></td></tr></table></figure><p>如果对象有一个内部的[[Class]]和一个浏览器的内置对象的[[Class]]相同，会返回相应的[[Class]]名字:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">jQuery.type( <span class="literal">true</span> ) === <span class="string">"boolean"</span></div><div class="line">jQuery.type( <span class="number">3</span> ) === <span class="string">"number"</span></div><div class="line">jQuery.type( <span class="string">"test"</span> ) === <span class="string">"string"</span></div><div class="line">jQuery.type( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; ) === <span class="string">"function"</span></div><div class="line">jQuery.type( [] ) === <span class="string">"array"</span></div><div class="line">jQuery.type( <span class="keyword">new</span> <span class="built_in">Date</span>() ) === <span class="string">"date"</span></div><div class="line">jQuery.type( <span class="keyword">new</span> <span class="built_in">Error</span>() ) === <span class="string">"error"</span> <span class="comment">// as of jQuery 1.9</span></div><div class="line">jQuery.type( <span class="regexp">/test/</span> ) === <span class="string">"regexp"</span></div></pre></td></tr></table></figure><p>总结一下：一般用typeof就OK了，如果预知Object类型的话可以选用instanceof或constructor，实在没辙就用$.type()好了。</p><p>​</p></li></ol><h3 id="apply和call是干什么用的？有啥区别？"><a href="#apply和call是干什么用的？有啥区别？" class="headerlink" title="apply和call是干什么用的？有啥区别？"></a>apply和call是干什么用的？有啥区别？</h3><blockquote><p>JS中通过call和apply来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为thisObj指定的新对象。简单说就是改变函数执行的上下文，换句话说，就是改变函数体内部this的指向。</p></blockquote><p>call和apply的作用完全一样，只是接收参数的方式不太一样：</p><ul><li>call(obj, arg1, arg2, arg3); call第一个参数传对象，可以是null，参数以逗号分开进行传值，参数可以是任何类型。</li><li>apply(obj, [arg1, arg2, arg3]); apply第一个参数传对象，参数可以是数组或arguments对象</li></ul><p>具体用法：</p><ul><li><p>“劫持”别人的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">  <span class="attr">name</span>:<span class="string">"mingming"</span>,</div><div class="line">  <span class="attr">logName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar=&#123;</div><div class="line">  <span class="attr">name</span>:<span class="string">"xiaowang"</span></div><div class="line">&#125;;</div><div class="line">foo.logName.call(bar);<span class="comment">//xiaowang</span></div></pre></td></tr></table></figure><p>此时foo中的logName方法被bar引用，this指向了bar</p></li><li><p>实现继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;   </div><div class="line">  <span class="keyword">this</span>.name = name;   </div><div class="line">  <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   </div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);   </div><div class="line">  &#125;   </div><div class="line">&#125;   </div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;  </div><div class="line">  Animal.call(<span class="keyword">this</span>, name);  </div><div class="line">&#125;   </div><div class="line"> </div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">"Black Cat"</span>);   </div><div class="line">cat.showName(); <span class="comment">//Black Cat</span></div></pre></td></tr></table></figure><p>借用构造函数继承时，需要用到call方法</p><p>​</p></li></ul><h3 id="两个数组去重，将去重后的数据放到新的数组中"><a href="#两个数组去重，将去重后的数据放到新的数组中" class="headerlink" title="两个数组去重，将去重后的数据放到新的数组中"></a>两个数组去重，将去重后的数据放到新的数组中</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//做比较的两个数组</span></div><div class="line"><span class="keyword">var</span> array1 = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>];<span class="comment">//数组1</span></div><div class="line"><span class="keyword">var</span> array2 = [<span class="string">'d'</span>,<span class="string">'f'</span>,<span class="string">'e'</span>,<span class="string">'a'</span>,<span class="string">'p'</span>];<span class="comment">//数组2</span></div><div class="line"></div><div class="line"><span class="comment">//临时数组存放</span></div><div class="line"><span class="keyword">var</span> tempArray1 = [];<span class="comment">//临时数组1</span></div><div class="line"><span class="keyword">var</span> tempArray2 = [];<span class="comment">//临时数组2</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;array2.length;i++)&#123;</div><div class="line">    tempArray1[array2[i]]=<span class="literal">true</span>;<span class="comment">//将数array2 中的元素值作为tempArray1 中的键，值为true；</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;array1.length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(!tempArray1[array1[i]])&#123;</div><div class="line">        tempArray2.push(array1[i]);<span class="comment">//过滤array1 中与array2 相同的元素；</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还有种比较蠢且有限制的方法，也贴出来好了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mergeArray:<span class="function"><span class="keyword">function</span> (<span class="params">arr1, arr2</span>)</span>&#123; </div><div class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; arr1.length ; i ++ )&#123;</div><div class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; arr2.length ; j ++ )&#123;</div><div class="line">    <span class="keyword">if</span> (arr1[i] === arr2[j])&#123;</div><div class="line">     arr1.splice(i,<span class="number">1</span>); <span class="comment">//利用splice函数删除元素，从第i个位置，截取长度为1的元素</span></div><div class="line">    &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">var</span> newArr = arr1.contact(arr2);</div><div class="line"> <span class="keyword">return</span> newArr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>顺便贴一下一个数组的去重吧，有好几种方式：</p><ul><li><p>遍历数组：新建一个新数组，遍历传入的数组，若值不在新数组就加入到新数组中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 最简单数组去重法 </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique1</span>(<span class="params">array</span>)</span>&#123; </div><div class="line">  <span class="keyword">var</span> n = []; <span class="comment">//一个新的临时数组 </span></div><div class="line">  <span class="comment">//遍历当前数组 </span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123; </div><div class="line">  <span class="comment">//如果当前数组的第i已经保存进了临时数组，那么跳过， </span></div><div class="line">  <span class="comment">//否则把当前项push到临时数组里面 </span></div><div class="line">    <span class="keyword">if</span> (n.indexOf(array[i]) == <span class="number">-1</span>) &#123;</div><div class="line">      n.push(array[i]);  </div><div class="line">    &#125;</div><div class="line">  &#125; </div><div class="line">  <span class="keyword">return</span> n; </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>hashtable结构：用hashtable结构记录已有元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = [], hash = &#123;&#125;;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, elem; (elem = arr[i]) != <span class="literal">null</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (!hash[elem]) &#123;</div><div class="line">      result.push(elem);</div><div class="line">      hash[elem] = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>ES6的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Map</span>()</div><div class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">a</span>) =&gt;</span> !seen.has(a) &amp;&amp; seen.set(a, <span class="number">1</span>))</div><div class="line">&#125;</div><div class="line"><span class="comment">// or</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;new操作符做了哪些事&quot;&gt;&lt;a href=&quot;#new操作符做了哪些事&quot; class=&quot;headerlink&quot; title=&quot;new操作符做了哪些事&quot;&gt;&lt;/a&gt;new操作符做了哪些事&lt;/h3&gt;&lt;p&gt;new操作符接收一个函数F和参数：new F(arguments…)，它做了简单的三个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;创建这个类的实例instance：&lt;/strong&gt;将实例的__proto__设为F.prototype&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化实例：&lt;/strong&gt;调用函数F并将this指向该实例&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;判断F的返回值：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;若为值类型，就丢弃它，返回该实例instance&lt;/li&gt;
&lt;li&gt;若为引用类型，就返回这个引用类型的对象，替换掉instance&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://hu33.tech/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://hu33.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://hu33.tech/tags/JavaScript/"/>
    
  </entry>
  
</feed>
